<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Tiny4412] 使用 SD 卡给 Tiny4412 烧写系统]]></title>
    <url>%2F2018%2F10%2F06%2Ftiny4412-download-system-by-sd-card%2F</url>
    <content type="text"><![CDATA[需要准备的东西这里我列出我通过 SD 卡给 Tiny4412 烧写系统涉及到的资源 电脑一台，电脑安装 Windows 系统，并通过 vmware 安装有 Ubuntu 虚拟机 Tiny4412 开发板一台，包括显示屏和电源线 大于 4G 的 SD 卡一张，包括小卡转大卡的 SD adapter 网线一根，路由器一个 友善之臂光盘两张，没有实际光盘可以在 百度云 中直接下载光盘镜像 刷机步骤 对 SD 卡分区，并烧写引导程序到 SD 卡中分区工具位置：光盘A盘\tools\SD-Flasher-1328\SD-Flasher.exe注意：工具软件需要使用管理员身份运行 将光盘 B 盘中的 image 目录拷贝到 SD 卡中这个 image 目录中就是系统镜像文件，进入 image 目录可以看到有三个子目录，分别是 Android、Linux、Ubuntu 相关的系统镜像文件。除了这三个文件夹，还有一个通用的引导程序和一个配置文件。 修改配置文件配置文件前几行为： CheckOneButton=No Action = Install OS = Android LowFormat = Yes VerifyNandWrite = No LCD-Mode = No CheckCRC32=No StatusType = Beeper | LED 这里我们可通过修改 OS 的值为 Android、Linux、Ubuntu 来选择要烧写哪个系统 使用 SD 卡烧写将启动开关拨到 SD 卡启动，插入制作好的 SD 卡，上电，可以在显示屏上看到进度条，同时蜂鸣器会有提示音。 使用 EMMC 启动系统进度条完成后，此时系统已经烧写成功了，掉电，将启动开关拨到 EMMC 启动，上电，可以进入系统。 通过 nfs 网络文件系统在 Ubuntu 和 Tiny4412 之间传输文件先查看下 ubuntu 的 ip 地址 user@vmware:~$ ifconfig ens33 Link encap:Ethernet HWaddr 00:0c:29:d6:8f:01 inet addr:192.168.31.178 Bcast:192.168.31.255 Mask:255.255.255.0 inet6 addr: fe80::c7e0:ff91:111f:c9cf/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:840535 errors:0 dropped:0 overruns:0 frame:0 TX packets:1385918 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:82241401 (82.2 MB) TX bytes:2467078326 (2.4 GB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:5138 errors:0 dropped:0 overruns:0 frame:0 TX packets:5138 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:416944 (416.9 KB) TX bytes:416944 (416.9 KB) 再查看下开发板的 ip 地址，这里我的板子自动获取了 ip，如果没有自动获取的话，需要使用 ifconfig eth0 &lt;ip&gt; 手动设置板子的 ip 地址 [root@FriendlyARM /]# ifconfig eth0 Link encap:Ethernet HWaddr 1C:6F:65:34:51:7E inet addr:192.168.31.153 Bcast:192.168.31.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:5363 errors:0 dropped:2 overruns:0 frame:0 TX packets:43 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:250704 (244.8 KiB) TX bytes:3103 (3.0 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 在板子上 ping 一下 Ubuntu，保证板子和 Ubuntu 在同一个局域网中，相互之前可以 ping 通 [root@FriendlyARM /]# ping 192.168.31.178 PING 192.168.31.178 (192.168.31.178): 56 data bytes 64 bytes from 192.168.31.178: seq=0 ttl=64 time=1.064 ms 64 bytes from 192.168.31.178: seq=1 ttl=64 time=0.980 ms 64 bytes from 192.168.31.178: seq=2 ttl=64 time=0.902 ms ^C --- 192.168.31.178 ping statistics --- 3 packets transmitted, 3 packets received, 0% packet loss round-trip min/avg/max = 0.902/0.982/1.064 ms 在 Ubuntu 中配置好要和板子共享的 nfs 共享目录，这里我设置的是 /home/user/board 目录作为共享目录。具体的设置步骤我就不细说了。板子上挂载 nfs 网络文件系统，实现和 Ubuntu 之间通信，这样，在 ubuntu 上编译的驱动和应用程序就可以直接传到板子上运行了。 [root@FriendlyARM /]# mount -t nfs 192.168.31.178:/home/user/board /mnt -o nolock [root@FriendlyARM /]# cd /mnt/ [root@FriendlyARM /mnt]# ls sixth_app sixth_drv.ko]]></content>
      <categories>
        <category>Tiny4412</category>
      </categories>
      <tags>
        <tag>FrindlyARM</tag>
        <tag>tiny4412</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Git] 上传大文件到 github 上]]></title>
    <url>%2F2018%2F10%2F04%2Fgit-upload-large-files%2F</url>
    <content type="text"><![CDATA[遇到问题在提交友善之臂提供的内核源码到 github 上的仓库时，遇到问题，无法正常将本地的版本库同步上传到 github 上。详细的报错信息如下： user@vmware:~/tiny4412/FriendlyARM.source.code$ git push origin Counting objects: 6, done. Compressing objects: 100% (6/6), done. Writing objects: 100% (6/6), 112.48 MiB | 2.08 MiB/s, done. Total 6 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), done. remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com. remote: error: Trace: 44eb3c8ef0f61d8703f7ccea30ee046b remote: error: See http://git.io/iEPt8g for more information. remote: error: File linux-3.5-20150929.tgz is 101.86 MB; this exceeds GitHub&apos;s file size limit of 100.00 MB To git@github.com:tiny4412/FriendlyARM.source.code.git ! [remote rejected] master -&gt; master (pre-receive hook declined) error: failed to push some refs to &apos;git@github.com:tiny4412/FriendlyARM.source.code.git&apos; 报错中提示说 File linux-3.5-20150929.tgz is 101.86 MB; this exceeds GitHub&#39;s file size limit of 100.00 MB，另外自己百度了下，了解到大于 100M 的文件需要用 git lfs 进行管理才能提交到 github。 这里引用博客Ubuntu 14.04 LTS安装Git LFS中的一段话说明下什么是 git lfs： Git LFS 是 git 支持大文件的一个工具。例如，大于 100M 的文件，多了之后用 Git 管理，经常会卡死。从 Git 1.8 之后的版本开始支持。有了 Git LFS，可以大幅度提升对大文件的支持性能。 安装 git lfs访问官网 https://git-lfs.github.com 下载 gz 包，解压执行安装脚本即可。 user@vmware:~/tiny4412/git-lfs$ ls git-lfs-linux-386-v2.5.2.tar.gz user@vmware:~/tiny4412/git-lfs$ tar -zxvf git-lfs-linux-386-v2.5.2.tar.gz README.md CHANGELOG.md git-lfs install.sh user@vmware:~/tiny4412/git-lfs$ ls CHANGELOG.md git-lfs git-lfs-linux-386-v2.5.2.tar.gz install.sh README.md user@vmware:~/tiny4412/git-lfs$ sudo ./install.sh Git LFS initialized. user@vmware:~/tiny4412/git-lfs$ git lfs version git-lfs/2.5.2 (GitHub; linux 386; go 1.10.3; git 8e3c5c93) 尝试解决因为安装 Git LFS 需要 Git 的版本不低于 1.8.5，所以安装之前，需要先查看自己的 git 版本。 user@vmware:~/tiny4412/FriendlyARM.source.code$ git --version git version 2.7.4 没问题，我的 git 版本是在 1.8 版本之后，查看下帮助信息，看看 git lfs 怎么用 user@vmware:~/tiny4412/FriendlyARM.source.code$ git lfs help git lfs &lt;command&gt; [&lt;args&gt;] Git LFS is a system for managing and versioning large files in association with a Git repository. Instead of storing the large files within the Git repository as blobs, Git LFS stores special &quot;pointer files&quot; in the repository, while storing the actual file contents on a Git LFS server. The contents of the large file are downloaded automatically when needed, for example when a Git branch containing the large file is checked out. Git LFS works by using a &quot;smudge&quot; filter to look up the large file contents based on the pointer file, and a &quot;clean&quot; filter to create a new version of the pointer file when the large file&apos;s contents change. It also uses a pre-push hook to upload the large file contents to the Git LFS server whenever a commit containing a new large file version is about to be pushed to the corresponding Git server. Commands -------- Like Git, Git LFS commands are separated into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands. High level commands -------------------- * git lfs env: Display the Git LFS environment. * git lfs checkout: Populate working copy with real content from Git LFS files. * git lfs clone: Efficiently clone a Git LFS-enabled repository. * git lfs fetch: Download Git LFS files from a remote. * git lfs fsck: Check Git LFS files for consistency. * git lfs install: Install Git LFS configuration. * git lfs lock: Set a file as &quot;locked&quot; on the Git LFS server. * git lfs locks: List currently &quot;locked&quot; files from the Git LFS server. * git lfs logs: Show errors from the Git LFS command. * git lfs ls-files: Show information about Git LFS files in the index and working tree. * git lfs migrate: Migrate history to or from Git LFS * git lfs prune: Delete old Git LFS files from local storage * git lfs pull: Fetch Git LFS changes from the remote &amp; checkout any required working tree files. * git lfs push: Push queued large files to the Git LFS endpoint. * git lfs status: Show the status of Git LFS files in the working tree. * git lfs track: View or add Git LFS paths to Git attributes. * git lfs uninstall: Uninstall Git LFS by removing hooks and smudge/clean filter configuration. * git lfs unlock: Remove &quot;locked&quot; setting for a file on the Git LFS server. * git lfs untrack: Remove Git LFS paths from Git Attributes. * git lfs update: Update Git hooks for the current Git repository. * git lfs version: Report the version number. Low level commands ------------------- * git lfs clean: Git clean filter that converts large files to pointers. * git lfs pointer: Build and compare pointers. * git lfs pre-push: Git pre-push hook implementation. * git lfs filter-process: Git process filter that converts between large files and pointers. * git lfs smudge: Git smudge filter that converts pointer in blobs to the actual content. Examples -------- To get started with Git LFS, the following commands can be used. 1. Setup Git LFS on your system. You only have to do this once per repository per machine: git lfs install 2. Choose the type of files you want to track, for examples all ISO images, with git lfs track: git lfs track &quot;*.iso&quot; 3. The above stores this information in gitattributes(5) files, so that file need to be added to the repository: git add .gitattributes 3. Commit, push and work with the files normally: git add file.iso git commit -m &quot;Add disk image&quot; git push 帮助的最后给出了使用 git lfs 的示例，那么我们就参考这个示例来提交 linux-3.5 源码文件吧 user@vmware:~/tiny4412/FriendlyARM.source.code$ git lfs track linux-3.5-20150929.tgz Tracking &quot;linux-3.5-20150929.tgz&quot; user@vmware:~/tiny4412/FriendlyARM.source.code$ git add .gitattributes user@vmware:~/tiny4412/FriendlyARM.source.code$ git push origin Counting objects: 6, done. Compressing objects: 100% (6/6), done. Writing objects: 100% (6/6), 112.48 MiB | 2.25 MiB/s, done. Total 6 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), done. remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com. remote: error: Trace: 3e6e6cee79d8ac960dc2c335eaf5326b remote: error: See http://git.io/iEPt8g for more information. remote: error: File linux-3.5-20150929.tgz is 101.86 MB; this exceeds GitHub&apos;s file size limit of 100.00 MB To git@github.com:tiny4412/FriendlyARM.source.code.git ! [remote rejected] master -&gt; master (pre-receive hook declined) error: failed to push some refs to &apos;git@github.com:tiny4412/FriendlyARM.source.code.git&apos; 还是没有成功，怎么回事，使用 git lfs 也不行，难道这个 100M 的限制不是 git 工具的限制，而是 github 的限制？还是说我之前已经将 linux-3.5 源码先提交了，导致二次 track 不生效？ 目前的提交记录为： commit e201f89c2c576c8f1e126ce582ef3b5c30711264 Author: mz8023yt &lt;mz8023yt@163.com&gt; Date: Thu Oct 4 15:27:51 2018 +0800 code: add rootfs commit 6e1d6f365264da2b933786b59e9def02e5351b6f Author: mz8023yt &lt;mz8023yt@163.com&gt; Date: Mon Sep 24 21:51:35 2018 +0800 code: add kernel commit 9b30299a4a969d9b1aab01ba32bb85c1735a5f32 Author: mz8023yt &lt;mz8023yt@163.com&gt; Date: Sun Sep 23 23:46:35 2018 +0800 code: add uboot 回退到 9b30299a4a969d9b1aab01ba32bb85c1735a5f32 节点再试一次看看 user@vmware:~/tiny4412/FriendlyARM.source.code$ mv rootfs-huangweizhong.tar.gz ../ user@vmware:~/tiny4412/FriendlyARM.source.code$ mv linux-3.5-20150929.tgz ../ user@vmware:~/tiny4412/FriendlyARM.source.code$ git reset --hard 9b30299a4a969d9b1aab01ba32bb85c1735a5f32 user@vmware:~/tiny4412/FriendlyARM.source.code$ git log commit 9b30299a4a969d9b1aab01ba32bb85c1735a5f32 Author: mz8023yt &lt;mz8023yt@163.com&gt; Date: Sun Sep 23 23:46:35 2018 +0800 code: add uboot 回退了两笔，先把 rootfs 那笔先提交掉 user@vmware:~/tiny4412/FriendlyARM.source.code$ mv ../rootfs-huangweizhong.tar.gz ./ user@vmware:~/tiny4412/FriendlyARM.source.code$ git st On branch master Your branch is up-to-date with &apos;origin/master&apos;. Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) rootfs-huangweizhong.tar.gz user@vmware:~/tiny4412/FriendlyARM.source.code$ git add --all user@vmware:~/tiny4412/FriendlyARM.source.code$ git commit -m &quot;code: add the rootfs&quot; [master 87fafa1] code: add the rootfs 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100755 rootfs-huangweizhong.tar.gz user@vmware:~/tiny4412/FriendlyARM.source.code$ git push origin Counting objects: 3, done. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 10.86 MiB | 1.34 MiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@github.com:tiny4412/FriendlyARM.source.code.git 9b30299..87fafa1 master -&gt; master user@vmware:~/tiny4412/FriendlyARM.source.code$ clear user@vmware:~/tiny4412/FriendlyARM.source.code$ git st On branch master Your branch is up-to-date with &apos;origin/master&apos;. nothing to commit, working directory clean 再重新试试使用 git lfs 提交 linux-3.5 user@vmware:~/tiny4412/FriendlyARM.source.code$ mv ../linux-3.5-20150929.tgz ./ user@vmware:~/tiny4412/FriendlyARM.source.code$ git lfs track linux-3.5-20150929.tgz Tracking &quot;linux-3.5-20150929.tgz&quot; user@vmware:~/tiny4412/FriendlyARM.source.code$ git add .gitattributes user@vmware:~/tiny4412/FriendlyARM.source.code$ git add linux-3.5-20150929.tgz user@vmware:~/tiny4412/FriendlyARM.source.code$ git commit -m &quot;code: add the kernel&quot; [master 943ad9e] code: add the kernel 2 files changed, 4 insertions(+) create mode 100644 .gitattributes create mode 100755 linux-3.5-20150929.tgz user@vmware:~/tiny4412/FriendlyARM.source.code$ git push origin Counting objects: 4, done.% (1/1), 107 MB | 1.5 MB/s Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 564 bytes | 0 bytes/s, done. Total 4 (delta 0), reused 0 (delta 0) To git@github.com:tiny4412/FriendlyARM.source.code.git 87fafa1..943ad9e master -&gt; master 很好，成功提交到了 github 上 简单总结通过这个问题得到的收获是： 大文件不要直接用 git 管理，即使没有大到 100M 以上，也要用 git lfs 来管理，提高 git 使用的性能。 我们仓库使用了 git lfs 管理，别人克隆是否也需要通过 git lfs clone 克隆，需要做实验验证下。 先提交过的文件，再通过 git lfs track 不生效，需要回退重新 track 后再 commit 才生效。 验证实验使用 git clone 直接克隆仓库，看看是否可以成功 user@vmware:~/tiny4412$ cd demo/ user@vmware:~/tiny4412/demo$ git clone git@github.com:tiny4412/FriendlyARM.source.code.git Cloning into &apos;FriendlyARM.source.code&apos;... remote: Enumerating objects: 10, done. remote: Counting objects: 100% (10/10), done. remote: Compressing objects: 100% (10/10), done. remote: Total 10 (delta 1), reused 9 (delta 0), pack-reused 0 Receiving objects: 100% (10/10), 22.01 MiB | 2.44 MiB/s, done. Resolving deltas: 100% (1/1), done. Checking connectivity... done. Downloading linux-3.5-20150929.tgz (107 MB) user@vmware:~/tiny4412/demo$ cd FriendlyARM.source.code/ user@vmware:~/tiny4412/demo/FriendlyARM.source.code$ ls linux-3.5-20150929.tgz rootfs-huangweizhong.tar.gz uboot_tiny4412-20130729.tgz 使用 git lfs clone 克隆看看 user@vmware:~/tiny4412$ mkdir demo.lfs user@vmware:~/tiny4412$ cd demo.lfs/ user@vmware:~/tiny4412/demo.lfs$ git lfs clone git@github.com:tiny4412/FriendlyARM.source.code.git Cloning into &apos;FriendlyARM.source.code&apos;... remote: Enumerating objects: 10, done. remote: Counting objects: 100% (10/10), done. remote: Compressing objects: 100% (10/10), done. remote: Total 10 (delta 1), reused 9 (delta 0), pack-reused 0 Receiving objects: 100% (10/10), 22.01 MiB | 872.00 KiB/s, done. Resolving deltas: 100% (1/1), done. Checking connectivity... done. user@vmware:~/tiny4412/demo.lfs$ 1), 107 MB | 1.5 MB/s user@vmware:~/tiny4412/demo.lfs$ cd FriendlyARM.source.code/ user@vmware:~/tiny4412/demo.lfs/FriendlyARM.source.code$ ls linux-3.5-20150929.tgz rootfs-huangweizhong.tar.gz uboot_tiny4412-20130729.tgz 看起来是两者都可以正常 clone，先记着目前的验证结论，以后有补充的话再补充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Tiny4412] 实现自己的 uboot 命令]]></title>
    <url>%2F2018%2F09%2F24%2Ftiny4412-uboot-add-hello-command%2F</url>
    <content type="text"><![CDATA[一 uboot 命令介绍Tiny 4412 开机倒数3秒计时的时候，按下 enter 键将进入 uboot 终端。输入 ? 或者 help 可以查看 uboot 支持的所有命令 TINY4412 # ? ? - alias for &apos;help&apos; base - print or set address offset bdinfo - print Board Info structure boot - boot default, i.e., run &apos;bootcmd&apos; bootd - boot default, i.e., run &apos;bootcmd&apos; bootelf - Boot from an ELF image in memory bootm - boot application image from memory bootp - boot image via network using BOOTP/TFTP protocol bootvx - Boot vxWorks from an ELF image chpart - change active partition cmp - memory compare coninfo - print console devices and information cp - memory copy crc32 - checksum calculation dcache - enable or disable data cache dnw - dnw - initialize USB device and ready to receive for Windows server (specific) echo - echo args to console editenv - edit environment variable emmc - Open/Close eMMC boot Partition env - environment handling commands exit - exit script ext2format- ext2format - disk format by ext2 ext2load- load binary file from a Ext2 filesystem ext2ls - list files in a directory (default /) ext3format- ext3format - disk format by ext3 false - do nothing, unsuccessfully fastboot- fastboot- use USB Fastboot protocol fatformat- fatformat - disk format by FAT32 fatinfo - fatinfo - print information about filesystem fatload - fatload - load binary file from a dos filesystem fatls - list files in a directory (default /) fdisk - fdisk for sd/mmc. go - start application at address &apos;addr&apos; help - print command description/usage icache - enable or disable instruction cache iminfo - print header information for application image imxtract- extract a part of a multi-image itest - return true/false on integer compare loadb - load binary file over serial line (kermit mode) loads - load S-Record file over serial line loady - load binary file over serial line (ymodem mode) loop - infinite loop on address range md - memory display mm - memory modify (auto-incrementing address) mmc - MMC sub system mmcinfo - mmcinfo &lt;dev num&gt;-- display MMC info movi - movi - sd/mmc r/w sub system for SMDK board mtdparts- define flash/nand partitions mtest - simple RAM read/write test mw - memory write (fill) nfs - boot image via network using NFS protocol nm - memory modify (constant address) ping - send ICMP ECHO_REQUEST to network host printenv- print environment variables reginfo - print register information reset - Perform RESET of the CPU run - run commands in an environment variable saveenv - save environment variables to persistent storage setenv - set environment variables showvar - print local hushshell variables sleep - delay execution for some time source - run script from memory test - minimal test like /bin/sh tftpboot- boot image via network using TFTP protocol true - do nothing, successfully usb - USB sub-system version - print monitor version uboot 支持很多命令，命令对应的源文件都在 common 目录下 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/common$ ls bedbug.c cmd_exit.o cmd_mii.c cmd_source.c dlmalloc.c kgdb.c cmd_ambapp.c cmd_ext2.c cmd_misc.c cmd_source.o dlmalloc.o kgdb_stubs.c cmd_bdinfo.c cmd_ext2.o cmd_misc.o cmd_spibootldr.c dlmalloc.src lcd.c cmd_bdinfo.o cmd_fastboot.c cmd_mmc.c cmd_spi.c env_auto.c libcommon.o cmd_bedbug.c cmd_fastboot.o cmd_mmc_fdisk.c cmd_strings.c env_auto.o lynxkdi.c cmd_bmp.c cmd_fat.c cmd_mmc_fdisk.o cmd_terminal.c env_common.c main.c cmd_boot.c cmd_fat.o cmd_mmc.o cmd_test.c env_common.o main.o cmd_bootldr.c cmd_fdc.c cmd_movi.c cmd_test.o env_dataflash.c Makefile cmd_bootm.c cmd_fdos.c cmd_movi.o cmd_tsi148.c env_eeprom.c memsize.c cmd_bootm.o cmd_fdt.c cmd_mp.c cmd_ubi.c env_embedded.c memsize.o cmd_boot.o cmd_flash.c cmd_mtdparts.c cmd_ubifs.c env_flash.c miiphyutil.c cmd_cache.c cmd_fpga.c cmd_mtdparts.o cmd_universe.c env_mgdisk.c modem.c cmd_cache.o cmd_help.c cmd_nand.c cmd_usb.c env_mmc.c serial.c cmd_console.c cmd_help.o cmd_net.c cmd_usbd3.c env_nand.c serial.o cmd_console.o cmd_i2c.c cmd_net.o cmd_usbd.c env_nowhere.c s_record.c cmd_cplbinfo.c cmd_ide.c cmd_nvedit.c cmd_usbd.o env_nvram.c s_record.o cmd_cramfs.c cmd_immap.c cmd_nvedit.o cmd_usb.o env_onenand.c stdio.c cmd_dataflash_mmc_mux.c cmd_irq.c cmd_onenand.c cmd_version.c env_sf.c stdio.o cmd_date.c cmd_itest.c cmd_otp.c cmd_version.o exports.c system_map.c cmd_dcr.c cmd_itest.o cmd_pci.c cmd_vfd.c exports.o update.c cmd_df.c cmd_jffs2.c cmd_pcmcia.c cmd_ximg.c fdt_support.c usb.c cmd_diag.c cmd_license.c cmd_pcmcia.o cmd_ximg.o flash.c usb_kbd.c cmd_display.c cmd_load.c cmd_portio.c cmd_yaffs2.c flash.o usb.o cmd_dtt.c cmd_load.o cmd_reginfo.c command.c hush.c usb_storage.c cmd_echo.c cmd_log.c cmd_reginfo.o command.o hush.o xyzModem.c cmd_echo.o cmd_mac.c cmd_reiser.c console.c hwconfig.c xyzModem.o cmd_eeprom.c cmd_mem.c cmd_sata.c console.o image.c cmd_elf.c cmd_mem.o cmd_scsi.c ddr_spd.c image.o cmd_elf.o cmd_mfsl.c cmd_setexpr.c decompress_ext4.c iomux.c cmd_exit.c cmd_mgdisk.c cmd_sf.c decompress_ext4.o kallsyms.c 每一个命令都由 U_BOOT_CMD 宏描述，宏定义的位置在 include/command.h 文件中，感兴趣的小伙伴可以去研究下。 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ grep -rsnE &quot; U_BOOT_CMD(&quot; include/command.h:112:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ include/command.h:120:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ doc/README.commands:5:Then using the U_BOOT_CMD() macro to fill in a cmd_tbl_t struct. 二 分析 help 命令这里我们分析下 help 命令来了解 uboot 命令的结构。common/cmd_help.c 文件内容如下： #include &lt;common.h&gt; #include &lt;command.h&gt; extern cmd_tbl_t __u_boot_cmd_bdinfo; extern cmd_tbl_t __u_boot_cmd_showvar; int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[]) { return _do_help(&amp;__u_boot_cmd_bdinfo, &amp;__u_boot_cmd_showvar - &amp;__u_boot_cmd_bdinfo + 1, cmdtp, flag, argc, argv); } U_BOOT_CMD( help, CONFIG_SYS_MAXARGS, 1, do_help, &quot;print command description/usage&quot;, &quot;\n&quot; &quot; - print brief description of all commands\n&quot; &quot;help command ...\n&quot; &quot; - print detailed usage of &apos;command&apos;&quot; ); /* This does not use the U_BOOT_CMD macro as ? can&apos;t be used in symbol names */ cmd_tbl_t __u_boot_cmd_question_mark Struct_Section = { &quot;?&quot;, CONFIG_SYS_MAXARGS, 1, do_help, &quot;alias for &apos;help&apos;&quot;, #ifdef CONFIG_SYS_LONGHELP &quot;&quot; #endif /* CONFIG_SYS_LONGHELP */ }; 三 编写一个自定义的 hello 命令从 help 命令的实现，猜测实现一个新的 uboot cmd 的步骤为： 在 common 目录下创建 cmd_hello.c 文件 包含头文件 #include &lt;common.h&gt; #include &lt;command.h&gt; 使用 U_BOOT_CMD 定义一个命令 U_BOOT_CMD ( &lt;命令的名称&gt;, &lt;最大参数个数&gt;, &lt;重复次数&gt;, &lt;命令底层执行的回调函数&gt;, &lt;说明命令的功能&gt;, &lt;说明命令的详细用法&gt; ); 实现回调函数函数原型为 /** * @param cmdtp 描述命令的结构体，保存了 U_BOOT_CMD * @param flag * @param argc 命令传入的参数的个数 * @param argv 命令传入的参数 */ int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[]) 四 编译 uboot 命令 将实现的 cmd_hello.c 放到 common 目录下 修改 Makefile，将 cmd_hello.c 包含到到编译系统中 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git diff diff --git a/common/Makefile b/common/Makefile old mode 100644 new mode 100755 index bfa39d5..92b9a66 --- a/common/Makefile +++ b/common/Makefile @@ -48,6 +48,7 @@ COBJS-y += cmd_bootm.o COBJS-y += cmd_help.o COBJS-y += cmd_nvedit.o COBJS-y += cmd_version.o +COBJS-y += cmd_hello.o # environment COBJS-y += env_common.o 重新编译 下载验证 TINY4412 # hello xxx hello - this is a demo command Usage: hello - this is a demo long help TINY4412 # hello hello uboot]]></content>
      <categories>
        <category>Tiny4412</category>
      </categories>
      <tags>
        <tag>FrindlyARM</tag>
        <tag>tiny4412</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Tiny4412] 搭建 Linux3.5 开发环境]]></title>
    <url>%2F2018%2F09%2F23%2Ftiny4412-build-the-dev-env%2F</url>
    <content type="text"><![CDATA[前言最近在学习 V4L2 编程，刚好自己手头上有一块 Tiny4412 的板子和一个免驱的摄像头。因此想在 Tiny4412 的板子上做实验，在实践中学习。本文做为第一篇文章，在 Tiny4412 板子上搭建 Linux 系统。 一 配置编译烧写 u-boot1.1 获取 uboot 源码和交叉工具链uboot 源码和交叉工具链可以在 Tiny4412 附赠的光盘中获取，没有光盘的小伙伴可以访问我的 github 仓库获取。 获取交叉工具链 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.tool.chain.git 获取 uboot 源码 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.source.code.git 这里我是直接从光盘中拷贝的，放在 ~/tiny4412 目录下。 user@vmware:~/tiny4412$ ls arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz uboot_tiny4412-20130729.tgz 1.2 创建仓库管理 uboot 源码在 github 上创建一个名为 FriendlyARM.uboot-2010.12 的空仓库，克隆到本地 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.uboot-2010.12.git Cloning into &apos;FriendlyARM.uboot-2010.12&apos;... Warning: Permanently added the RSA host key for IP address &apos;192.30.253.112&apos; to the list of known hosts. warning: You appear to have cloned an empty repository. Checking connectivity... done. 解压 uboot 源码，并将源码移动到仓库目录中进行管理 user@vmware:~/tiny4412$ tar zxvf uboot_tiny4412-20130729.tgz user@vmware:~/tiny4412$ mv uboot_tiny4412/* FriendlyARM.uboot-2010.12/ 提交第一笔提交，记录最原始的 uboot 源码状态 user@vmware:~/tiny4412$ cd FriendlyARM.uboot-2010.12/ user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ make clean user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ make distclean user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git add --all user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git commit -m &quot;init: get the u-boot source code by friendly arm&quot; user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git push origin -u master 1.3 安装交叉编译器这里其实也没有什么安装一说，就是将交叉编译器解压出来，后续编译 uboot 的时候，修改 uboot 编译 Makefile 指定交叉编译器用我们现在解压的这个而已 user@vmware:~/tiny4412$ tar zxvf arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz 1.4 指定 uboot 使用的交叉编译器通过修改 arch/arm/config.mk 指定交叉编译器 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git diff diff --git a/arch/arm/config.mk b/arch/arm/config.mk index 24f8982..a454343 100644 --- a/arch/arm/config.mk +++ b/arch/arm/config.mk @@ -21,7 +21,7 @@ # MA 02111-1307 USA # -CROSS_COMPILE ?= arm-linux- +CROSS_COMPILE ?= /home/user/tiny4412/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- ifeq ($(BOARD),omap2420h4) STANDALONE_LOAD_ADDR = 0x80300000 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git add --all user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git commit -m &quot;conf: modify the cross compiler&quot; user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git push origin 1.5 配置编译 uboot配置 uboot user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ make tiny4412_config Configuring for tiny4412 board... 编译 uboot user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ make 确认到 u-boot.bin 镜像成功生成 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ ls -l u-boot.bin -rw-rw-r-- 1 user user 276932 9月 23 22:36 u-boot.bin 1.6 给 u-boot 添加 .gitignore 文件查看发现全是编译的中间文件，这些文件根本不需使用版本库进行管理，因此我们要忽略它们。随便找一个 kernel 源码中拷贝一个 kernel 默认的忽略规则过来就好。这里我拷贝的是 mini2440 用到的 linux-2.6.22.6 中的忽略规则。 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ cp ../../mini2440/linux-2.6.22.6/.gitignore ./ 将 kernel 默认的忽略文件拷贝到 u-boot 源码中，很好，大部分的中间文件都成功忽略了，但是通过 git st 查看还是有部分中间文件没有被忽略。因此将剩余的中间文件都追加到 .gitignore 文件中。需要追加的列表有： # don&apos;t ignore the .gitignore file !.gitignore arch/arm/include/asm/arch arch/arm/include/asm/proc examples/standalone/hello_world examples/standalone/hello_world.bin examples/standalone/hello_world.srec include/autoconf.mk include/autoconf.mk.dep include/config.h include/config.mk include/generated/ include/timestamp_autogenerated.h include/version_autogenerated.h tools/gen_eth_addr tools/img2srec tools/mkimage u-boot u-boot.bin u-boot.lds u-boot.map u-boot.srec 将忽略规则提交 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git add --all user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git commit -m &quot;conf: add the gitignore rule&quot; user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ git push origin 1.7 烧写 uboot通过 uboot 中提供的脚本可以将 uboot 烧写到 sd 卡中，之后便可以通过 sd 卡启动 uboot。另外由于我是在虚拟机上编译的 uboot，因此，sd 卡接在 windows 上，需要在虚拟机右下角找到 sd 卡设备，断开其 windows 主机的连接，让其连接到虚拟机中。sd 卡在虚拟机中正确识别后，在 /dev 目录下将会自动创建对应的设备节点 sd 卡未接入 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse/tiny4412$ ls /dev/sd* /dev/sda /dev/sda1 /dev/sda2 /dev/sda5 sd 卡接入后 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse/tiny4412$ ls /dev/sd* /dev/sda /dev/sda1 /dev/sda2 /dev/sda5 /dev/sdb /dev/sdb1 确认到 sd 卡是 /dev/sdb 节点后，就可以开始用脚本烧写了，但是烧写依赖 mkbl2 镜像，因此要先生成它。 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12$ cd sd_fuse/ user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse$ ls Makefile sd_fdisk.c tiny4412 V310-EVT1-mkbl2.c user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse$ make gcc -o mkbl2 V310-EVT1-mkbl2.c gcc -o sd_fdisk sd_fdisk.c user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse$ ls Makefile mkbl2 sd_fdisk sd_fdisk.c tiny4412 V310-EVT1-mkbl2.c 执行烧写脚本烧写 uboot，使用方法为 ./sd_fusing.sh /dev/sdb，值得注意的是，需要加 sudo 添超级权限才可以读写 sdb。 user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse$ cd tiny4412/ user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse/tiny4412$ ls E4412_N.bl1.bin E4412_tzsw.bin fast_fuse.sh sd_fusing.sh user@vmware:~/tiny4412/FriendlyARM.uboot-2010.12/sd_fuse/tiny4412$ sudo ./sd_fusing.sh /dev/sdb /dev/sdb reader is identified. --------------------------------------- BL1 fusing 16+0 records in 16+0 records out 8192 bytes (8.2 kB, 8.0 KiB) copied, 0.203274 s, 40.3 kB/s --------------------------------------- BL2 fusing 28+0 records in 28+0 records out 14336 bytes (14 kB, 14 KiB) copied, 0.444371 s, 32.3 kB/s --------------------------------------- u-boot fusing 541+1 records in 541+1 records out 276996 bytes (277 kB, 271 KiB) copied, 1.9351 s, 143 kB/s --------------------------------------- TrustZone S/W fusing 184+0 records in 184+0 records out 94208 bytes (94 kB, 92 KiB) copied, 0.721558 s, 131 kB/s --------------------------------------- U-boot image is fused successfully. Eject SD card and insert it again. 1.8 用 sd 卡启动验证是否烧录成功将 SD 卡插入板子中，使用 SD 卡启动，出现如下打印，说明编译烧写成功，如不成功，请仔细 check 上述每一个步骤 OK U-Boot 2010.12-00000-gcfd8b91 (Sep 23 2018 - 22:36:26) for TINY4412 CPU: S5PC220 [Samsung SOC on SMP Platform Base on ARM CortexA9] APLL = 1400MHz, MPLL = 800MHz Board: TINY4412 DRAM: 1023 MiB vdd_arm: 1.2 vdd_int: 1.0 vdd_mif: 1.1 BL1 version: N/A (TrustZone Enabled BSP) Checking Boot Mode ... SDMMC REVISION: 1.1 MMC Device 0: 7460 MB MMC Device 1: 3728 MB MMC Device 2: N/A *** Warning - using default environment Net: No ethernet found. Hit any key to stop autoboot: 0 TINY4412 # TINY4412 # TINY4412 # TINY4412 # 二 配置编译烧写 linux 内核2.1 获取 linux 源码linux 源码可以在 Tiny4412 附赠的光盘中获取，没有光盘的小伙伴可以访问我的 github 仓库获取。 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.source.code.git 这里我是直接从光盘中拷贝的，放在 ~/tiny4412 目录下。 user@vmware:~/tiny4412$ ls FriendlyARM.source.code FriendlyARM.tool.chain FriendlyARM.uboot-2010.12 linux-3.5-20150929.tgz opt 2.2 创建仓库管理 linux 源码在 github 上创建一个名为 FriendlyARM.linux-3.5 的空仓库，克隆到本地 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.linux-3.5.git Cloning into &apos;FriendlyARM.linux-3.5&apos;... warning: You appear to have cloned an empty repository. Checking connectivity... done. 解压 linux 源码，并将源码移动到仓库目录中进行管理 user@vmware:~/tiny4412$ tar zxf linux-3.5-20150929.tgz user@vmware:~/tiny4412$ mv linux-3.5/* FriendlyARM.linux-3.5/ 提交第一笔提交，记录最原始的 linux 源码状态 user@vmware:~/tiny4412$ cd FriendlyARM.linux-3.5/ user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ make clean user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ make distclean user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git add --all user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git commit -m &quot;init: get the linux source code by friendly arm&quot; user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git push origin -u master 2.3 指定 linux 使用的交叉编译器通过修改顶层 Makefile 指定交叉编译器 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git diff diff --git a/Makefile b/Makefile old mode 100644 new mode 100755 index 371e0e4..053f911 --- a/Makefile +++ b/Makefile @@ -194,7 +194,7 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \ export KBUILD_BUILDHOST := $(SUBARCH) #ARCH ?= $(SUBARCH) ARCH ?= arm -CROSS_COMPILE ?= $(CONFIG_CROSS_COMPILE:&quot;%&quot;=%) +CROSS_COMPILE ?= /home/user/tiny4412/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- # Architecture as present in compile.h UTS_MACHINE := $(ARCH) user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git add --all user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git commit -m &quot;conf: modify the cross compiler&quot; user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git push origin 2.4 配置内核修改友善之臂官网提供的配置文件，关闭 trustzone 功能 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git diff diff --git a/tiny4412_linux_defconfig b/tiny4412_linux_defconfig old mode 100644 new mode 100755 index 8da9719..c2b29bd --- a/tiny4412_linux_defconfig +++ b/tiny4412_linux_defconfig @@ -482,7 +482,7 @@ CONFIG_CPU_CP15_MMU=y # # Processor Features # -CONFIG_ARM_TRUSTZONE=y +# CONFIG_ARM_TRUSTZONE is not set # CONFIG_ARM_LPAE is not set # CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set CONFIG_ARM_THUMB=y user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git add --all user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git commit -m &quot;conf: disable the trustzone&quot; user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git push origin 使用友善之臂提供的配置文件来配置内核 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ cp tiny4412_linux_defconfig .config 2.5 编译内核内核配置好后，直接执行 make 开始编译即可 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ make ... ... TIMEC kernel/timeconst.h Can&apos;t use &apos;defined(@array)&apos; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373. /home/user/tiny4412/FriendlyARM.linux-3.5/kernel/Makefile:133: recipe for target &apos;kernel/timeconst.h&apos; failed make[1]: *** [kernel/timeconst.h] Error 255 Makefile:776: recipe for target &apos;kernel&apos; failed make: *** [kernel] Error 2 报错了，不慌，百度了解到需要做如下修改 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git add kernel/timeconst.pl user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git diff --cached diff --git a/kernel/timeconst.pl b/kernel/timeconst.pl old mode 100644 new mode 100755 index eb51d76..0461239 --- a/kernel/timeconst.pl +++ b/kernel/timeconst.pl @@ -370,7 +370,7 @@ if ($hz eq &apos;--can&apos;) { } @val = @{$canned_values{$hz}}; - if (!defined(@val)) { + if (!@val) { @val = compute_values($hz); } output($hz, @val);user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git diff --cached diff --git a/kernel/timeconst.pl b/kernel/timeconst.pl old mode 100644 new mode 100755 index eb51d76..0461239 --- a/kernel/timeconst.pl +++ b/kernel/timeconst.pl @@ -370,7 +370,7 @@ if ($hz eq &apos;--can&apos;) { } @val = @{$canned_values{$hz}}; - if (!defined(@val)) { + if (!@val) { @val = compute_values($hz); } output($hz, @val); 修改好后重新 make 成功了，确认到成功生成内核镜像 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ ls -l arch/arm/boot/zImage -rwxrwxr-x 1 user user 4783472 9月 24 16:32 arch/arm/boot/zImage 2.6 给 linux 添加 .gitignore 文件原本内核都是自带 ,gitignore 文件的，但是友善之臂提供的内核却没有，因此我们需要手动添加下忽略规则。 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ cp ../FriendlyARM.uboot-2010.12/.gitignore ./ 同样，参考 uboot 中修改 ignore 规则一样，还是有部分中间文件没有被忽略。因此将剩余的中间文件都追加到 .gitignore 文件中。并将忽略规则提交 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git add --all user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git commit -m &quot;conf: add the gitignore rule&quot; user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ git push origin 2.7 烧写内核通过 dd 命令将内核烧写到 SD 卡中，dd 使用格式为： dd iflag=dsync oflag=dsync if=&lt;烧写的文件名称&gt; of=&lt;指定烧写的设备&gt; seek=&lt;跳过块数量&gt; UBOOT默认情况下是从SD卡的1057块开始读取内核映像。位置可以随意写，但是不能将前面的UBOOT代码覆盖掉。 user@vmware:~/tiny4412/FriendlyARM.linux-3.5$ sudo dd iflag=dsync oflag=dsync if=arch/arm/boot/zImage of=/dev/sdb seek=1057 [sudo] password for user: 9342+1 records in 9342+1 records out 4783472 bytes (4.8 MB, 4.6 MiB) copied, 42.1633 s, 113 kB/s 2.8 用 sd 卡启动验证是否烧录成功将 SD 卡插入板子中，使用 SD 卡启动，出现如下打印，说明编译烧写成功，如不成功，请仔细 check 上述每一个步骤 OK U-Boot 2010.12-00000-gbf8103b-dirty (Sep 24 2018 - 09:19:16) for TINY4412 CPU: S5PC220 [Samsung SOC on SMP Platform Base on ARM CortexA9] APLL = 1400MHz, MPLL = 800MHz Board: TINY4412 DRAM: 1023 MiB vdd_arm: 1.2 vdd_int: 1.0 vdd_mif: 1.1 BL1 version: N/A (TrustZone Enabled BSP) Checking Boot Mode ... SDMMC REVISION: 1.1 MMC Device 0: 7460 MB MMC Device 1: 3728 MB MMC Device 2: N/A *** Warning - using default environment Net: No ethernet found. Hit any key to stop autoboot: 0 reading kernel..device 0 Start 1057, Count 12288 MMC read: dev # 0, block # 1057, count 12288 ... 12288 blocks read: OK completed reading RFS..device 0 Count 13345, Start 2048 MMC read: dev # 0, block # 13345, count 2048 ... 2048 blocks read: OK completed Boot with zImage Wrong Ramdisk Image Format [err] boot_get_ramdisk Starting kernel ... Uncompressing Linux... done, booting the kernel. [ 0.000000] Booting Linux on physical CPU 0 [ 0.000000] Initializing cgroup subsys cpu [ 0.000000] Linux version 3.5.0-FriendlyARM-gd4bb223-dirty (user@vmware) (gcc version 4.5.1 (ctng-1.8.1-FA) ) #1 SMP PREEMPT Mon Sep 24 16:31:49 CST 2018 如果此时接了屏幕的话，还可以看到屏幕上出现企鹅图标。 三 构建根文件系统我们知道 linux 中一切皆文件，linux 的运行少不了文件文件系统中的系统文件的支持，就好比 windows 电脑如果没有 c 盘中的 windows 系统文件，windows 系统也是无法运行起来的。因此要让我们自己编译的 linux 系统运行起来，必须提供系统需要的对应的系统文件，这些系统文件包括常用的可执行程序，如 ls、cd 等我们常用的命令的其他 linux 系统服务需要用到的配置文件。 这里我们要用到 busybox 工具去生成我们自己的 linux 系统需要需要到的工具，以及通过拷贝我们使用的 ubuntu 主机上的配置文件作为我们班子上 linux 的配置文件， 3.1 获取 busybox可以从官网下载最新版本，也可以从我的 github 仓库中获取我本文使用的 busybox-1.23.2 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.tool.chain.git 解压得到 busybox 源码 user@vmware:~/tiny4412$ tar -jxvf busybox-1.23.2.tar.bz2 user@vmware:~/tiny4412$ ls busybox-1.23.2 FriendlyARM.uboot-2010.12 FriendlyARM.tool.chain opt busybox-1.23.2.tar.bz2 FriendlyARM.source.code FriendlyARM.linux-3.5 3.2 创建仓库管理根文件系统在 github 上创建一个名为 FriendlyARM.rootfs 的空仓库，克隆到本地 user@vmware:~/tiny4412$ git clone git@github.com:tiny4412/FriendlyARM.rootfs.git Cloning into &apos;FriendlyARM.rootfs&apos;... warning: You appear to have cloned an empty repository. Checking connectivity... done. 3.3 配置编译 busybox先配置 busybox，进入到解压目录下。敲 make menuconfig 命令进入图形配置菜单 user@vmware:~/tiny4412/busybox-1.23.2$ make menuconfig 分别进行以下配置： 配置 busybox 的编译器为 /home/user/tiny4412/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- Busybox Settings --&gt; Build Options --&gt; (/home/user/tiny4412/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-) Cross Compiler prefix 配置 busybox 编译安装的目录为 /home/user/tiny4412/FriendlyARM.rootfs Busybox Settings --&gt; Installation Options (&quot;make install&quot; behavior) --&gt; (/home/user/tiny4412/FriendlyARM.rootfs) BusyBox installation prefix 我在配置的时候，遇到 BusyBox installation prefix 无法编辑的情况，就是可以进入编辑框，但是无法删除原来的配置，退格键没有用。遇到这种情况的话，可以先执行 make menuconfig 生成 .config 配置文件，然后用文本编辑器手动修改下面两个宏为对应的值效果也是一样的。 user@vmware:~/tiny4412/busybox-1.23.2$ cat .config | grep tiny4412 CONFIG_CROSS_COMPILER_PREFIX=&quot;/home/user/tiny4412/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-&quot; CONFIG_PREFIX=&quot;/home/user/tiny4412/FriendlyARM.rootfs&quot; 配置好后，开始编译安装 busybox user@vmware:~/tiny4412/busybox-1.23.2$ make user@vmware:~/tiny4412/busybox-1.23.2$ make install 安装好后，将会在安装目标目录，也就是 make menuconfig 中指定的 FriendlyARM.rootfs 目录中生产以下文件 user@vmware:~/tiny4412/busybox-1.23.2$ cd ../FriendlyARM.rootfs/ user@vmware:~/tiny4412/FriendlyARM.rootfs$ ls bin linuxrc sbin usr 使用 ls -l 查看下，不难看出，这些生成的可执行文件都是到 busybox 的链接 ls -l bin/* sbin/* usr/* linuxrc lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/cat -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/chmod -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/conspy -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/cp -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/dmesg -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/echo -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/grep -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/gunzip -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/gzip -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/ln -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/ls -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/mv -&gt; busybox lrwxrwxrwx 1 user user 7 9月 24 22:02 bin/ping -&gt; busybox lrwxrwxrwx 1 user user 11 9月 24 22:02 linuxrc -&gt; bin/busybox 3.4 制作根文件系统 完善 linux 系统根目录下的目录 user@vmware:~/tiny4412/FriendlyARM.rootfs$ mkdir -p lib dev etc/init.d home proc sys root opt tmp var mnt user@vmware:~/tiny4412/FriendlyARM.rootfs$ ls bin dev etc home lib linuxrc mnt opt proc root sbin sys tmp usr var 拷贝共享库到 rootfs/lib 目录下 user@vmware:~/tiny4412/FriendlyARM.rootfs$ cp -rfdv ../opt/FriendlyARM/toolschain/4.5.1/arm-none-linux-gnueabi/lib/* lib/ 拷贝分组和密码文件到 rootfs/etc 目录下 user@vmware:~/tiny4412/FriendlyARM.rootfs$ cp /etc/group etc/ user@vmware:~/tiny4412/FriendlyARM.rootfs$ cp /etc/passwd etc/ 创建 fstab 文件 user@vmware:~/tiny4412/FriendlyARM.rootfs$ cp /etc/fstab etc/ 创建 inittab 文件 user@vmware:~/tiny4412/FriendlyARM.rootfs$ vim etc/inittab user@vmware:~/tiny4412/FriendlyARM.rootfs$ cat etc/inittab ::sysinit:/etc/init.d/rcS console::respawn:-/bin/sh ::ctrlaltdel:/sbin/reboot ::shutdown:/bin/umount -a -r 解释以上代码： ::sysinit:/etc/init.d/rcS # 定义系统上电执行的初始化文件。 console::respawn:-/bin/sh # 指定控制台的脚本解释器和进入控制台的模式。可选的模式有 # 1. askfirst 进入命令行需要按回车键确认 # 2. respawn 进入命令行不需要按回车键确认 ::ctrlaltdel:/sbin/reboot # 指定系统重启命令。 ::shutdown:/bin/umount -a -r # 指定系统关机前执行的命令 创建 etc/init.d/rcS 文件 user@vmware:~/tiny4412/FriendlyARM.rootfs$ vim etc/init.d/rcS user@vmware:~/tiny4412/FriendlyARM.rootfs$ cat etc/init.d/rcS #!/bin/sh mount -a mkdir /dev/pts mount -t devpts devpts /dev/pts echo /sbin/mdev &gt; /proc/sys/kernel/hotplug mdev -s /bin/hostname Maziot 注意, rcS 文件是一个脚本文件，必须有可执行权限 user@vmware:~/tiny4412/FriendlyARM.rootfs$ chmod 777 etc/init.d/rcS user@vmware:~/tiny4412/FriendlyARM.rootfs$ ll etc/init.d/rcS -rwxrwxrwx 1 user user 130 10月 5 19:49 etc/init.d/rcS* 其中 mdev -s 命令会根据安装的驱动自动在 dev 目录下创建设备节点 创建 etc/profile 文件 user@vmware:~/tiny4412/FriendlyARM.rootfs$ vim etc/profile user@vmware:~/tiny4412/FriendlyARM.rootfs$ cat etc/profile USER=&quot;id-un&quot; LOGNAME=$USER PS1=&apos;[\u@\h \w]\# &apos; PATH=$PATH HOSTNAME=&apos;/bin/hostname&apos; export USER LOGNAME PS1 PATH 其中 PS1 环境变量保存的是当前命令行终端提示符显示的格式 3.5 将制作好的文件系统上传到 github 管理由于 git 默认不管理空目录，但是文件系统中一些的特定的目录结构是需要存在的，因此需要将空目录也提交的 github 上。参考立体风的博客了解到，如要想要提交空目录 mnt 到 github 上，只需要在该目录下创建 .gitkeep 文件即可。 user@vmware:~/tiny4412/FriendlyARM.rootfs$ touch dev/.gitkeep home/.gitkeep opt/.gitkeep proc/.gitkeep sys/.gitkeep tmp/.gitkeep var/.gitkeep mnt/.gitkeep user@vmware:~/tiny4412/FriendlyARM.rootfs$ git add --all user@vmware:~/tiny4412/FriendlyARM.rootfs$ git commit -m &quot;conf: create the root file system&quot; user@vmware:~/tiny4412/FriendlyARM.rootfs$ git push origin 3.6 配置 nfs 共享目录编辑 nfs 服务的配置文件，将 /home/user/tiny4412/FriendlyARM.rootfs 目录加入共享目录 user@vmware:~/tiny4412/FriendlyARM.rootfs$ sudo vim /etc/exports user@vmware:~/tiny4412/FriendlyARM.rootfs$ cat /etc/exports # /etc/exports: the access control list for filesystems which may be exported # to NFS clients. See exports(5). # # Example for NFSv2 and NFSv3: # /srv/homes hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check) # # Example for NFSv4: # /srv/nfs4 gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check) # /srv/nfs4/homes gss/krb5i(rw,sync,no_subtree_check) # /home/user/board/ *(rw,sync,no_root_squash) /home/user/tiny4412/rootfs *(rw,no_root_squash,sync) /home/user/tiny4412/FriendlyARM.rootfs *(rw,sync,no_root_squash) 加入后重启 nfs 服务 user@vmware:~/tiny4412/FriendlyARM.rootfs$ sudo /etc/init.d/nfs-kernel-server restart [ ok ] Restarting nfs-kernel-server (via systemctl): nfs-kernel-server.service. 重启 nfs 服务后，本地验证下 nfs 配置是否生效 user@vmware:~/tiny4412$ sudo mount -t nfs 192.168.31.178:/home/user/tiny4412/FriendlyARM.rootfs /mnt -o nolock user@vmware:~/tiny4412$ cd /mnt/ user@vmware:/mnt$ ls bin dev etc home lib linuxrc opt proc root sbin sys tmp usr var user@vmware:/mnt$ touch fs1 user@vmware:/mnt$ cd - /home/user/tiny4412 user@vmware:~/tiny4412$ cd FriendlyARM.rootfs/ user@vmware:~/tiny4412/FriendlyARM.rootfs$ ls bin dev etc fs1 home lib linuxrc opt proc root sbin sys tmp usr var user@vmware:~/tiny4412/FriendlyARM.rootfs$ rm -rf fs1 确认到配置是没问题的 3.7 设置 uboot 启动参数从 sd 启动，开机倒数计时按下 enter 进入 uboot 命令行，重新设置 bootargs 环境变量，设置为 nfs 方式挂载文件系统 Checking Boot Mode ... SDMMC REVISION: 1.1 MMC Device 0: 7460 MB MMC Device 1: 3728 MB MMC Device 2: N/A Net: No ethernet found. Hit any key to stop autoboot: 0 TINY4412 # TINY4412 # setenv bootargs root=/dev/nfs nfsroot=192.168.31.178:/home/user/tiny4412/FriendlyARM.rootfs ip=192.168.31.199:192.168.31.178:192.168.31.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0 TINY4412 # TINY4412 # saveenv Saving Environment to SMDK bootable device... done nfsroot 语法格式为： &lt;服务器IP地址&gt;:&lt;服务器上的文件目录&gt; ip=&lt;开发板IP地址&gt;:&lt;服务器IP地址&gt;:&lt;网关&gt;:&lt;子网掩码&gt;::eth0:off 3.8 挂载文件系统启动 linux重启开发板，此时应该可以正常启动内核，正常情况下最后一段 log 为： ... ... [ 7.325000] link_reset() speed: 10 duplex: 0 [ 7.335000] IP-Config: Complete: [ 7.335000] device=eth0, addr=192.168.31.199, mask=255.255.255.0, gw=192.168.31.1 [ 7.335000] host=192.168.31.199, domain=, nis-domain=(none) [ 7.335000] bootserver=192.168.31.178, rootserver=192.168.31.178, rootpath= [ 7.335000] hotplug_policy_init: intialised with policy : DVFS_NR_BASED_HOTPLUG [ 7.345000] ALSA device list: [ 7.345000] No soundcards found. [ 7.365000] VFS: Mounted root (nfs filesystem) on device 0:10. [ 7.365000] Freeing init memory: 212K [root@Maziot /]# 但是有的时候会出现问题 情况1：卡死在 No soundcards found 这里，没有成功挂载到 nfs 文件系统 这样情况需要重点检查 nfs 服务这块，nfs 服务配置是否正确，uboot 中 bootargs 是否设置正确 情况2：卡死在 Freeing init memory: 212K 成功 mount 了文件系统，但是没有进入终端 说实话，我也不清除具体的原因，这里我的排查方法是用同学做好的，可以正常启动的文件系统包做交叉实验，找到自己文件系统中哪些文件配置的不对 同学做好的正常的文件系统我也放了一份到 https://github.com/tiny4412/FriendlyARM.source.code.git 仓库中，克隆下来将会得到 rootfs-huangweizhong.tar.gz 文件。先试试这个文件系统能否正常挂载 user@vmware:~/tiny4412$ tar zxvf rootfs-huangweizhong.tar.gz user@vmware:~/tiny4412$ cd rootfs/ user@vmware:~/tiny4412/rootfs$ pwd /home/user/tiny4412/rootfs 设置 uboot 中 bootargs 以及 nfs 共享的目录 setenv bootargs root=/dev/nfs nfsroot=192.168.31.178:/home/user/tiny4412/FriendlyARM.rootfs ip=192.168.31.199:192.168.31.178:192.168.31.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0 确认到可以正常挂载，接下来就是找不同，看看具体是哪个配置的区别导致我自己做的文件系统挂载不上。我在制作本文文件系统中就是遇到情况2的问题，卡死在 Freeing init memory: 212K 位置，最后通过交叉实验，确认到是 fstab 的问题。需要将 fstab 修改为： user@vmware:~/tiny4412/FriendlyARM.rootfs$ cat etc/fstab # # /etc/fstab # # Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos; # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/VolGroup-lv_root / ext4 defaults 1 1 UUID=1d8cfac6-27f4-464f-9296-04d5bad1d7b2 /boot ext4 defaults 1 2 /dev/mapper/VolGroup-lv_home /home ext4 defaults 1 2 /dev/mapper/VolGroup-lv_swap swap swap defaults 0 0 tmpfs /dev/shm tmpfs defaults 0 0 devpts /dev/pts devpts gid=5,mode=620 0 0 sysfs /sys sysfs defaults 0 0 proc /proc proc defaults 0 0 四 产品发布前面提到的在 tiny4412 上搭建 linux 环境基本已经可以运行了，使用的是 SD 启动挂载 nfs 网络文件系统，这样的方式好处是可以很方便的在 ubuntu 和 tiny4412 之前传输文件，但是我们最终的产品是要卖给用户的。我们不能强制用户要求插上启动用的 SD 卡，以及网线挂载网络文件系统。因此，最终，我们要将 uboot、kernel、fs 都要烧写到 EMMC 中，并在 EMMC 引导他们启动。 4.1 将 uboot 和内核从 SD 卡中拷贝到 EMMC 中注意：SD 中有第 0 块不可用，EMMC 第 0 块是可用的，因此从 SD 到 EMMC 中烧的任何代码都需要减去 1SD 卡是从第一个块开始的， EMMC 是从第0个块开始的]]></content>
      <categories>
        <category>Tiny4412</category>
      </categories>
      <tags>
        <tag>FrindlyARM</tag>
        <tag>tiny4412</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 块设备驱动程序]]></title>
    <url>%2F2018%2F08%2F05%2Fmini2440-block-device-driver%2F</url>
    <content type="text"><![CDATA[一 块设备程序的引入1.1 字符设备程序总结不妨先总结下字符设备驱动程序，内核引入字符设备来操作硬件设备，大致的框架如下： app: open read write -------------------- drv: open read write -------------------- hardware 应用程序通过 c 库提供的系统调用接口调用 open、read、write 等，将会直接的调用的驱动的 open、read、write 函数。在驱动中的 open、read、write 将会操作实际的硬件设备。 那驱动中的 open、read、write 函数和系统调用提供的 open、read、write 函数怎么对应起来呢？ 申请主设备号 实现 open、read、write 函数 将实现的 open、read、write 函数绑定到 fops 结构中 注册字符设备，将主设备号和 fops 绑定起来，并告诉内核 因此，APP 在 open 对应设备的时候，就可以通过主设备号找到该设备，接着找到对应的 fops 结构，调用驱动中对应的接口函数。 1.2 按键字符设备驱动总结按键驱动的实现方式多种多样，以一个简单的场景最为例子：在一个屋子里，有一个小孩在睡觉，他的妈妈在外面干活，现在妈妈要知道孩子什么时候醒来，妈妈需要怎么做？ 查询方式每隔两分钟，进屋里看一次，看看孩子醒了没。 休眠唤醒妈妈进屋，发现孩子没醒，也在旁边睡下，等孩子醒了，会叫醒她。 Poll机制休眠唤醒存在一个问题，倘若孩子生病了，一睡不醒，那孩子就不会唤醒妈妈，妈妈也将会一直睡眠。为了规避这种情况，加一个30分钟响一次的闹钟，除了孩子醒了主动唤醒妈妈的手段外，妈妈每隔30分钟也会被闹钟唤醒一次。 异步通知妈妈不需要关注小孩醒了没，小孩醒了会自己起来，出屋子去找妈妈。 输入子系统上述驱动都有一个缺点，上述方式写的代码都只有自己团队成员知道怎么用，并不通用。使用内核提供的统一的子系统实现，可以提高代码的通用性。输入子系统仅仅是针对按键驱动，如果是其他设备可能是使用其他内核子系统封装。如 lcd 使用 Frame Buffer。 1.2 块设备驱动程序]]></content>
      <tags>
        <tag>mini2440</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 如何添加 u-boot 命令]]></title>
    <url>%2F2018%2F07%2F20%2Fmini2440-add-u-boot-cmd%2F</url>
    <content type="text"><![CDATA[看书总是介绍说，使用 U_BOOT_CMD 宏可以定义一个命令，但是并没有仔细研究过，这里在卫东山老师的 u-boot-1.1.6 源码基础上简单分析下。搜索下，看看这个宏是什么东西： user@vmware:~/mini2440/u-boot-1.1.6$ grep -rsn &quot; U_BOOT_CMD&quot; ./ ./common/command.c:329:/* This do not ust the U_BOOT_CMD macro as ? can&apos;t be used in symbol names */ ./include/command.h:97:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ ./include/command.h:102:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ ./doc/README.commands:5:Then using the U_BOOT_CMD() macro to fill in a cmd_tbl_t struct. 好家伙，居然有文档，那看看 ./doc/README.commands 文档怎么说：文档很简洁，原文如下： Commands are added to U-Boot by creating a new command structure.This is done by first including command.h Then using the U_BOOT_CMD() macro to fill in a cmd_tbl_t struct. U_BOOT_CMD(name,maxargs,repeatable,command,”usage”,”help”) name: is the name of the commad. THIS IS NOT a string.maxargs: the maximumn numbers of arguments this function takescommand: Function pointer (cmd)(struct cmd_tbl_s , int, int, char *[]);usage: Short description. This is a stringhelp: long description. This is a string Behinde the scene ** The structure created is named with a special prefix (__u_bootcmd)and placed by the linker in a special section. This makes it possible for the final link to extract all commandscompiled into any object code and construct a static array so thecommand can be found in an array starting at __u_boot_cmd_start. If a new board is defined do not forget to define the command sectionby writing in u-boot.lds ($(TOPDIR)/board/boardname/u-boot.lds) these3 lines: u_boot_cmd_start = .;.u_boot_cmd : { *(.u_boot_cmd) } u_boot_cmd_end = .; 简单翻译下： 添加一个命令本质其实就是添加一个命令的结构体第一件要做的事情就是包含 command.h 头文件然后使用 U_BOOT_CMD 宏来填充 cmd_tbl_t 命令结构体，U_BOOT_CMD 宏的原型如下： U_BOOT_CMD(name,maxargs,repeatable,command,”usage”,”help”)name: 命令的名称，注意，不是字符串，不要用双引号maxargs: 这个函数的参数的最大数量command: 回调函数的函数指针 (cmd)(struct cmd_tbl_s , int, int, char *[]);usage: 简述该命令的用法 字符串help: 详细描述改名的用法 字符串 使用该宏所创建的结构都使用同一个前缀命名，该前缀为 (u_bootcmd)。并且，这些结构由链接器放置在一个特殊的区域。这使得最后这些结构被静态的连接成为了一个数组，通过 u_boot_cmd_start 可以访问的到。 u_boot_cmd_start = .;.u_boot_cmd : { *(.u_boot_cmd) } u_boot_cmd_end = .; 将 U_BOOT_CMD 展开看看： user@vmware:~/mini2440/u-boot-1.1.6$ grep -rsn &quot; U_BOOT_CMD&quot; ./ ./common/command.c:329:/* This do not ust the U_BOOT_CMD macro as ? can&apos;t be used in symbol names */ ./include/command.h:97:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ ./include/command.h:102:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ ./doc/README.commands:5:Then using the U_BOOT_CMD() macro to fill in a cmd_tbl_t struct. 看看这两行中是如何定义的： ./include/command.h:97:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ ./include/command.h:102:#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ 打开 command.h 文件看看： 93 #define Struct_Section __attribute__ ((unused,section (&quot;.u_boot_cmd&quot;))) 94 95 #ifdef CFG_LONGHELP 96 97 #define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ 98 cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep, cmd, usage, help} 99 100 #else /* no long help info */ 101 102 #define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \ 103 cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep, cmd, usage} 104 105 #endif /* CFG_LONGHELP */ 两个宏的作用是一致的，只是一个用详细的 help 说明，一个省略了而已。另外，看 93 行，可以发现，Struct_Section 也是一个宏，用于指定链接的存放的位置。随便找一个命令代入，将宏展开后看看，不妨就以经常使用的 printenv 代入看看吧 user@vmware:~/mini2440/u-boot-1.1.6$ grep -rsn &quot;printenv,&quot; ./ ./common/cmd_nvedit.c:580: printenv, CFG_MAXARGS, 1, do_printenv, ./doc/README.cmi:71:* U-Boot commands: go, loads, loadb, all memory features, printenv, 打开 cmd_nvedit.c 文件看看： 579 U_BOOT_CMD( 580 printenv, CFG_MAXARGS, 1, do_printenv, 581 &quot;printenv- print environment variables\n&quot;, 582 &quot;\n - print values of all environment variables\n&quot; 583 &quot;printenv name ...\n&quot; 584 &quot; - print value of environment variable &apos;name&apos;\n&quot; 585 ); 将 U_BOOT_CMD 和 Struct_Section 展开后看看： cmd_tbl_t __u_boot_cmd_printenv __attribute__ ((unused,section (&quot;.u_boot_cmd&quot;))) = { printenv, 16, 1, do_printenv, &quot;printenv- print environment variables\n&quot;, &quot;printenv name ...\n - print value of environment variable &apos;name&apos;\n&quot; } 这里就是定义了一个 cmd_tbl_t 的结构体对象，并将它们存到了 .u_boot_cmd 段中。注释和文档已经说的很清楚了，cmd_tbl_t 不多扯了，这里还是贴出来吧： typedef struct cmd_tbl_s cmd_tbl_t; struct cmd_tbl_s { char *name; /* Command Name */ int maxargs; /* maximum number of arguments */ int repeatable; /* autorepeat allowed? */ /* Implementation function */ int (*cmd)(struct cmd_tbl_s *, int, int, char *[]); char *usage; /* Usage message (short) */ #ifdef CFG_LONGHELP char *help; /* Help message (long) */ #endif #ifdef CONFIG_AUTO_COMPLETE /* do auto completion on the arguments */ int (*complete)(int argc, char *argv[], char last_char, int maxv, char *cmdv[]); #endif }; 上面是添加命令的方式，那么命令添加到 u_boot_cmd 后，谁会去访问？谁来用？文档中说链接脚本中有这样的描述，我们当然相信，不过最好是自己确认下： __u_boot_cmd_start = .; .u_boot_cmd : { *(.u_boot_cmd) } __u_boot_cmd_end = .; 去 100ask 的板级信息下确认下： user@vmware:~/mini2440/u-boot-1.1.6$ cd board/100ask24x0/ user@vmware:~/mini2440/u-boot-1.1.6/board/100ask24x0$ grep -rsn &quot;__u_boot_cmd_start&quot; ./ ./u-boot.lds:50: __u_boot_cmd_start = .; 49 . = .; 50 __u_boot_cmd_start = .; 51 .u_boot_cmd : { *(.u_boot_cmd) } 52 __u_boot_cmd_end = .; 没错，确实是这样的，看看在哪里用？ user@vmware:~/mini2440/u-boot-1.1.6/board/100ask24x0$ cd ../../ user@vmware:~/mini2440/u-boot-1.1.6$ grep -rsn &quot;&amp;__u_boot_cmd_start&quot; ./ ./lib_mips/board.c:320: for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { ./common/command.c:246: &amp;__u_boot_cmd_start; /* pointer arith! */ ./common/command.c:251: cmdtp = &amp;__u_boot_cmd_start; ./common/command.c:349: cmd_tbl_t *cmdtp_temp = &amp;__u_boot_cmd_start; /*Init value */ ./common/command.c:360: for (cmdtp = &amp;__u_boot_cmd_start; ./common/command.c:435: for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { ./common/command.c:468: for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { ./lib_m68k/board.c:444: for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { ./lib_ppc/board.c:633: for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { 搜索 __u_boot_cmd_start 关键字，结果太多了，都是链接脚本的搜索结果，因此这里加了个 &amp; 搜索 &amp;__u_boot_cmd_start，或者在 source insight 下搜索 ---- __u_boot_cmd_start Matches (7 in 2 files) ---- do_help in command.c (common) : &amp;__u_boot_cmd_start; /* pointer arith! */ do_help in command.c (common) : cmdtp = &amp;__u_boot_cmd_start; find_cmd in command.c (common) : cmd_tbl_t *cmdtp_temp = &amp;__u_boot_cmd_start; /*Init value */ find_cmd in command.c (common) : for (cmdtp = &amp;__u_boot_cmd_start; complete_cmdv in command.c (common) : for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { complete_cmdv in command.c (common) : for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { command.h (include) line 57 : extern cmd_tbl_t __u_boot_cmd_start; 不难看到有多个地方会遍历 .u_boot_cmd 段中的 cmd_tbl_t 对象，拿出来 cmd_tbl_t 对象出来搞事情。猜想：u-boot 命令模式下，等待用户输入命令后，会去遍历 __u_boot_cmd_start 的表格，找到用于输入的对应命令，并执行其中的 cmd 回调函数。验证猜想：从启动流程这块接着分析： main_loop run_command /* Look up command in command table */ find_cmd /* OK - call function to do the command */ cmdtp-&gt;cmd 没错，就是在 find_cmd 函数中去遍历所有的命令，找到当前要执行的命令，具体实现如下： cmd_tbl_t *find_cmd (const char *cmd) { cmd_tbl_t *cmdtp; cmd_tbl_t *cmdtp_temp = &amp;__u_boot_cmd_start; /*Init value */ const char *p; int len; int n_found = 0; /* * Some commands allow length modifiers (like &quot;cp.b&quot;); * compare command name only until first dot. */ len = ((p = strchr(cmd, &apos;.&apos;)) == NULL) ? strlen (cmd) : (p - cmd); for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) { if (strncmp (cmd, cmdtp-&gt;name, len) == 0) { if (len == strlen (cmdtp-&gt;name)) return cmdtp; /* full match */ cmdtp_temp = cmdtp; /* abbreviated command ? */ n_found++; } } if (n_found == 1) { /* exactly one match */ return cmdtp_temp; // 找到了就返回命令的 cmd_tbl_t 对象 } return NULL; /* not found or ambiguous command */ } u-boot 启动后最后会运行到 mian_loop 中，main_loop 会去判断 bootm 和 bootargs 有没有，有的话，就自动启动，没有的话，就进入 u-boot 命令行，等到用户输入命令。但是不管是自动启动，还是等待用户输入命令，最后的结果都是调用 run_command 执行 u-boot 命令，最后都会通过 find_cmd 得到命令对应的 cmd_tbl_t 结构对象，运行命令对应的 cmd 回调函数。]]></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>mini2440</tag>
        <tag>u-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Essays] 日本70岁退休]]></title>
    <url>%2F2018%2F07%2F13%2Fessays-retire-at-70%2F</url>
    <content type="text"><![CDATA[原文链接: http://www.ruanyifeng.com/blog/2018/03/retire-at-70.html 原标题: 日本70岁退休谈起 作者：阮一峰 1、 2018年初，日本政府修改法律，推迟公务员的退休年龄。 现在，日本的公务员是60岁～63岁退休。新法律生效后，退休年龄立刻推迟到65岁，然后逐步推迟到70岁。 更厉害的是，日本政府同时宣布，养老金制度也要改革。现在是65岁领取养老金，将来只有到了70岁才能领。 如果我是一个刚刚毕业的日本大学生，听到这种消息，恐怕腿都要软了。日本那种毕恭毕敬、论资排辈的社会里面，上班简直像受罪一样。你必须每天小心翼翼地勤勉工作，日复一日地加班，所有前辈都下班了，你才能下班。这种生活要一直过到七十岁，怎不令人害怕？ 等到你走也走不动了，吃也吃不下了，才能领养老金，那么养老金又有多大意义呢，能够保障什么质量的生活呢？毕竟七十岁以前，都要靠自己啊。 2、 日本政府推迟退休，实在是迫不得已，因为日本的人口老龄化太严重了。 日本是全世界人均寿命最高的国家之一，男81.7岁，女88.5岁。同时，日本也是全世界出生率最低的国家之一。 结果就是人口不断萎缩，国民的平均年龄越来越大。2015年，日本人的平均年龄已经到了46.5岁，是全世界平均年龄最大的国家，而且这个数字以后还会变大。据估计，四十年后，日本人口会减少三分之一。 日本对输入外国劳动力和外国移民控制极严，导致劳动力越来越少。日本政府发现，一方面，交税的人口不断减少；另一方面，领取养老金的人口不断增多，而且领的时间越来越长。于是别无选择，只能让老年人多上几年班，晚几年领养老金。 3、 几乎所有发达国家都存在同样的问题：养老金存在缺口，无法满足越来越多的老年人口。日本只是问题最严重而已。 有些地区还不那么发达，也出现养老金问题，比如台湾地区。台湾的生育率也是世界最低之一，养老金早就不够用了，破产在即，不得不立刻改革，减少养老金发放规模，每个人的缴款增加，但是未来领取的金额却要减少。台湾年轻人的薪水并不高，台北房价却直逼香港东京，现在养老金又要减少，年轻人的郁闷和绝望可想而知。一个台湾网友给出了三条对策。 上策：要求改变制度设计，每一代人自己养自己，让有钱的老人补贴没钱的老人，不要拿下一代的钱发给上一代人。中策：移民，彻底脱离这个制度。自己出不去，也要让下一代出去。下策：如果走不了，就不要生育，并且拼命地挣钱和存钱。同时，支持安乐死合法化，因为未来很可能，你的钱都用光了，人却还没死。 4、 请设想这样一种情景。未来很可能过了65岁，你的头发白了、眼睛花了、牙齿松了，还不得不朝九晚五地上班，为别人打工。 就算你能健康活过七十岁领到养老金，那些钱也很可能由于通货膨胀，以及僧多粥少，而变得非常微薄。 这种前景只要想一想，就会觉得不寒而栗。大多数人之所以工作，不是因为热爱工作，而是因为这样可以挣到钱，可以有保障，得到安稳的退休生活。但是这一切看上去很难实现了，如今你必须忍受着疲惫，工作更多年，到头来发现，你的养老并没有保障。 难怪日本和台湾的很多年轻人，看不到前景，对未来不抱希望。日本和台湾都有很高的自杀率，我想这绝不是偶然的。 5、 作为个人，要摆脱这种老无所依的命运，马上能想到的解决办法就是要多多挣钱。你不得不拼命工作，挣更多的钱。但是，这条路上已经挤满了人，很可能你为雇主投入了100%的心力，年复一年，到老还是在为生存挣扎。另一方面，很多人上班其实并不开心，想想看，如果要一直苦闷地熬到60多岁，人生一定没有什么幸福感。 我有时会有另外一种想法：反正已经是这种处境了，为什么不索性换一种活法呢？如果不喜欢这个工作，你是否还要继续下去，熬到退休拿养老金？如果养老金是苦苦支撑到七十岁才能拿到，那能不能就当它不存在，趁早去干一些自己想干的事情？至少也要找一些自己喜欢、做起来开心的工作吧。 甚至可不可以再进一步，与其等待别人决定，你应该在什么时候退休。我也可以做一回命运的主人，哪天觉得没意思了，拍拍衣服说，从现在开始我退休了，过另外一种生活。以前还有养老金可以期待，现在这种期待即使存在，也肯定小多了。 提前退休并不意味着，从此你什么也不干了，而是让你有机会，转身尝试另一种生活，在一个自己有热情的领域创造出更大的价值。一旦你体验过，按照自己的想法生活，自由安排时间，你就完全回不去了，再也无法忍受那种大公司小隔间的呆板压抑的生活了。 6、 你可能会说，我的这种想法是水中月，镜中花，一厢情愿而已。没工作了就没钱，没钱怎么活？确实，提前退休就没收入了，但这注定我一定要为别人打工到退休吗？ 事实上，美国早有人研究过这个问题：一个普通的工薪族，怎么样才能在40岁退休？结论居然是，只要你不是那么穷，有一定的积蓄，普通人也可以40岁退休。 这里有一个计算公式，如果你的所有钱都投资在证券上面，只要你一年的支出小于投资组合原始金额的4%，那么你就可以退休了。这被称为”百分之四”规则（Four Percent Rule）。 它的依据是1926年至1976年的美国证券投资回报率，有人发现即使这段时间熊市居多，如果你每年取出原始投资金额的4%，一直要到33年以后才会把钱取光。要是碰到大牛市，就可以撑更久。 如果这条规则正确，那么可以推算，如果你每年的总支出为4万人民币，而你现在的证券投资有100万，那么你就可以退休了。如果每年支出40万，那么证券投资需要1000万。这些钱能够支撑30多年，中国人的平均寿命现在也就是70多岁。事实上，有一项研究专门验证这项规则，结果发现它（在美国）成立的概率是94%。 7、 当然，我不是说，你真的用这个规则，来安排自己的退休规划。尽管随着年龄变老，人的支出一般会越来越少，但是万一有突发事件（比如生了大病），恐怕马上就会耗尽存款。（不过，即使你没有退休，突发事件也有可能耗尽你的存款，你的生活保障并不会因为有没有正在上班，而有实质的不同。） 我举这条规则的用意是，我想用它证明，只要管控好支出，提前退休在财务上是完全可行的。如果你很早就开始提前规划，可能性就会大大增加，如果你对自己的消费有严格的纪律，就完全有可能做到。 普通人的生存正在变得越来越难，养老金和退休这样的字眼，正在离你越来越远，全世界皆是如此。你必须为自己早做打算，而在我看来，如果规划得当，你的人生至少可以不是那么悲惨，要熬到七十岁油干灯尽才能退休。]]></content>
      <categories>
        <category>Essays</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[CAR] 学习总结(三) 字符设备驱动框架]]></title>
    <url>%2F2018%2F07%2F10%2Fcar-char-driver-frame%2F</url>
    <content type="text"><![CDATA[开发环境搭建好了，现在开始做任务吧。 任务要求 编写一个基本字符设备，验证字符设备常用接口：open/close/read/write/ioctl 任务实现驱动模块：first_drv.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt; /* copy_to_user ... */#include &lt;linux/ioctl.h&gt;/* simple log */#define log(fmt, arg...)\ printk(KERN_INFO "[Paul][%s][%d] "fmt"\n", __func__, __LINE__, ##arg);#define FIRST_IOC_MAGIC 'F'#define FIRST_ONLY_EXECUTE _IO(FIRST_IOC_MAGIC, 0)#define FIRST_ONLY_WRITE _IOW(FIRST_IOC_MAGIC, 1, int)#define FIRST_ONLY_READ _IOR(FIRST_IOC_MAGIC, 2, int)#define FIRST_RW _IOWR(FIRST_IOC_MAGIC, 3, int)#define FIRST_IOCTL_MAXNR 3int first_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; if (_IOC_TYPE(cmd) != FIRST_IOC_MAGIC) &#123; log("error1"); return -ENOTTY; &#125; if (_IOC_NR(cmd) &gt; FIRST_IOCTL_MAXNR) &#123; log("error2"); return -ENOTTY; &#125; switch(cmd) &#123; case FIRST_ONLY_EXECUTE: log("FIRST_ONLY_EXECUTE"); break; case FIRST_ONLY_WRITE: log("FIRST_ONLY_WRITE"); break; case FIRST_ONLY_READ: log("FIRST_ONLY_READ"); break; case FIRST_RW: log("FIRST_RW"); break; default: log("default"); &#125;&#125;static int first_open(struct inode *my_indoe, struct file *my_file)&#123; log("standard open ok"); return 0;&#125;static int first_release(struct inode *my_indoe, struct file *my_file)&#123; log("standard release ok"); return 0;&#125;static ssize_t first_read(struct file *my_file, char __user *buff, size_t cnt, loff_t *loff)&#123; int tmp = 128; copy_to_user(buff, &amp;tmp, 4); log("standard read ok"); return 0;&#125;static ssize_t first_write(struct file *my_file, const char __user *buff, size_t cnt, loff_t *loff)&#123; int tmp = 0; copy_from_user(&amp;tmp, buff, 4); log("tmp = %d", tmp); log("standard write ok"); return 0;&#125;static struct file_operations first_fops =&#123; .open = first_open, .release = first_release, .read = first_read, .write = first_write, .unlocked_ioctl = first_ioctl,&#125;;static int first_major;static int first_minor;static dev_t first_devno;struct cdev * standard_device;static struct class * first_class;static int __init mod_init(void)&#123; int ret; ret = alloc_chrdev_region(&amp;first_devno, first_minor, 1, "standard_device"); first_major = MAJOR(first_devno); if (ret &lt; 0) &#123; log("cannot get first_major %d", first_major); return -1; &#125; standard_device = cdev_alloc(); if (standard_device != NULL) &#123; cdev_init(standard_device, &amp;first_fops); standard_device-&gt;owner = THIS_MODULE; if (cdev_add(standard_device, first_devno, 1) != 0) &#123; log("add cdev error!"); goto error; &#125; &#125; else &#123; log("cdev_alloc error!"); return -1; &#125; first_class = class_create(THIS_MODULE, "first_class"); if (IS_ERR(first_class)) &#123; log("create class error"); return -1; &#125; device_create(first_class, NULL, first_devno, NULL, "standard_device"); log("mod_init ok"); return 0;error: unregister_chrdev_region(first_devno, 1); return ret;&#125;static void __exit mod_exit(void)&#123; cdev_del(standard_device); unregister_chrdev_region(first_devno, 1); device_destroy(first_class, first_devno); class_destroy(first_class); log("mod_exit ok");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 模块对应 Makefile： 12345678910obj-m += first_drv.oKERNEL = /home/baohua/develop/linuxall: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -C $(KERNEL) M=`pwd` modules @echo &quot;&gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt;&quot;clean: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -C $(KERNEL) M=`pwd` modules clean @echo &quot;&gt;&gt;&gt;&gt;&gt;&gt; make clean successful &lt;&lt;&lt;&lt;&lt;&lt;&quot; 测试程序：first_app.c 12345678910111213141516171819202122232425262728int main(int argc, char**argv)&#123; int fd; printf(&quot;[app] O_RDWR = %d\n&quot;, O_RDWR); fd = open(&quot;/dev/standard_device&quot;, O_RDWR); if(fd &lt; 0) &#123; printf(&quot;[app] driver open fail\n&quot;); return -1; &#125; int write_buf = 100; write(fd, &amp;write_buf, 4); int read_buf = 0; read(fd, &amp;read_buf, 4); ioctl(fd, FIRST_ONLY_EXECUTE); ioctl(fd, FIRST_ONLY_WRITE, 100); ioctl(fd, FIRST_ONLY_READ, 100); ioctl(fd, FIRST_RW, 100); close(fd); printf(&quot;[app] read_buf = %d\n&quot;, read_buf); return 0;&#125; 任务验证编译模块和测试程序并拷贝到开发板上： 123456789101112# 编译模块baohua@baohua-VirtualBox:~/develop/wangbing/01.char$ make# 编译测试程序baohua@baohua-VirtualBox:~/develop/wangbing/01.char$ arm-linux-gnueabi-gcc first_app.c -o app# 挂载开发板根目录baohua@baohua-VirtualBox:~/develop/wangbing//01.char$ sudo mount -o loop,offset=1048576 /home/baohua/develop/linux/extra/vexpress.img /home/baohua/develop/linux/extra/img# 拷贝到开发板上baohua@baohua-VirtualBox:~/develop/wangbing/01.char$ sudo cp first_drv.ko /home/baohua/develop/linux/extra/img/ -abaohua@baohua-VirtualBox:~/develop/wangbing/01.char$ sudo cp app /home/baohua/develop/linux/extra/img/ -a 开发板执行效果图：]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>train</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CAR] 学习总结(二) 搭建环境]]></title>
    <url>%2F2018%2F07%2F09%2Fcar-build-devlop-env%2F</url>
    <content type="text"><![CDATA[实践环境要求实践环境基本需要有： 一台 ubuntu 主机：用于编译驱动和测试程序 一块开发板：用于验证驱动和测试程序 其他小东西：下载器，usb线，串口线等 虚拟实践环境ubuntu 主机的问题很好处理，使用 vmware 创建一个虚拟机，并安装一个 ubuntu 系统即可。开发板的话就比较麻烦了，这里本系列实践记录欲使用“宋宝华”老师《Linux设备驱动开发详解：基于最新的Linux 4.0内核》书中的 QEMU 实验平台验证，不能保证一定 ok，目前正在尝试中。先尝试下，如果可以的实现的就基于 VMware(或 Virtual Box) + Qemu 做实践，不行的话，只能拿出我的 mini2440 开发板搞事情了或者搞一套公司的硬件验证了，顺便熟悉项目的编译，烧写，启动，或许操作会麻烦点，但是可以提前熟悉项目还是很不错的。 总结下就是，用 vmware 虚拟一台 ubuntu 主机，用 qemu 虚拟一台 develop board。 QEMU 介绍介绍 QEMU 的相关博客： https://www.cnblogs.com/bakari/p/7858029.htmlhttps://blog.csdn.net/zhaihaifei/article/details/51028823https://www.ibm.com/developerworks/cn/linux/l-qemu/ 尝试搭建环境第一步：下载书籍对应的光盘资料下载《Linux设备驱动开发详解：基于最新的Linux 4.0内核》配套的光盘，光盘中有宋宝华老师已经搭建好的ubuntu虚拟机和qemu cortex-A9 开发板。光盘资料在百度云可以下载，老的百度云链接已经失效了，需要关注宋宝华老师的微信公众号：”Linux阅码场”，在公众号中可以获取最新的光盘下载地址。获取书籍配套光盘百度云链接的步骤：关注 “Linux阅码场” 公众号 -&gt; 书和课程 -&gt; 书籍FAQ -&gt; 配套光盘下载地址。 第二步：使用 VMware(或Virtual Box)安装ubuntu参考光盘中的《Linux虚拟机安装手册.docx》文档，安装光盘中提供的虚拟机，此虚拟机中已经配置好了开发环境，当然包括 QEMU 了。先尝试使用 VMware 14 安装虚拟机，安装后 ubuntu 开机会 panic，进不了系统。因此重新使用光盘中提供的 Virtual Box 成功安装。至于 VMware 7.0 没有尝试，谁有兴趣可以试试，并帮忙补全下。 安装好 ubuntu 后，虚拟机账户密码都是 baohua，账户：baohua，密码：baohua。为了在 Virtual Box 和 windows 之间方便拷贝，需要设置共享粘贴板：设备 -&gt; 共享粘贴板 -&gt; 双向。 第三步：编译、烧写、运行书籍配套内核接下来就是看看内核怎么编译，如何烧写到 QEMU 中，以及如何启动 QEMU 开发板。 源码在哪？源码在 /home/baohua/develop/linux 位置，编译脚本宝华已经做好了，build.sh 脚本位于源码根目录。尝试着编译了下，没问题，可以编译过： 12345678910111213141516171819202122baohua@baohua-VirtualBox:~/develop/linux$ ./build.sh CHK include/config/kernel.release CHK include/generated/uapi/linux/version.h CHK include/generated/utsrelease.hmake[1]: `include/generated/mach-types.h&apos; is up to date. CALL scripts/checksyscalls.sh CHK include/generated/compile.h CHK kernel/config_data.h Kernel: arch/arm/boot/Image is ready Kernel: arch/arm/boot/zImage is ready CHK include/config/kernel.release CHK include/generated/uapi/linux/version.h CHK include/generated/utsrelease.hmake[1]: `include/generated/mach-types.h&apos; is up to date. CALL scripts/checksyscalls.sh Building modules, stage 2. MODPOST 5 modules CHK include/config/kernel.release CHK include/generated/uapi/linux/version.h CHK include/generated/utsrelease.hmake[1]: `include/generated/mach-types.h&apos; is up to date. CALL scripts/checksyscalls.sh 简单看一下编译脚本 build.sh 12345678910export ARCH=armexport EXTRADIR=$&#123;PWD&#125;/extraexport CROSS_COMPILE=arm-linux-gnueabi-#make LDDD3_vexpress_defconfigmake zImage -j8make modules -j8make dtbscp arch/arm/boot/zImage extra/cp arch/arm/boot/dts/*ca9.dtb extra/cp .config extra/ 可以看到最后将编译得到的 zImage 和 dtb 文件都拷贝到了源码根目录下的 extra/ 目录中，配合《Linux设备驱动开发详解》中介绍，extra 是一张虚拟的 SD 卡，作为 QEMU 板子的文件系统存放介质，因此这里的拷贝动作其实就是下载的动作。编译和烧写的动作，build.sh 已经做好了，剩下要做的就是要知道，如何编写自己的内核模块，以及修改设备树，最后又该如何 insmod 到 QEMU 上。先启动下 QEMU 版子看看： 123456789baohua@baohua-VirtualBox:~$ cd develop/linux/extra/baohua@baohua-VirtualBox:~/develop/linux/extra$ lsimg run-nolcd.sh u-boot.bin vexpress.img zImagerun-lcd.sh u-boot u-boot.sh vexpress-v2p-ca9.dtbbaohua@baohua-VirtualBox:~/develop/linux/extra$ ./run-lcd.sh WARNING: Image format was not specified for 'vexpress.img' and probing guessed raw. Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted. Specify the 'raw' format explicitly to remove the restrictions.audio: Could not init `oss' audio driver 运行 run-lcd.sh 脚本后，将自动调起 QEMU，成功运行。 编写内核驱动模块和测试程序试着编写一个最简单的内核模块 module.c，通过动态加载的方式加载到内核： 12345678910111213141516171819#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#define log(fmt, arg...) printk(KERN_INFO "[Paul][%s][%d] "fmt"\n", __func__, __LINE__, ##arg);static int __init mod_init(void)&#123; log("mod_init ok"); return 0;&#125;static void __exit mod_exit(void)&#123; log("mod_exit ok");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 接下来编写对应的 Makefile： 1234567891011obj-m += module.oKERNEL = /home/baohua/develop/linuxall: make -C $(KERNEL) M=`pwd` modules @echo &quot;&gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt;&quot;clean: make -C $(KERNEL) M=`pwd` modules clean @echo &quot;&gt;&gt;&gt;&gt;&gt;&gt; make clean successful &lt;&lt;&lt;&lt;&lt;&lt;&quot; 这两个文件都放在 /home/baohua/develop/wangbing 目录下，可是编译一下，居然报错，很是尴尬，看看宝华提供的编译模块的脚本 module.sh 是怎么编译模块的： 12345baohua@baohua-VirtualBox:~/develop/wangbing$ cat ../linux/module.sh make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modulessudo mount -o loop,offset=$((2048*512)) extra/vexpress.img extra/imgsudo make ARCH=arm modules_install INSTALL_MOD_PATH=extra/imgsudo umount extra/img 将 arch 和 cross_complie 加上试试，修改后的 Makefile 如下： 1234567891011obj-m += module.oKERNEL = /home/baohua/develop/linuxall: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -C $(KERNEL) M=`pwd` modules @echo &quot;&gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt;&quot;clean: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -C $(KERNEL) M=`pwd` modules clean @echo &quot;&gt;&gt;&gt;&gt;&gt;&gt; make clean successful &lt;&lt;&lt;&lt;&lt;&lt;&quot; 加上后果然成功编译出 module.ko 模块，再看看怎么拷贝到开发板上，同样参考宝华提供的 module.sh 脚本。同时看到配套书籍上有这么一句话： extra 目录下的 vexpress.img 是一张虚拟 SD 卡，将作为根文件系统的存放介质。它能以 loop 的形式被挂载，如执行: sudo mount -o loop,offset=1048576 $(KERNEL)/extra/vexpress.img $(KERNEL)/extra/img 就可以将 vexpress.img 挂载到 $(KERNEL)/extra/img 位置。 因此，尝试一下，这么干： 12baohua@baohua-VirtualBox:~/develop/wangbing$ sudo mount -o loop,offset=1048576 /home/baohua/develop/linux/extra/vexpress.img /home/baohua/develop/linux/extra/imgbaohua@baohua-VirtualBox:~/develop/wangbing$ sudo cp module.ko /home/baohua/develop/linux/extra/img/ 看了一眼 QEMU，不行呀，没有 module.ko 文件。重启一下试试，重启之后果然有了(如果没有就再重启一下，我猜是文件同步需要一点时间)。 模块已经拷贝到了 Qemu 上，并成功装载。至此，我们已经搭建好了基于 Virtual Box 和 QEMU 的开发环境。 备注鼠标点进 QEMU 虚拟的开发板终端后，鼠标将被屏蔽，此时，切回到 ubuntu 其他窗口，鼠标依然是隐藏的状态，并不会主动显示出来，需要使用 Ctrl + Alt + G 组合键，释放鼠标光标。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>train</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CAR] 入职学习任务]]></title>
    <url>%2F2018%2F07%2F09%2Fcar-learning-tasks%2F</url>
    <content type="text"><![CDATA[一 前言6月15号，刚刚办完离职手续，16号就举家搬迁，从上海搬到杭州，18号端午节都没有好好过，忙着整理新家，19号就开始上班了，好在新公司给了两个月的适应期，在这期间，仅仅布置学习任务，还是很人性化的。 前期驱动侧学习任务如下： 编写一个基本字符设备，验证字符设备常用接口：open/close/read/write/ioctl 在上述字符设备中添加内存申请释放功能，并将内存与文件系统中的某个文件对应，文件（内存）大小为4MB。 通过read/write接口实现对内存区域的读写操作，编写用户态的测试程序。 通过proc接口实现对内存区域的读写操作。 在用户态使用多线程对驱动申请的内存进行并发访问（写操作），在驱动中采用合适的互斥机制，避免多线程写数据错乱。 在驱动中添加阻塞读操作，当写进程向设备写入数据后，读进程才可以读取数据，否则读进程阻塞。 在驱动中添加poll机制，支持用户态读操作轮询，当写进程向设备写入数据后，读进程select成功，可以读取数据。 需要编写驱动和测试程序，并进行总结。 二 搭建开发环境这里我使用的是 mini2440 开发板来完成上述任务的，搭建 mini2440 开发环境请参考： 搭建韦东山二期驱动视频学习环境。 也可以使用 QEMU 虚拟一台开发板搭建验证环境，搭建 QEMU 虚拟开发板的话，推荐使用宋宝华老师做好的虚拟机，此虚拟机创建好了 vexpress cortex-a9 双核开发板，安装好就可以直接用了。搭建宋 vespress 开发环境请参考： 搭建 Vexpress Cortex-A9 虚拟开发板环境。 三 任务实现前言中提到的任务目前全部都已经实现，源码开源在 GitHub，仓库路径为 https://github.com/mini2440/hikvision.training。 每个任务的说明，请查看仓库 readme 文档。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>train</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] nfs 无响应问题解决]]></title>
    <url>%2F2018%2F07%2F08%2Fmini2440-nfs-not-responding%2F</url>
    <content type="text"><![CDATA[操作环境win7 电脑上装有 vmware 虚拟机，虚拟机中运行 ubuntu 16.04LTS 系统，ubuntu 启动 nfs 服务供开发板挂载网络文件系统，以便和 ubuntu 进行文件传输。开发板使用的是 mini2440 开发板，刷的是韦东山老师的 u-boot-1.1.6 + linux-2.6.22.6 系统。网卡驱动用的是韦东山老师光盘中提供的适用于 mini2440 的网卡驱动。 遇到问题由于搬家，重新买了个小米路由器，使用 mini2440 挂载虚拟机启动的 nfs 网络文件系统出现问题。问题现象是：可以成功挂载，但是拷贝文件的时候会出错，操作过程如下： 先设置下设置开发板 ip 地址 ifconfig eth0 192.168.31.100 ping 一下服务器，能 ping 通，说明局域网配置没有问题 # ping 192.168.31.66 PING 192.168.31.66 (192.168.31.66): 56 data bytes 64 bytes from 192.168.31.66: seq=0 ttl=64 time=0.963 ms 64 bytes from 192.168.31.66: seq=1 ttl=64 time=0.707 ms 挂载 nfs 文件系统试试，能成功挂载 # mount -t nfs 192.168.31.66:/home/user/board /mnt -o nolock # ls -l /mnt/ -rwxrwxr-x 1 1000 1000 5543 Jul 1 2018 app -rw-rw-r-- 1 1000 1000 53809 Jul 1 2018 early_module.ko 尝试拷贝文件，小文件可以正常拷贝，但是稍微大一点的文件就不行，报错如下： # cp /mnt/app / # cp /mnt/early_module.ko / nfs: server 192.168.31.66 not responding, still trying 此问题 100% 必现，影响工作学习，需要赶紧解决。 怀疑对象主要怀疑这几块的问题： vmware 启动的 nfs 服务出现问题 小米路由器的问题 开发板网太卡驱动的问题 一一验证验证过程如下： 重启 vmware 中的 nfs 服务，验证3次，问题仍存在ubuntu 重启 nfs 服务命令如下： user@vmware:~$ sudo /etc/init.d/nfs-kernel-server restart [ ok ] Restarting nfs-kernel-server (via systemctl): nfs-kernel-server.service.sudo /etc/init.d/nfs-kernel-server restart 使用另外一台装有 ubuntu 的笔记本挂载，可以成功挂载并访问，基本排除 nfs 服务问题 user@pavilion:~$ ping 192.168.31.66 PING 192.168.31.66 (192.168.31.66) 56(84) bytes of data. 64 bytes from 192.168.31.66: icmp_seq=1 ttl=64 time=1.10 ms 64 bytes from 192.168.31.66: icmp_seq=2 ttl=64 time=0.826 ms user@pavilion:~$ sudo mount -t nfs 192.168.31.66:/home/user/board /mnt/ -o nolock user@pavilion:~$ ls -l /mnt/ -rwxrwxr-x 1 user user 5543 7月 1 21:18 app -rw-rw-r-- 1 user user 53809 7月 1 21:18 early_module.ko user@pavilion:~$ sudo cp /mnt/app ./ user@pavilion:~$ sudo cp /mnt/early_module.ko ./ user@pavilion:~$ ls -l -rwxr-xr-x 1 root root 5543 7月 6 22:13 app -rw-rw-r-- 1 user user 53809 7月 6 22:13 early_module.ko 可以正常挂载并访问，这就奇怪了，ubuntu 主机可以，但是开发板不行，这两者的差异在哪？ 难道是网卡驱动的问题，文件一大就问题就体现出来了？ 重新烧录友善之臂官方提供的内核，验证3次，问题仍存在，排除网卡问题参考我之前总结的博客重新烧录内核后，验证 [root@FriendlyARM /]# ifconfig eth0 192.168.31.100 [root@FriendlyARM /]# ping 192.168.31.66 PING 192.168.31.66 (192.168.31.66): 56 data bytes 64 bytes from 192.168.31.66: seq=0 ttl=64 time=4.495 ms 64 bytes from 192.168.31.66: seq=1 ttl=64 time=0.780 ms [root@FriendlyARM /]# mount -t nfs 192.168.31.66:/home/user/board /mnt -o nolock [root@FriendlyARM /]# ls -l /mnt/ -rwxrwxr-x 1 1000 1000 5543 Jul 1 2018 app -rw-rw-r-- 1 1000 1000 53809 Jul 1 2018 early_module.ko [root@FriendlyARM /]# cp mnt/app ./ [root@FriendlyARM /]# cp mnt/early_module.ko ./ nfs: server 192.168.31.66 not responding, still trying 使用友善之臂官方提供的网卡也有同样的问题，那就说明不是网卡这一块的问题。 难道是小米路由器不认识 mini2440 开发板，对它做了点限制，我不知道到？ 赶紧闲鱼二手买了个路由器，验证下看看。 换 TP-LINK 路由器验证，问题仍然存在，排除路由器问题 [root@FriendlyARM /]# ifconfig eth0 192.168.1.230 [root@FriendlyARM /]# ping 192.168.1.101 PING 192.168.1.101 (192.168.1.101): 56 data bytes 64 bytes from 192.168.1.101: seq=0 ttl=64 time=4.495 ms 64 bytes from 192.168.1.101: seq=1 ttl=64 time=0.780 ms [root@FriendlyARM /]# mount -t nfs 192.168.1.101:/home/user/board /mnt -o nolock [root@FriendlyARM /]# ls -l /mnt/ -rwxrwxr-x 1 1000 1000 5543 Jul 1 2018 app -rw-rw-r-- 1 1000 1000 53809 Jul 1 2018 early_module.ko [root@FriendlyARM /]# cp mnt/app ./ [root@FriendlyARM /]# cp mnt/early_module.ko ./ nfs: server 192.168.1.101 not responding, still trying 换了路由器，也还是一样，说明不是路由器的问题。 那究竟是什么问题？纠结。 无奈，求助百度，验证多种方案，最后得到的解决方案是: 在 mount 时追加 -otcp 选项。即使用下面命令在开发板上挂载可以有效的解决此问题。 mount -t nfs 192.168.31.66:/home/user/board /mnt -o nolock -otcp mount -t nfs -o intr,nolock,tcp,rsize=1024,wsize=1024 192.168.31.66:/home/user/board /mnt 参考博客https://blog.csdn.net/g1036583997/article/details/44492759 使用友善之臂提供的内核的话，则需要用下面这条命令。 mount -t nfs 192.168.31.66:/home/user/board /mnt -o nolock -otcp 使用百问科技提供的内核的话，用这条命令可以正常访问 nfs 网络文件系统。 mount -t nfs -o intr,nolock,tcp,rsize=1024,wsize=1024 192.168.31.66:/home/user/board /mnt]]></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>mini2440</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C] 引用外部函数]]></title>
    <url>%2F2018%2F06%2F27%2Fc-extern-bug%2F</url>
    <content type="text"><![CDATA[问题当一个文件中需要引用另一个文件中的函数时，一般情况下都会使用 extern 关键字来声明外部函数，然后调用它。如果某个时候，我们修改了被引用的函数原型，但是在 extern 外部申明的位置却忘了修改，会发生什么？如果函数原型改变的话，对应的每个 extern 声明的地方都要改一遍，如果有地方没改到呢？我们通过一个例子来看下悲剧是怎么发生的。 示例文件1：fun.c123456#include &lt;stdio.h&gt;void fun(int data)&#123; printf("data = %d\n", data);&#125; 文件2：main.c12345678910#include &lt;stdio.h&gt;// 注意这里把 fun 声明成无参数的了extern void fun();int main(int argc, char* argv[])&#123; fun(); return 0;&#125; 文件3：Makefile12345678910objs := main.o fun.oapp:$(objs) gcc -Wall -O2 -o app $(objs)%.o:%.c gcc -Wall -O2 -c -o $@ $&lt;clean: rm -f *.o app 执行效果： user@vmware:~/workspace/c/extern-bug$ make gcc -Wall -O2 -c -o main.o main.c gcc -Wall -O2 -c -o fun.o fun.c gcc -Wall -O2 -o app main.o fun.o user@vmware:~/workspace/c/extern-bug$ ./app data = 1 分析 编译的时候即使加了 -Wall 选项也没有编译告警？在 main.c 中，fun 函数被 extern 重定义成无参数的了，所以编译不会告警。如果把 extern 声明去掉，编译器还会给个”函数未显式定义”的警告。 程序链接也没报错？C 语言中，编译出来的函数符号表中是不包含参数的，如下所示，也就是为什么 C 语言不能做编译时的多态。所以，别指望在链接的时候会报错。 user@vmware:~/workspace/c/extern-bug$ nm fun.o 0000000000000000 T fun U printf 程序竟然还能运行？程序输出了1， 这个1是哪里来的？看看下面的执行效果，你是不是明白为什么了？ user@vmware:~/workspace/c/extern-bug$ ./app 2 3 4 5 6 data = 6 user@vmware:~/workspace/c/extern-bug$ ./app 2 3 4 5 6 7 8 9 data = 9 user@vmware:~/workspace/c/extern-bug$ ./app 2 3 data = 3 竟然把 argc 的数值打印出来了！运行的时候调用的肯定还是带参数的 func 函数，但是参数从哪里来呢？处于栈顶的 argc 就被取出来塞给 func 函数了，所以它的数值被打印出来了{压栈方式不同的话，也有可能打印argv)。 都这样了，接下来离各种异常还远吗？这种问题定位起来会搞死人的。 改进建议通过头文件引用的方式来调用外部函数，追加一个新文件 fun.h 123456#ifndef __FUN_H__#define __FUN_H__void fun(int data);#endif 如果 main.c 中 fun 调用还是没有传参 12345678#include &lt;stdio.h&gt;#include "fun.h"int main(int argc, char* argv[])&#123; fun(); return 0;&#125; 则会报错，可以及时发现问题 main.c: In function ‘main’: main.c:6:9: error: too few arguments to function ‘fun’ fun(); ^ In file included from main.c:2:0: fun.h:4:6: note: declared here void fun(int data); ^ Makefile:7: recipe for target &apos;main.o&apos; failed make: *** [main.o] Error 1]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>extern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python] 安装 python3]]></title>
    <url>%2F2018%2F06%2F13%2Fpython-install-python3%2F</url>
    <content type="text"><![CDATA[一 ubuntu 下安装 Python3 使用 apt-get 安装 python3 user@vmware:~$ sudo apt-get install python3.5 验证是否安装成功 user@vmware:~$ python Python 2.7.12 (default, Nov 20 2017, 18:23:56) [GCC 5.4.0 20160609] on linux2 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; 很奇怪，明明安装的是 python3.5，但是执行时调用的却是 python2.7 找一下版本不对的原因搜索下 python 命令看看 user@vmware:~$ cd / user@vmware:/$ sudo find -name &quot;python&quot; ./var/lib/python ./usr/bin/python ./usr/lib/libreoffice/share/Scripts/python ./usr/share/gdb/python ./usr/share/gcc-5/python ./usr/share/lintian/overrides/python ./usr/share/doc/python ./usr/share/bash-completion/completions/python ./usr/share/python ./usr/share/librevenge/python ./etc/apparmor.d/abstractions/python ./etc/python 上面的搜索结果就 ./usr/bin/python 有点像可执行文件，看一眼 user@vmware:/$ ls -l /usr/bin/python lrwxrwxrwx 1 root root 18 6月 13 22:34 /usr/bin/python -&gt; /usr/bin/python2.7 确认到 python 命令其实是指向同级目录下 python2.7 的符号连接，看看 /usr/bin/ 目录下的 python 命令集合 user@vmware:/$ ls -l /usr/bin/python* lrwxrwxrwx 1 root root 18 6月 13 22:34 /usr/bin/python -&gt; /usr/bin/python2.7 lrwxrwxrwx 1 root root 9 4月 27 23:20 /usr/bin/python2 -&gt; python2.7 -rwxr-xr-x 1 root root 3542008 11月 24 2017 /usr/bin/python2.7 lrwxrwxrwx 1 root root 9 4月 27 23:20 /usr/bin/python3 -&gt; python3.5 -rwxr-xr-x 2 root root 4464400 11月 29 2017 /usr/bin/python3.5 -rwxr-xr-x 2 root root 4464400 11月 29 2017 /usr/bin/python3.5m lrwxrwxrwx 1 root root 10 4月 27 23:20 /usr/bin/python3m -&gt; python3.5m 发现，还有 python3.5，因此只要将 python 链接到 python3.5 就可以了 修改 python 链接 user@vmware:/$ sudo rm -rf /usr/bin/python user@vmware:/$ sudo ln -s /usr/bin/python3.5 /usr/bin/python user@vmware:/$ ls -l /usr/bin/python lrwxrwxrwx 1 root root 18 6月 13 22:46 /usr/bin/python -&gt; /usr/bin/python3.5 再次验证是否安装成功 user@vmware:/$ python Python 3.5.2 (default, Nov 23 2017, 16:37:01) [GCC 5.4.0 20160609] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C] 条件表达式]]></title>
    <url>%2F2018%2F06%2F13%2Fc-conditional-operator%2F</url>
    <content type="text"><![CDATA[遇到疑惑最近在阅读内核源码的时候，发现条件表达式居然可以省略 ture 表达式，示例如下： 12345678// file: src/kernel/msm-3.18/drivers/video/msm/mdss/mdss_dsi_panel.cvoid mdss_dsi_parse_esd_params(struct device_node *np, struct mdss_dsi_ctrl_pdata *ctrl)&#123; ... ... lenp = ctrl-&gt;status_valid_params ?: ctrl-&gt;status_cmds_rlen; ... ...&#125; 以往我们在使用条件表达式的格式是: 表达式1 ? 表达式2 : 表达式 3。对于条件表达式的值是：判断表达式1的值，ture的话条件表达式的值为表达式2的值，false的话条件表达式的值为表达式3的值。但是上面 ture 对应的表达式为是空的，因此产生一个疑问: 难道将空值赋给 lenp 变量？ 示例验证决定在 ubuntu 上编写一个小示例程序验证下，验证用的示例程序如下： 1234567891011121314// file: conditional-operator.c#include "stdio.h"int main()&#123; int a = 0, b = 0, c = 0, d = 0; a = 7 ? : 1; b = 0 ? : 2; c = (7 &gt; 4) ? : 3; d = (7 &lt; 4) ? : 4; printf("a = %d, b = %d, c = %d, d = %d\n", a, b, c, d); return 0;&#125; 编译执行结果如下： user@vmware:~/c$ gcc conditional-operator.c -o app &amp;&amp; ./app a = 7, b = 2, c = 1, d = 4 同步想要确认下，如果省略表达式2，d的值是否是0? 保持其他不变，仅修改 d 的赋值语句。 1234567891011121314// file: conditional-operator.c#include "stdio.h"int main()&#123; int a = 0, b = 0, c = 0, d = 0; a = 7 ? : 1; b = 0 ? : 2; c = (7 &gt; 4) ? : 3; d = (7 &lt; 4) ? 4 : ; printf("a = %d, b = %d, c = %d, d = %d\n", a, b, c, d); return 0;&#125; 很遗憾，编译报错了，说明表达式3不允许省略。 user@vmware:~/c$ gcc conditional-operator.c -o app &amp;&amp; ./app conditional-operator.c: In function ‘main’: conditional-operator.c:9:20: error: expected expression before ‘;’ token d = (7 &lt; 4) ? 4 : ; 得出结论从示例程序的运行结果可以发现，在表达式1为 true 的前提下，表达式2可以省略，此情况下会将表达式1的值作为整个条件表达式的结果。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] LCM 相关 debug 实例]]></title>
    <url>%2F2018%2F06%2F05%2Fodm-lcm-debug-instance%2F</url>
    <content type="text"><![CDATA[实例1：闪屏问题问题描述工厂 OOB 测试先后测试出 3pcs 闪屏机器，不良现象为每隔 2s 左右规律性的出现一次黑屏，上海可生产测试出 1pcs 闪屏机器，不良现象和工厂不良一致 分析过程 分析工厂传回的 log不良现象为每隔 2s 黑屏一次，2s 的频率和 esd check 的频率一致，并且 esd recover 动作掉电确实会黑屏一次，重点怀疑 esd check 这块 [ 590.217496] lcd esd return_buf[1] = 0x88 status_value = 0x80 [ 593.385461] lcd esd check failed mdss_check_dsi_ctrl_status 175 [ 595.897451] lcd esd return_buf[1] = 0x88 status_value = 0x80 [ 597.856254] lcd esd check failed mdss_check_dsi_ctrl_status 175 [ 600.125425] lcd esd return_buf[1] = 0x88 status_value = 0x80 [ 602.998541] lcd esd check failed mdss_check_dsi_ctrl_status 175 [ 604.342345] lcd esd return_buf[1] = 0x88 status_value = 0x80 搜索 lcd esd 关键字，确认到，确实是 lcd esd check fail，触发 recover 动作(黑屏一次)，正常情况下，recover 动作执行完后，ic 状态应该恢复正常，再次 check 将会 pass，但是，通过 log 中看出，recover 动作后，esd check 仍旧 fail，说明 ic 状态还是异常，再次触发 recover(黑屏一次)，如此循环，出现闪屏 确认是哪一项 check failed查看屏 dtsi 中 esd 相关的属性值，确认到是 09 寄存器第一个字节异常 qcom,esd-check-enabled; /* 指定 esd check 的 command，cmd 最后一次字节是 check 的寄存器 */ qcom,mdss-dsi-panel-status-command = [ 14 01 00 01 05 00 01 68 06 01 00 01 05 00 01 09 14 01 00 01 05 00 01 CC 14 01 00 01 05 00 01 AF ]; qcom,mdss-dsi-panel-status-command-state = &quot;dsi_lp_mode&quot;; qcom,mdss-dsi-panel-status-check-mode = &quot;reg_read&quot;; /* 在 command 中指定指定过了 check 的寄存器，这里指定 check 对应寄存器的前几个字节 */ qcom,mdss-dsi-panel-status-read-length = &lt;1 3 1 1&gt;; qcom,mdss-dsi-panel-max-error-count = &lt;2&gt;; /* 指定 esd check 读取的寄存器的标准值 buf[0] buf[1] buf[2] buf[3] buf[4] buf[5] */ qcom,mdss-dsi-panel-status-value = &lt;0xC0&gt;, &lt;0x80 0x73 0x04&gt;, &lt;0x0B&gt;, &lt;0xFD&gt;; 怎么确认的：qcom,mdss-dsi-panel-status-command 指定了要 check 哪些寄存器qcom,mdss-dsi-panel-status-read-length 指定了要 check 这些寄存器的前几个字节，并将这些字节，依次编号为 0,1,2,3…因此确认到 buf[1] 对应的是 09 寄存器的第一个字节，正常状态下 09h_01 = 0x80，但是异常情况下读取出来的是 0x88, bit3 从 0 变成了 1 查看 spec 确认 09h_01[3] 表示什么含义 确认到是 VGL 电压异常，看 spec 描述应该是 VGL 电压高于 esd 侦测的标准，导致 09h_01[3] 被置位，接下来需要实际测量下是否真的是这样的情况 交叉主板和三合一，确认到闪屏不良现象跟着三合一模组走 实测良品和不良显示屏单体 VGL 电压这里贴出模组厂验证情况： 确认到不良单体的 VGL 电压较正常品偏低，和步骤3猜想一致 分析结论此闪屏问题为 LCD 三合一模组单体不良，不良单体 VGL 电压较正常单体偏低，导致触发 esd check fail，并且 recover 无法修正，因此出现闪屏现象。 实例2：闪屏问题衍生问题问题描述衍生出来问题情况很复杂，一条一条描述： 工厂出现不良的机器，发现在 OOB 测试用的 user b08 版本 100% 闪屏，但是在组装用的 eng b08 版本 100% 不闪屏，客户需要我们理清 eng 和 user 版本的区别点 上面模组厂测试的结果发现，在不同的界面下(桌面、白图、flick图片) VGL 的电压不一致，客户想要理清不一致的原因 同步和玻璃厂 FAE 确认到玻璃要求的 VGL 电压范围为 -9V ~ -11V，但是从模组厂测试的结果发现，即使是良品也是不符合玻璃 spec 的，客户追问为什么良品也不满足，是否是软件上设置不对 分析过程议题1：eng 和 user 版本的区别点 将代码回退到 eng B08(Factory分支) 和 user b08(MP分支) 时间节点，对比 lcd 驱动代码和 dtsi 配置文件，驱动和配置完全一模一样。同时使用上海已经拆解的不良品，分别刷 user b08 和 eng b8 版本，使用高精度示波器测量主界面桌面状态下，得到 VGL 电压分别为 8.075V(eng) 和 8.045V(user)，user 和 eng 版本测试结果电压基本一致 考虑到模组厂测试的结果，在不同的界面下 VGL 的电压不一致，怀疑是测试场景的区别导致 eng 和 user 版本的 VGL 电压不一致，因此安排工厂使用工厂不良机在 flicker 图片验证 eng 版本是否闪屏，但是工厂不良机已经打回组装车间维修掉了，不良机丢失 由于不良机丢失，无法验证工厂不良机是否是测试场景的区别导致 eng 和 user 版本的 VGL 电压不一致，但是从验证步骤1的结论看来，user 版本和 eng 版本 VGL 电压基本一致，客户不再追究 user 和 eng 版本的差异了。但是由于我司工厂生产流程是: 贴片 -&gt; 组装 -&gt; 组装测试(eng) -&gt; 前10k的订单会额外进行OOB测试(user) -&gt; 包装 -&gt; 出货，对于后续出货的机器，并不会再刷 user 版本进行 OOB 测试，目前看到有 1pcs 闪屏机器是在 eng 不闪，user 版本才闪，客户需要提供一种卡关策略，要保证所有的 VGL 偏低的单体不良的机器可以在 eng 版本下 100% 被卡下来，保证不会流到用户手中 根据上面模组厂测试的结果可以看出在 flicker 图片界面，VGL 被拉到最低，最容易触发 esd check fail。因此卡关策略为将 flicker 图片导入工模 lcd 测试项中，要求产线在测试 lcd 测试项是静置手机在 flicker 图片 10s 左右，观是否有闪屏现象。若闪屏，则当做不良品打出，若不闪，则可以保证用户在其他场景下使用也不会闪屏。此方案客户已经认可，并导入了最新版本中 议题2：为什么不同场景 VGL 电压不一致 此议题涉及 LCM 内部组成原理，由部件主导回复，软件无需跟进 议题3：为什么良品三合一的 VGL 电压也不符合玻璃 spec 确认软件设置的 VGL 值是多少屏 dtsi 配置 C1 寄存器值如下： qcom,mdss-dsi-on-command = [ ... ... /* command format len reg 1 2 3 4 5 6 7 8 9 10 11 12 */ 39 01 00 00 00 00 0d C1 54 00 1E 1E 77 C1 FF FF EE EE EE EE ... ... ] spec 描述如下： 确认到软件上设置 C1 寄存器的值为 0x54，对照 spec 确认到 VGL 值是 -11V，符合玻璃 spec 标准。但实际输出仅有 8.5V 左右，约 FAE 一起分析，确认到是 C1h_06[5]:TURBO 没有使能 TURBO 软件上为什么没有使能 TURBO项目初期是使能了 TURBO 的，但是后面为了解决射频干扰问题，将其关闭了 解射频干扰时没有考虑玻璃 VGL 电压要求吗?玻璃 spec Gate 电压要求： 玻璃 spec 上仅仅说明了 typ 值是 -10V，并没有指明 min、max 值，一般没有写明 min 值则认为玻璃没有 min 值的要求，因此当时才将 VGL 适当调低以优化射频干扰问题，后面提到的 -9V ~ -11V 是出现闪屏问题后玻璃厂 FAE 提供的电压范围 目前所有三合一模组 100% 不符合玻璃 spec 要怎么处理处理方式：重新开启 TURBO 功能此处理方案需要重新调试射频干扰，并且 lcd 主客观测试需要重测，测试好后还要将新的参数重新烧录到模组 OTP 中，和模组厂确认了目前已经生产了 150k 左右的模组，意味着这 150k 的模组，需要重新返工，并且对于已经装机的机器，要拆机成三合一状态，重烧 OTP，是个大动作，此方案客户和项目都不同意 实测的 VGL 电压偏低是否会出现大批量闪屏的风险唯一的处理方案客户不同意，那只能将就着使用目前 VGL 设定了，但目前实际测试得到的 VGL 电压和 esd 侦测 VGL 的标准(-8.5V)很接近，可能会出现大批量闪屏的风险，因此考虑将 esd 侦测标准从 -8.5V 修改为 -8.0V屏 dtsi 配置 C6 寄存器值如下： qcom,mdss-dsi-on-command = [ ... ... /* command format len reg 1 2 3 4 5 */ 39 01 00 00 00 00 06 C6 26 40 CF 7F 20 ... ... ] spec 描述如下： 因此将 C6_01 从 26 修改为 16 即可配置 esd check 标准为 8.0V]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>qcom</tag>
        <tag>lcm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 搭建韦东山三期项目视频学习环境]]></title>
    <url>%2F2018%2F06%2F02%2Fmini2440-build-100ask3prj-dev-env%2F</url>
    <content type="text"></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>mini2440</tag>
        <tag>100ask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] TP 相关 debug 实例]]></title>
    <url>%2F2018%2F05%2F31%2Fodm-tp-debug-instance%2F</url>
    <content type="text"><![CDATA[前言TP 这块出现问题，条件允许的话，一定要第一时间拿到不良机，使用不良机复现问题，在线调试。这里说的在线调试是指通过 adb 实时打印 log。实时打印 kernel log 可以通过下面几条命令： dmesg -w | grep -E &lt;keyword&gt; logcat -b kernel | grep -E &lt;keyword&gt; 实时打印 main log 可以通过下面命令： logcat | grep -E &lt;keyword&gt; 上面使用的是 grep -E 选项，因此 keyword 可以使用正则表达式进行过滤。 如果没有办法协调到不良机在线调试，对于手势概率性识别的问题，那就很尴尬了，因为很多时候 log 中是看不到手势未识别的情况的。比如说，用户画了20次C手势，我在 log 中看到14次正常，我不知道具体是哪一次未识别，还是说用户这一次画手势的操作手法不规范，很多东西没有办法确认到，没有办法细致的分析。 TP 手势 log，需要按照以下流程抓取log： 开启 log 工具抓取 log。 用另一台手机录制视频，主要录制画手势的手法。 在设置界面开关下手势。(就算之前开过手势了，也请操作以下，我用这个时间点和视频中的时间点做对应，计算后面画手势动作对应的 log 时间点) 进行手势操作即可。 实例1：手势失效工厂出现 200pcs 手势功能失效，无法唤醒手势或打开手势对应的 app，从工厂协调 2pcs 不良机，分析过程如下： 确认上层手势开关设置是否生效在设置界面中设置手势的开关，看底层 TP 手势 proc 节点的 log 有没有打印 [ 3834.582866] [Paul][HXTP][himax_GESTURE_write][2966] gesture flag: 01111111 确认到有相关 log 打印，从上述 log 确认到上层设置手势开关生效了 确认 TP 睡眠时有没有成功进入手势模式按 power key 灭屏，看 suspend log 确认是否进入手势模式 [ 3858.094688] [HXTP] [himax] himax_chip_common_suspend: SMART_WAKEUP enable, reject suspend 从上述 log 确认到进入了手势模式 确认是否有手势键值上报进入手势模式了，尝试双击看看有没有 event 事件上报。多次画手势动作，均没有看到手势上报对应的 log，确认到没有事件上报 确认熄屏手势 TP 是否产生中断查看 /proc/interrupts 节点，看看有没有检测到 TP 的中断熄屏状态下画手势，TP 中断计数没有增加，确认到没有中断产生怀疑 TP 没有识别到手势，因此没有触发中断。 此问题需要联系 FAE 进一步分析，分析是否是 TP 固件侧的问题最后确认到是固件侧没有识别到手势，没有触发手势中断TP 供应商优化固件后，将 TP 扫描方式从自容扫描修改为互容扫描，提高手势识别率解决了此问题 实例2：固件升级失败供应商发布 0x8 版本的 TP 固件需要合入临时版本给测试验证，出现升级失败的问题。分析过程如下： 0x7 版本三合一刷 0x8 版本固件 –&gt; 升级失败将 0x8 版本固件合入软件中，刷机第一次开机，log 中正确读取了 IC 和 版本中的固件版本号，但是升级函数返回值出错，升级失败 [ 5.153623] [wjwind] current name = st7703 720p video mode dsi panel [ 5.159843] [wjwind] IC fw =0xe502 conf = 0x7 Firmware: fw = 0xe502, conf = 0x8 [ 7.207020] [HXTP] irq_enable_count = 0[HXTP][ERROR] i_update_FW: TP upgrade error, upgrade_times = 1 [ 7.216221] [HXTP][ERROR] i_update_FW: TP upgrade error, upgrade_times = 2 [ 7.429449] [HXTP][ERROR] i_update_FW: TP upgrade error, upgrade_times = 3 0x7 版本三合一刷 0x8 版本固件 –&gt; 升级失败重新启动，看看第二次重启是否 ok，报错同上 0x6 版本三合一刷 0x8 版本固件 –&gt; 升级失败将三合一通过 bat 脚本强制刷到 0x6 版本固件，使用 0x8 固件的软件版本开机，log 中正确读取了 IC 和 版本中的固件版本号，升级还是失败，报错同上 [ 5.413623] [wjwind] current name = st7703 720p video mode dsi panel [ 5.419842] [wjwind] IC fw =0xe502 conf = 0x6 Firmware: fw = 0xe502, conf = 0x8 [ 7.418033] [HXTP] irq_enable_count = 0[HXTP][ERROR] i_update_FW: TP upgrade error, upgrade_times = 1 [ 7.418035] [HXTP][ERROR] i_update_FW: TP upgrade error, upgrade_times = 2 [ 7.418037] [HXTP][ERROR] i_update_FW: TP upgrade error, upgrade_times = 3 0x6 版本三合一刷 0x7 版本固件 –&gt; 升级成功使用上一步刷的 0x6 版本的三合一，刷 0x7 固件的软件版本，开机，升级流程正常 [ 4.768697] [wjwind] current LCM = st7703 720p video mode dsi panel [ 5.199845] [wjwind] IC fw =0xe502 conf = 0x6 Firmware: fw = 0xe502, conf = 0x7 [ 20.428222] [HXTP] i_update_FW: TP upgrade OK 怀疑无法升级至 0x8 版本，是 0x8 版本固件存在问题通过 log 发现，log 中读取的固件长度相比于正常固件的大小偏小，最后确认到是因为我使用的是 Foxmail 邮件客户端，收取固件的时候，部分数据丢失。供应商发出的是 165KB 大小固件文件，我通过 Foxmail 接收到的固件只有 125KB，将固件压缩后重发，Foxmail 接收到后并解压得到 165KB 的固件，使用完整的固件升级成功 实例3：手势失效部件出现两台手势失效的机器，参考实例1的分析过程，实例3分析过程如下： 确认到上层手势开关设置生效 确认到 TP 睡眠时有进入手势模式 确认到没有手势事件上报 确认到有中断计数，TP 产生了中断 查看 TP 中断中的 log，发现异常 log 如下： [ 3858.094688] [HXTP][HIMAX TP MSG] checksum fail : checksum_cal: 0x49C [ 3858.636112] [HXTP][HIMAX TP MSG] checksum fail : checksum_cal: 0x7F8 [ 3858.706841] [HXTP][HIMAX TP MSG] checksum fail : checksum_cal: 0x4C4 查看代码发现，这里 checksum 函数校验的是 TP i2c 回传的数据 buf，在手势模式下会去校验 buf 的格式是否满足手势键值的格式。若发现不符合手势数据 buf 格式，则会打印此 log 约供应商一起分析此问题，复现问题的状态下，通过 proc/android_touch/register 节点查看 8F 状态寄存器确认到 8F 寄存器的值为 0xA0，正常情况进入手势的话，8F 寄存器的值应该是 0x20 这里介绍下，Himax 的 TP 有三种工作状态，分别是：normal mode([8F] = 0x00)，gesture mode([8F] = 0x20)，hsen mode([8F] = 0x40)。括号中是对应的 8F 寄存器的值，8F 寄存器是工作状态寄存器，其中位5是手势标识位，位6是手套标识位，其他位是保留位，没有使用。TP 在 suspend 函数中会先读取 8F 寄存器中的值，然后根据驱动中的手势使能标识和手套使能标识修改 8F 寄存器的位5和位6，将修改后的值写回 8F 寄存器中。 在读写 8F 寄存器的位置添加 log 后复现问题，确认到：正常情况下，TP suspend 读取 tp 的 8F 寄存器是读取到 0x00，将手势标识位位5置位后，得到 0x20，写回 TP 中，TP 进入手势模式。异常情况1，读取到的值是 0x80，将位5置位后，得到 0xA0，写回 TP 中，TP 工作状态异常。异常情况2，读取到的值是 0x00，将位5置位后，得到 0x20，写回 TP 中，TP 值没有生效，还是 0x00 。TP 工作状态异常。在上述两种异常情况下，TP 固件侧都未处于手势模式，因此回传的 buf 自然校验不过，就出现了 checksum fail 的情况。 问题定位到是 TP 状态寄存器值异常，和 FAE 确认到，驱动在 suspend 中，针对手势和手套有做两次分别读写 8F 的寄存器的动作，在 himax_set_SMWP_enable 手势操作完 8F 寄存器后，此时固件也会去操作 8F 寄存器，获取 TP 的最新状态，固件操作 8F 可能会和 himax_set_HSEN_enable 同时操作到 8F 寄存器，产生冲突，导致值出现异常。供应商有做实验，强制高频率让驱动和固件同时操作 8F 寄存器，看是否高概率出现 8F 寄存器的值不稳定，确认到确实存在这样的情况。最后拟定解决方案为：将手势和手套单独读写修改标识位的方式，修改为一起判断标识位，只做一次读写。具体修改 diff 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788diff --git a/drivers/input/touchscreen/HX8527/himax_debug.c b/drivers/input/touchscreen/HX8527/himax_debug.cindex 4f0ea5b..ed3e9a8 100755--- a/drivers/input/touchscreen/HX8527/himax_debug.c+++ b/drivers/input/touchscreen/HX8527/himax_debug.c@@ -2811,7 +2811,8 @@ static ssize_t himax_HSEN_write(struct file *file, const char *buff, else return -EINVAL; - himax_set_HSEN_enable(ts-&gt;client, ts-&gt;HSEN_enable, ts-&gt;suspended);+ // himax_set_HSEN_enable(ts-&gt;client, ts-&gt;HSEN_enable, ts-&gt;suspended);+ himax_set_work_status(ts-&gt;client, ts-&gt;SMWP_enable, ts-&gt;HSEN_enable, ts-&gt;suspended); I(&quot;%s: HSEN_enable = %d.\n&quot;, __func__, ts-&gt;HSEN_enable); @@ -2878,7 +2879,8 @@ static ssize_t himax_SMWP_write(struct file *file, const char *buff, else return -EINVAL; - himax_set_SMWP_enable(ts-&gt;client, ts-&gt;SMWP_enable, ts-&gt;suspended);+ // himax_set_SMWP_enable(ts-&gt;client, ts-&gt;SMWP_enable, ts-&gt;suspended);+ himax_set_work_status(ts-&gt;client, ts-&gt;SMWP_enable, ts-&gt;HSEN_enable, ts-&gt;suspended); HX_SMWP_EN = ts-&gt;SMWP_enable; paul(&quot;SMART_WAKEUP_enable = %d&quot;, HX_SMWP_EN);diff --git a/drivers/input/touchscreen/HX8527/himax_ic.c b/drivers/input/touchscreen/HX8527/himax_ic.cindex 6611e90..b26ce10 100755--- a/drivers/input/touchscreen/HX8527/himax_ic.c+++ b/drivers/input/touchscreen/HX8527/himax_ic.c@@ -901,6 +901,25 @@ test_retry: return pf_value; &#125; +void himax_set_work_status(struct i2c_client *client, uint8_t SMWP_enable, uint8_t HSEN_enable, bool suspended)+&#123;+ uint8_t buf[4];+ i2c_himax_read(client, 0x8F, buf, 1, DEFAULT_RETRY_CNT);++ if(SMWP_enable == 1 &amp;&amp; suspended)+ buf[0] = 0x20 ;+ else+ buf[0] = 0x00;++ if(HSEN_enable == 1 &amp;&amp; !suspended)+ buf[0] = 0x40;+ else+ buf[0] &amp;= 0xBF;++ if ( i2c_himax_write(client, 0x8F,buf, 1, DEFAULT_RETRY_CNT) &lt; 0)+ E(&quot;%s i2c write fail.\n&quot;,__func__);+&#125;+ void himax_set_HSEN_enable(struct i2c_client *client, uint8_t HSEN_enable, bool suspended) &#123; uint8_t buf[4];@@ -2268,12 +2293,16 @@ void himax_resend_cmd_func(bool suspended) #endif &#125; -#ifdef HX_SMART_WAKEUP- himax_set_SMWP_enable(ts-&gt;client,ts-&gt;SMWP_enable,suspended);-#endif-#ifdef HX_HIGH_SENSE- himax_set_HSEN_enable(ts-&gt;client,ts-&gt;HSEN_enable,suspended);-#endif+// #ifdef HX_SMART_WAKEUP+// himax_set_SMWP_enable(ts-&gt;client,ts-&gt;SMWP_enable,suspended);+// #endif+// #ifdef HX_HIGH_SENSE+// himax_set_HSEN_enable(ts-&gt;client,ts-&gt;HSEN_enable,suspended);+// #endif++ himax_set_work_status(ts-&gt;client, ts-&gt;SMWP_enable, ts-&gt;HSEN_enable, suspended);+ #ifdef HX_USB_DETECT_GLOBAL himax_cable_detect_func(true); #endifdiff --git a/drivers/input/touchscreen/HX8527/himax_ic.h b/drivers/input/touchscreen/HX8527/himax_ic.hindex 21361f1..4e0c286 100755--- a/drivers/input/touchscreen/HX8527/himax_ic.h+++ b/drivers/input/touchscreen/HX8527/himax_ic.h@@ -72,6 +72,7 @@ enum fw_image_type int himax_hand_shaking(struct i2c_client *client); void himax_set_SMWP_enable(struct i2c_client *client,uint8_t SMWP_enable, bool suspended); void himax_set_HSEN_enable(struct i2c_client *client,uint8_t HSEN_enable, bool suspended);+void himax_set_work_status(struct i2c_client *client, uint8_t SMWP_enable, uint8_t HSEN_enable, bool suspended); void himax_usb_detect_set(struct i2c_client *client,uint8_t *cable_config); int himax_determin_diag_rawdata(int diag_command); int himax_determin_diag_storage(int diag_command);]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>qcom</tag>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 搭建韦东山二期驱动视频学习环境]]></title>
    <url>%2F2018%2F05%2F19%2Fmini2440-build-100ask2drv-dev-env%2F</url>
    <content type="text"><![CDATA[前言韦东山老师的视频使用的是 JZ2440 开发板，本来使用视频配套的 JZ2440 开发板学习起来才会事半功倍，但是目前我手头上已经有了 mini2440 开发板以及配套的 X35 LCD，想将现有资源充分利用起来。并且韦东山老师经常说天下 2440 开发板都一样，让我更加断绝了购买 JZ2440 的欲望。因此决定使用 mini2440 学习韦东山老师的视频，才有了本文。本文主要记录在 mini2440 上移植 u-boot-1.1.6 和 linux-2.6.22.6 学习环境，总结此文，以便日后查阅。 一 配置编译 u-boot1.1 获取 u-boot 源码并打补丁解压 u-boot 源码 user@vmware:~/mini2440$ tar jxf u-boot-1.1.6.tar.bz2 user@vmware:~/mini2440$ cd u-boot-1.1.6/ 清除配置 user@vmware:~/mini2440/u-boot-1.1.6$ make distclean 创建 git 版本库管理源码 user@vmware:~/mini2440/u-boot-1.1.6$ git init Initialized empty Git repository in /home/user/mini2440/u-boot-1.1.6/.git/ user@vmware:~/mini2440/u-boot-1.1.6$ git add --all user@vmware:~/mini2440/u-boot-1.1.6$ git commit -m &quot;init: get the u-boot source code by 100ask.net&quot; 给 u-boot 打补丁 user@vmware:~/mini2440/u-boot-1.1.6$ patch -p1 &lt; ../u-boot-1.1.6_jz2440.patch user@vmware:~/mini2440/u-boot-1.1.6$ git add --all user@vmware:~/mini2440/u-boot-1.1.6$ git commit -m &quot;patch: u-boot-1.1.6_jz2440.patch&quot; 1.2 配置、编译 u-boot配置 user@vmware:~/mini2440/u-boot-1.1.6$ make 100ask24x0_config Configuring for 100ask24x0 board... 编译 user@vmware:~/mini2440/u-boot-1.1.6$ make ... ... /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_udivsi3.o): In function `__aeabi_uidiv&apos;: (.text+0x0): multiple definition of `__udivsi3&apos; lib_arm/libarm.a(_udivsi3.o):/home/user/mini2440/u-boot-1.1.6/lib_arm/_udivsi3.S:17: first defined here arm-linux-ld: ERROR: Source object /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_udivdi3.o) has EABI version 5, but target u-boot has EABI version 0 arm-linux-ld: failed to merge target specific data of file /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_udivdi3.o) arm-linux-ld: ERROR: Source object /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_udivsi3.o) has EABI version 5, but target u-boot has EABI version 0 arm-linux-ld: failed to merge target specific data of file /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_udivsi3.o) arm-linux-ld: ERROR: Source object /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_dvmd_lnx.o) has EABI version 5, but target u-boot has EABI version 0 arm-linux-ld: failed to merge target specific data of file /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_dvmd_lnx.o) arm-linux-ld: ERROR: Source object /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_clz.o) has EABI version 5, but target u-boot has EABI version 0 arm-linux-ld: failed to merge target specific data of file /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_clz.o) /opt/gcc/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/armv4t/libgcc.a(_dvmd_lnx.o): In function `__aeabi_ldiv0&apos;: (.text+0x8): undefined reference to `raise&apos; Makefile:263: recipe for target &apos;u-boot&apos; failed make: *** [u-boot] Error 1 编译报错了，百度确认到是因为我使用的编译器是友善之臂的提供的 4.3.2 版本的编译器，编译器的库文件和 U-Boot 源码中的函有重复定义，换成 100ask 光盘提供的 3.4.5 版本的编译器就不存在此问题。解压 100ask 提供的交叉编译器 user@vmware:~/mini2440/u-boot-1.1.6$ cd ../ user@vmware:~/mini2440$ tar jxf arm-linux-gcc-3.4.5-glibc-2.3.6.tar.bz2 user@vmware:~/mini2440$ cd gcc-3.4.5-glibc-2.3.6/bin/ user@vmware:~/mini2440/gcc-3.4.5-glibc-2.3.6/bin$ pwd /home/user/mini2440/gcc-3.4.5-glibc-2.3.6/bin 修改 u-boot 的 Makefile 指定编译使用刚刚解压的交叉编译器，修改点如下： user@vmware:~/mini2440/gcc-3.4.5-glibc-2.3.6/bin$ cd ../../u-boot-1.1.6/ user@vmware:~/mini2440/u-boot-1.1.6$ vim Makefile user@vmware:~/mini2440/u-boot-1.1.6$ git diff diff --git a/Makefile b/Makefile index a8fdbb1..f7ed826 100644 --- a/Makefile +++ b/Makefile @@ -125,7 +125,7 @@ ifeq ($(ARCH),ppc) CROSS_COMPILE = powerpc-linux- endif ifeq ($(ARCH),arm) -CROSS_COMPILE = arm-linux- +CROSS_COMPILE = /home/user/mini2440/gcc-3.4.5-glibc-2.3.6/bin/arm-linux- endif ifeq ($(ARCH),i386) ifeq ($(HOSTARCH),i386) user@vmware:~/mini2440/u-boot-1.1.6$ git add --all user@vmware:~/mini2440/u-boot-1.1.6$ git commit -m &quot;conf: modify the cross compiler&quot; 重新配置编译 user@vmware:~/mini2440/u-boot-1.1.6$ make distclean user@vmware:~/mini2440/u-boot-1.1.6$ make 100ask24x0_config user@vmware:~/mini2440/u-boot-1.1.6$ make 确认到 u-boot.bin 镜像成功生成 user@vmware:~/mini2440/u-boot-1.1.6$ ls -l u-boot.bin -rwxrwxr-x 1 user user 198324 5月 17 22:39 u-boot.bin 1.3 给 u-boot 添加 .gitignore 文件编译完 u-boot 后，通过 git st 查看发现全是编译的中间文件，这些文件根本不需使用版本库进行管理，因此我们要忽略它们。随便解压一个 linux 内核，拷贝内核的忽略规则 user@vmware:~/mini2440/u-boot-1.1.6$ cd ../ user@vmware:~/mini2440$ tar jxf linux-2.6.22.6.tar.bz2 user@vmware:~/mini2440$ cd u-boot-1.1.6/ user@vmware:~/mini2440/u-boot-1.1.6$ cp ../linux-2.6.22.6/.gitignore ./ 将 kernel 默认的忽略文件拷贝到 u-boot 源码中，很好，大部分的中间文件都成功忽略了，但是通过 git st 查看还是有部分中间文件没有被忽略 user@vmware:~/mini2440/u-boot-1.1.6$ git st On branch master Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) examples/hello_world examples/hello_world.bin examples/hello_world.srec include/asm-arm/arch include/asm-arm/proc include/bmp_logo.h include/config.h include/config.mk include/version_autogenerated.h tools/bmp_logo tools/crc32.c tools/envcrc tools/environment.c tools/gen_eth_addr tools/img2srec tools/mkimage u-boot u-boot.bin u-boot.map u-boot.srec nothing added to commit but untracked files present (use &quot;git add&quot; to track) 将这些文件手动添加到 .gitignore 文件中，值得注意的是，内核默认的忽略规则会将 . 开头的隐藏文件一并忽略掉，这里需要强制指定不忽略 .gitignore 文件注意：diff 命令的 &lt; 相当于 git diff 的 +，&gt; 相当于 git diff 的 - user@vmware:~/mini2440/u-boot-1.1.6$ vim .gitignore user@vmware:~/mini2440/u-boot-1.1.6$ diff .gitignore ../linux-2.6.22.6/.gitignore 5,29d4 &lt; &lt; # &lt; # maiot added rules &lt; # &lt; examples/hello_world &lt; examples/hello_world.bin &lt; examples/hello_world.srec &lt; include/asm-arm/arch &lt; include/asm-arm/proc &lt; include/bmp_logo.h &lt; include/config.h &lt; include/config.mk &lt; include/version_autogenerated.h &lt; tools/bmp_logo &lt; tools/crc32.c &lt; tools/envcrc &lt; tools/environment.c &lt; tools/gen_eth_addr &lt; tools/img2srec &lt; tools/mkimage &lt; u-boot &lt; u-boot.bin &lt; u-boot.map &lt; u-boot.srec &lt; 34,35d8 &lt; # don&apos;t ignore the .gitignore file &lt; !.gitignore 此时成功将编译的中间文件全部过滤 user@vmware:~/mini2440/u-boot-1.1.6$ git st On branch master Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore nothing added to commit but untracked files present (use &quot;git add&quot; to track) 很好，提交忽略规则到版本库中 user@vmware:~/mini2440/u-boot-1.1.6$ git add --all user@vmware:~/mini2440/u-boot-1.1.6$ git commit -m &quot;conf: add the gitignore rule&quot; 1.4 备份源码到 github 方便下次使用在 github 上创建一个空的仓库，我创建的仓库地址为：git@github.com:mini2440/100ask.u-boot-1.1.6.git查看目前本地仓库的状态，确认到并没有绑定远程仓库 user@vmware:~/mini2440/u-boot-1.1.6$ git remote -v 为本地仓库添加远程仓库 user@vmware:~/mini2440/u-boot-1.1.6$ git remote add origin git@github.com:mini2440/100ask.u-boot-1.1.6.git user@vmware:~/mini2440/u-boot-1.1.6$ git remote -v origin git@github.com:mini2440/100ask.u-boot-1.1.6.git (fetch) origin git@github.com:mini2440/100ask.u-boot-1.1.6.git (push) 将本地仓库上传到 github 远程仓库中 user@vmware:~/mini2440/u-boot-1.1.6$ git push origin -u master 1.5 使用 github 仓库快速获取源码直接克隆远程仓库配置编译即可注意：成功克隆工程后，您需要修改 Makefile 中交叉编译器路径为您的主机上编译器安装的实际路径。 user@vmware:~/mini2440$ git clone git@github.com:mini2440/100ask.u-boot-1.1.6.git user@vmware:~/mini2440$ cd 100ask.u-boot-1.1.6/ user@vmware:~/mini2440/100ask.u-boot-1.1.6$ make 100ask24x0_config user@vmware:~/mini2440/100ask.u-boot-1.1.6$ make user@vmware:~/mini2440/100ask.u-boot-1.1.6$ ls -l u-boot.bin -rwxrwxr-x 1 user user 198324 5月 20 13:15 u-boot.bin 二 配置编译 linux 内核2.1 获取 linux 内核源码并打补丁在上面 u-boot 中已经解压好了内核源码，这里直接创建仓库就好 user@vmware:~/mini2440$ cd linux-2.6.22.6/ user@vmware:~/mini2440/linux-2.6.22.6$ git init Initialized empty Git repository in /home/user/mini2440/linux-2.6.22.6/.git/ user@vmware:~/mini2440/linux-2.6.22.6$ git add --all user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;init: upload the linux-2.6.22.6 source code by 100ask.net&quot; 给 kernel 打补丁 user@vmware:~/mini2440/linux-2.6.22.6$ patch -p1 &lt; ../linux-2.6.22.6_jz2440.patch user@vmware:~/mini2440/linux-2.6.22.6$ git add --all user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;patch: linux-2.6.22.6_jz2440.patch&quot; 2.2 修改编译器修改顶层 Makefile 指定编译使用刚刚解压的交叉编译器，修改点如下： user@vmware:~/mini2440/linux-2.6.22.6$ vim Makefile user@vmware:~/mini2440/linux-2.6.22.6$ git diff diff --git a/Makefile b/Makefile index 9b456d0..e98b548 100644 --- a/Makefile +++ b/Makefile @@ -184,7 +184,7 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \ #ARCH ?= $(SUBARCH) ARCH ?= arm -CROSS_COMPILE ?= arm-linux- +CROSS_COMPILE ?= /home/user/mini2440/gcc-3.4.5-glibc-2.3.6/bin/arm-linux- # Architecture as present in compile.h UTS_MACHINE := $(ARCH) user@vmware:~/mini2440/linux-2.6.22.6$ git add --all user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;conf: modify the cross compiler&quot; 2.3 配置编译内核直接使用 100ask 提供的配置文件配置内核 user@vmware:~/mini2440/linux-2.6.22.6$ cp config_ok .config 执行 make 命令开始编译 user@vmware:~/mini2440/linux-2.6.22.6$ make uImage Makefile:1451: *** mixed implicit and normal rules: deprecated syntax /home/user/mini2440/linux-2.6.22.6/Makefile:418: *** mixed implicit and normal rules: deprecated syntax /home/user/mini2440/linux-2.6.22.6/Makefile:1451: *** mixed implicit and normal rules: deprecated syntax make[1]: *** No rule to make target &apos;silentoldconfig&apos;. Stop. CHK include/linux/version.h make: *** No rule to make target &apos;include/config/auto.conf&apos;, needed by &apos;include/asm-arm/.arch&apos;. Stop. 很遗憾，报错了，百度得到的结论是由于我的系统的 make 工具太新，新工具不兼容旧版规则，参考Maxwell的博客修改，修改点如下： user@vmware:~/mini2440/linux-2.6.22.6$ vim Makefile +416 user@vmware:~/mini2440/linux-2.6.22.6$ git diff diff --git a/Makefile b/Makefile index d6806d0..a52ab44 100644 --- a/Makefile +++ b/Makefile @@ -415,7 +415,7 @@ ifeq ($(config-targets),1) include $(srctree)/arch/$(ARCH)/Makefile export KBUILD_DEFCONFIG -config %config: scripts_basic outputmakefile FORCE +%config: scripts_basic outputmakefile FORCE $(Q)mkdir -p include/linux include/config $(Q)$(MAKE) $(build)=scripts/kconfig $@ @@ -1448,7 +1448,7 @@ endif $(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@) # Modules -/ %/: prepare scripts FORCE +%/: prepare scripts FORCE $(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \ $(build)=$(build-dir) %.ko: prepare scripts FORCE user@vmware:~/mini2440/linux-2.6.22.6$ git add Makefile user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;conf: fix new make tool can&apos;t compatible the old kernel&quot; 修改好后重新 make 试试 user@vmware:~/mini2440/linux-2.6.22.6$ make uImage ... ... LD arch/arm/boot/compressed/vmlinux OBJCOPY arch/arm/boot/zImage Kernel: arch/arm/boot/zImage is ready UIMAGE arch/arm/boot/uImage &quot;mkimage&quot; command not found - U-Boot images will not be built Image arch/arm/boot/uImage is read 很遗憾 uImage 还是没有成功编译出来，提示说需要 mkimage 工具，安装 mkimage 后试试 user@vmware:~/mini2440/linux-2.6.22.6$ sudo apt-get install u-boot-tools user@vmware:~/mini2440/linux-2.6.22.6$ make uImage ... ... Image Name: Linux-2.6.22.6 Created: Tue May 1 19:39:40 2018 Image Type: ARM Linux Kernel Image (uncompressed) Data Size: 1812732 Bytes = 1770.25 kB = 1.73 MB Load Address: 30008000 Entry Point: 30008000 Image arch/arm/boot/uImage is ready user@vmware:~/mini2440/linux-2.6.22.6$ ls -l arch/arm/boot/uImage -rw-rw-r-- 1 user user 1845932 5月 20 20:59 arch/arm/boot/uImage 2.4 修改 lcd 驱动由于我使用的是 mini2440 开发板，配套的 LCD 是 X35，使用 100ask 提供的 lcd 驱动无法直接点亮，因此需要修改 lcd 驱动文件。参考comwise的博客将 X35 屏幕的驱动移植到 kenrel 中，可以点亮 LCD。注意：博客提供的 LCD 驱动，直接移植好后编译会报错，需要屏蔽其中三行报错的头文件。我将修改好的 LCD 驱动和网卡驱动放了一份在 git@github.com:mini2440/100ask.lcd.and.net.driver.git 仓库中，可以克隆这个仓库获取，获取仓库的命令如下 user@vmware:~/mini2440$ git clone git@github.com:mini2440/100ask.lcd.and.net.driver.git 拷贝 LCD 驱动到内核中 user@vmware:~/mini2440$ cp -av 100ask.lcd.and.net.driver/drivers/video/mini2440_lcd_x35.c linux-2.6.22.6/drivers/video/ &apos;100ask.lcd.and.net.driver/drivers/video/mini2440_lcd_x35.c&apos; -&gt; &apos;linux-2.6.22.6/drivers/video/mini2440_lcd_x35.c&apos; 修改驱动目录下的 Makefile 使驱动被编译到 user@vmware:~/mini2440/linux-2.6.22.6$ vim drivers/video/Makefile user@vmware:~/mini2440/linux-2.6.22.6$ git diff diff --git a/drivers/video/Makefile b/drivers/video/Makefile old mode 100644 new mode 100755 index bd8b052..6f40cae --- a/drivers/video/Makefile +++ b/drivers/video/Makefile @@ -106,7 +106,11 @@ obj-$(CONFIG_FB_MAXINE) += maxinefb.o obj-$(CONFIG_FB_TX3912) += tx3912fb.o obj-$(CONFIG_FB_S1D13XXX) += s1d13xxxfb.o obj-$(CONFIG_FB_IMX) += imxfb.o -obj-$(CONFIG_FB_S3C2410) += s3c2410fb.o + +# mz8023yt@163.com 20180520 begin &gt;&gt;&gt; [2/2] realize the mini2440 x35 lcd driver +obj-$(CONFIG_FB_S3C2410) += mini2440_lcd_x35.o +# mz8023yt@163.com 20180520 end &lt;&lt;&lt; [2/2] realize the mini2440 x35 lcd driver + obj-$(CONFIG_FB_PNX4008_DUM) += pnx4008/ obj-$(CONFIG_FB_PNX4008_DUM_RGB) += pnx4008/ obj-$(CONFIG_FB_IBM_GXT4500) += gxt4500.o user@vmware:~/mini2440/linux-2.6.22.6$ git add --all user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;feature: realize the mini2440 x35 lcd driver&quot; 重新 make user@vmware:~/mini2440/linux-2.6.22.6$ make uImage 2.5 修改网卡驱动同理，修改网卡也是一样的，拷贝网卡驱动到内核中 user@vmware:~/mini2440$ cp -av 100ask.lcd.and.net.driver/drivers/net/mini2440_dm9000.c linux-2.6.22.6/drivers/net/ &apos;100ask.lcd.and.net.driver/drivers/net/mini2440_dm9000.c&apos; -&gt; &apos;linux-2.6.22.6/drivers/net/mini2440_dm9000.c&apos; 修改驱动目录下的 Makefile 使驱动被编译到 user@vmware:~/mini2440/linux-2.6.22.6$ git diff diff --git a/drivers/net/Makefile b/drivers/net/Makefile old mode 100644 new mode 100755 index e819674..0e714ce --- a/drivers/net/Makefile +++ b/drivers/net/Makefile @@ -194,7 +194,11 @@ obj-$(CONFIG_S2IO) += s2io.o obj-$(CONFIG_MYRI10GE) += myri10ge/ obj-$(CONFIG_SMC91X) += smc91x.o obj-$(CONFIG_SMC911X) += smc911x.o -obj-$(CONFIG_DM9000) += dm9dev9000c.o + +# mz8023yt@163.com 20180520 begin &gt;&gt;&gt; [2/2] realize the dm9000 net driver +obj-$(CONFIG_DM9000) += mini2440_dm9000.o +# mz8023yt@163.com 20180520 end &lt;&lt;&lt; [2/2] realize the dm9000 net driver + #obj-$(CONFIG_DM9000) += dm9000.o #obj-$(CONFIG_DM9000) += dm9ks.o obj-$(CONFIG_FEC_8XX) += fec_8xx/ user@vmware:~/mini2440/linux-2.6.22.6$ git add --all user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;feature: realize the mini2440 x35 lcd driver&quot; 重新 make user@vmware:~/mini2440/linux-2.6.22.6$ make uImage 2.6 提交忽略规则文件修改 .gitignore 文件，在 .* 后追加 !.gitignore，不忽略 .gitignore 文件，这样才可以将忽略规则一并提交到 github 仓库中。 user@vmware:~/mini2440$ vim .gitignore user@vmware:~/mini2440$ git diff diff --git a/.gitignore b/.gitignore index a8b11d5..56b2db9 100644 --- a/.gitignore +++ b/.gitignore @@ -7,8 +7,10 @@ # .* + +# don&apos;t ignore the .gitignore file +!.gitignore + *.o *.a @@ -26,6 +28,12 @@ tags TAGS vmlinux* + +# don&apos;t ignore the vmlinux.lds.* file +!vmlinux.lds.* + System.map Module.symvers user@vmware:~/mini2440/linux-2.6.22.6$ git add --all user@vmware:~/mini2440/linux-2.6.22.6$ git commit -m &quot;conf: add the git ignore files&quot; 备注：这里为什么要取消忽略 !vmlinux.lds.*，是因为我之前使用 kernel 默认的忽略规则，将版本库上传到 github 上，再下载下来 make 的时候，编译不过，发现找不到一些依赖文件，我才意识到可能是我的忽略规则存在问题，某些必须的文件的被忽略掉了，导致这些必要的文件没有提交到版本库中。因此用解压打完 patch 未编译的源码和 github 上 clone 下来的源码做对比，发现少了下面这几个文件： arch/alpha/kernel/vmlinux.lds.S arch/arm/boot/compressed/vmlinux.lds.in arch/arm/kernel/vmlinux.lds.S include/asm-generic/vmlinux.lds.h 因此确认到是 vmlinux* 忽略规则将这些文件忽略掉了，故添加 !vmlinux.lds.* 规则不忽略上述文件，保证版本可以编译通过。 2.7 备份源码到 github 方便下次使用在 github 上创建一个空的仓库，我创建的仓库地址为：git@github.com:mini2440/100ask.linux-2.6.22.6.git查看目前本地仓库的状态，确认到并没有绑定远程仓库 user@vmware:~/mini2440/linux-2.6.22.6$ git remote -v 为本地仓库添加远程仓库 user@vmware:~/mini2440/linux-2.6.22.6$ git remote add origin git@github.com:mini2440/100ask.linux-2.6.22.6.git user@vmware:~/mini2440/linux-2.6.22.6$ git remote -v origin git@github.com:mini2440/100ask.linux-2.6.22.6.git (fetch) origin git@github.com:mini2440/100ask.linux-2.6.22.6.git (push) 将本地仓库上传到 github 远程仓库中 user@vmware:~/mini2440/linux-2.6.22.6$ git push origin -u master 2.8 使用 github 仓库快速获取源码user@vmware:~/mini2440$ git clone git@github.com:mini2440/100ask.linux-2.6.22.6.git user@vmware:~/mini2440$ cd 100ask.linux-2.6.22.6/ user@vmware:~/mini2440/100ask.linux-2.6.22.6$ cp config_ok .config user@vmware:~/mini2440/100ask.linux-2.6.22.6$ make uImage 三 重烧整个系统3.1 下载 u-boot 到 nandflash 上将 u-boot.bin 拷贝到 windows 目录下，这里我拷贝到 D:\work\ 目录下，使用 oflash 工具下载到 nandflash 中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Microsoft Windows [版本 6.1.7600]版权所有 (c) 2009 Microsoft Corporation。保留所有权利。C:\Users\Administrator&gt;d:D:\&gt;cd workD:\work&gt;oflash 0 1 0 0 0 u-boot.bin+---------------------------------------------------------+| Flash Programmer v1.5.2 for OpenJTAG of www.100ask.net || OpenJTAG is a USB to JTAG &amp; RS232 tool based FT2232 || This programmer supports both of S3C24X0 &amp; S3C6410 || Author: Email/MSN(thisway.diy@163.com), QQ(17653039) |+---------------------------------------------------------+Usage:1. oflash, run with cfg.txt or prompt2. oflash [file], write [file] to flash with prompt3. oflash [-f config_file]4. oflash [jtag_type] [cpu_type] [flash_type] [read_or_write] [offset] [file]Select the JTAG type:0. OpenJTAG1. Dongle JTAG(parallel port)2. Wiggler JTAG(parallel port)Enter the number: 0Select the CPU:0. S3C24101. S3C24402. S3C6410Enter the number: 1device: 4 &quot;2232C&quot;deviceID: 0x14575118SerialNumber: FThecwJmADescription: USB&lt;=&gt;JTAG&amp;RS232 AS3C2440 detected, cpuID = 0x0032409d[Main Menu] 0:Nand Flash prog 1:Nor Flash prog 2:Memory Rd/Wr 3:ExitSelect the function to test:0[NAND Flash JTAG Programmer]Scan nand flash:Device 0: NAND 256MiB 3,3V 8-bit, sector size 128 KiBTotal size: 256 MiB 0:Nand Flash Program 1:Nand Flash Print BlkPage 2:ExitSelect the function to test :0[NAND Flash Writing Program]Source size: 0x306b4Available target block number: 0~2047Input target block number:0target start block number =0target size (0x20000*2) =0x40000STATUS:EppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppEppppppppppppppppppppppppppppppppp 3.2 使用 nandflash 启动开发板成功下载 u-boot.bin 到 nandflash 后，将启动选项设置为 nand 启动，上电有以下 log 输出说明 u-boot 成功运行 1234567891011121314151617181920212223242526272829303132333435363738U-Boot 1.1.6-g48373b63 (May 17 2018 - 22:46:07)DRAM: 64 MBFlash: 0 kBNAND: 256 MiBIn: serialOut: serialErr: serialUPLLVal [M:38h,P:2h,S:2h]MPLLVal [M:5ch,P:1h,S:1h]CLKDIVN:5h+---------------------------------------------+| S3C2440A USB Downloader ver R0.03 2004 Jan |+---------------------------------------------+USB: IN_ENDPOINT:1 OUT_ENDPOINT:3FORMAT: &lt;ADDR(DATA):4&gt;+&lt;SIZE(n+10):4&gt;+&lt;DATA:n&gt;+&lt;CS:2&gt;NOTE: Power off/on or press the reset button for 1 sec in order to get a valid USB device address.Hit any key to stop autoboot: 0##### 100ask Bootloader for OpenJTAG #####[n] Download u-boot to Nand Flash[k] Download Linux kernel uImage[j] Download root_jffs2 image[y] Download root_yaffs image[d] Download to SDRAM &amp; Run[z] Download zImage into RAM[g] Boot linux from RAM[f] Format the Nand Flash[s] Set the boot parameters[b] Boot the system[r] Reboot u-boot[q] Quit from menuEnter your selection: qOpenJTAG&gt; 3.3 下载 kernel 到 nandflash 上u-boot 成功烧写后，便可以使用 u-boot 的 tftp 命令可以下载文件到 SDRAM 中。 使用 tftp 命令下载的前提是： 开发板和 Windows 主机通过网线接在同一个路由器上 Windows 主机上启动了 TPTP 服务 配置好 Windows 主机的 ip，这里我的 Windows 主机的 ip 配置为 192.168.1.5。Windows 主机行运行 tftp 服务器软件，服务器 ip 默认就是 Windows 主机 ip。同时将要通过通过 tftp 下载到开发板的文件拷贝到 tftpd32.exe 服务器软件同级目录下。这里我拷贝了内核文件 uImage 和文件系统 fs_qtopia.yaffs2 到 tftp 目录下。 依次执行以下步骤将 kernel 烧写到 nandflash 中： 配置好开发板的 ip 以及 tftp 服务器 ip上电后，按下空格进入 U-Boot，执行下面的命令设置环境变量中开发板的 ip 为 192.168.1.8，指定 tftp 服务器的 ip 为 192.168.1.5。 OpenJTAG&gt; setenv ipaddr 192.168.1.100 OpenJTAG&gt; setenv serverip 192.168.1.5 OpenJTAG&gt; save OpenJTAG&gt; reset 使用小米路由器的话请使用下面的命令进行配置，需要多配置网关 ip 这一项： OpenJTAG&gt; setenv ipaddr 192.168.31.230 OpenJTAG&gt; setenv serverip 192.168.31.43 OpenJTAG&gt; setenv gatewayip 192.168.31.1 OpenJTAG&gt; save OpenJTAG&gt; reset 重启 U-Boot 之后使用 tftp 命令将 tftp 服务器中的文件下载到 SDRAM 0x30000000 地址处 OpenJTAG&gt; tftp 30000000 uImage 擦除 kernel 分区后再烧写到 nandflash 中所谓的 kernel 分区其实只是 nandfalsh 中 0x00060000 - 0x00260000 这段地址空间 OpenJTAG&gt; nand erase kernel 接下来要烧写到 nandflash 中，下面两条命令效果一致，二选一即可 OpenJTAG&gt; nand write.jffs2 30000000 kernel OpenJTAG&gt; nand write.jffs2 30000000 60000 200000 这条命令的意思是：将 SDRAM 中 0x30000000 地址开始连续 0x200000 个字节写入 nandflash 0x60000 地址中去 3.4 下载文件系统到 nandflash 上同样的方式，执行下列命令可以将文件系统烧写到 nandflash 中 OpenJTAG&gt; tftp 30000000 fs_qtopia.yaffs2 OpenJTAG&gt; nand erase root 烧写到 nandflash 中，下面三条命令效果一致，三选一即可 OpenJTAG&gt; nand write.yaffs 30000000 root OpenJTAG&gt; nand write.yaffs 30000000 260000 $(filesize) OpenJTAG&gt; nand write.yaffs 30000000 260000 2f76b40 上面烧写命令的含义其实就是，将 SDRAM 中 0x30000000 地址开始连续 0x2f76b40(49769280) 个字节写入 nandflash 0x260000 地址中去。不难发现其实 2f76b40 这个值就是 fs_qtopia.yaffs2 文件的大小。]]></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>mini2440</tag>
        <tag>100ask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 新增 PhoneInfoTest 命令]]></title>
    <url>%2F2018%2F04%2F28%2Fodm-add-PhoneInfoTest-cmd%2F</url>
    <content type="text"><![CDATA[问题来源客户新增 90PN 料号文件的读写需求，需要实现两个部分： 工厂产线生产时写入料号信息(已实现)。 售后网点售后时写入料号信息。 背景知识客户售后网点使用 PhoneInfoTest 应用程序读写手机信息，目前 PhoneInfoTest 支持的命令如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465## 整机 SSN eg. D8OKCT101847adb shell /data/data/PhoneInfoTest 0 1 [SSN]adb shell /data/data/PhoneInfoTest 0 0## IMEI eg. 358463051106605 358463051106613adb shell /data/data/PhoneInfoTest 1 1 [IMEI1]adb shell /data/data/PhoneInfoTest 1 2 [IMEI2]adb shell /data/data/PhoneInfoTest 1 0 [IMEI1]adb shell getprop persist.radio.device.imeiadb shell getprop persist.radio.device.imei2## BT eg. 5CFF356DB1D9adb shell /data/data/PhoneInfoTest 2 1 [BT Mac]adb shell /data/data/PhoneInfoTest 2 0adb shell getprop ro.btmac## WiFi eg. 5CFF358DB1D9adb shell /data/data/PhoneInfoTest 3 1 [Wifi Mac]adb shell /data/data/PhoneInfoTest 3 0adb shell getprop ro.wifimac## 主板 ISN eg. E234C671106011adb shell /data/data/PhoneInfoTest 4 1 [ISN]adb shell /data/data/PhoneInfoTest 4 0adb shell getprop ro.isn## Country Code eg. CN、WWadb shell /data/data/PhoneInfoTest 6 1 [Country Code]adb shell /data/data/PhoneInfoTest 6 0adb shell getprop ro.config.versatility## Color ID eg. 1Aadb shell /data/data/PhoneInfoTest 7 1 [Color ID Code]adb shell /data/data/PhoneInfoTest 7 0adb shell getprop ro.config.idcode## Customer ID eg. XIAOMIadb shell /data/data/PhoneInfoTest 8 1 [Customer ID Code]adb shell /data/data/PhoneInfoTest 8 0adb shell getprop ro.config.CID## Packing Code eg. WWadb shell /data/data/PhoneInfoTest 9 1 [Packing Code]adb shell /data/data/PhoneInfoTest 9 0adb shell getprop ro.config.revenuecountry## MEID eg. 99000841001456adb shell /data/data/PhoneInfoTest 11 1 [MEID]adb shell /data/data/PhoneInfoTest 11 0adb shell getprop persist.radio.device.meid## SIMCODEadb shell /data/data/PhoneInfoTest 12 1 [SIMCODE]adb shell /data/data/PhoneInfoTest 12 0## Model eg. ASUS_X00GDadb shell getprop ro.product.model## Device eg. ASUS_X00GD_1adb shell getprop ro.product.device## Image Version eg. CSC_ZC521TL_14.00.1701.10_CN_20170104adb shell getprop ro.build.version.incrementaladb shell getprop ro.build.csc.versionadb shell getprop ro.build.display.id 备注：PhoneInfoTest 程序通过将 argv[1] 和 argv[2] 组合起来的 argv[1]*10 + argv[2] 的值，去查表，找到真正的命令，再去执行命令对应的 case 分支，从而实现不同命令做不同的操作的需求，具体请分析代码。 功能实现新增 PhoneInfoTest 13 指令实现读写 90PN 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113diff --git a/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.cpp b/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.cppindex 83328a2..5fd87d6 100755--- a/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.cpp+++ b/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.cpp@@ -355,6 +355,9 @@ void diag_deinit() #define PROINFO_BUFFER_PATH_BACKUP &quot;/dev/block/bootdevice/by-name/proinfo&quot; +// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [1/7] add write 90PN interface+#define FACTORY_90PN_PATH &quot;/factory/90PN&quot;+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [1/7] add write 90PN interface int proinfo_read(unsigned char *buffer, int len) &#123;@@ -433,7 +436,12 @@ int main(int argc, char** argv) struct AP_Product_Info *p_AP_Product_Info; struct AP_Product_Info *p_AP_Product_backup_Info;+// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [2/7] add write 90PN interface+ unsigned char pn_buf[1024];+ int pn_fd = 0;+ int pn_ret = -1;+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [2/7] add write 90PN interface unsigned char imei[9] = &#123;0x08,0x0A&#125;; int i = 0;@@ -685,9 +693,41 @@ int main(int argc, char** argv) diag_deinit(); &#125; break;+// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [3/7] add write 90PN interface+ case WRITE_90PN:+ pn_fd = open(FACTORY_90PN_PATH, O_RDWR | O_SYNC | O_CREAT, 0660);+ if (pn_fd &lt; 0) &#123;+ printf(&quot;can&apos;t open file! error = %d\n&quot;, pn_fd);+ return -1;+ &#125;+ memset(&amp;pn_buf, 0, sizeof(pn_buf));+ memcpy(&amp;pn_buf, argv[3], strlen(argv[3]));+ pn_ret = write(pn_fd, pn_buf, 1024);+ fsync(pn_fd);+ if(pn_ret == strlen(1024)) &#123;+ printf(&quot;0: succeed\n&quot;);+ &#125; else &#123;+ printf(&quot;1: failure\n&quot;);+ &#125;+ close(pn_fd);+ break;++ case READ_90PN:+ pn_fd = open(FACTORY_90PN_PATH, O_RDWR | O_SYNC | O_CREAT, 0660);+ if (pn_fd &lt; 0) &#123;+ printf(&quot;can&apos;t open file! error = %d\n&quot;, pn_fd);+ return -1;+ &#125;+ memset(&amp;pn_buf, 0, sizeof(pn_buf));+ read(pn_fd, pn_buf, 1024);+ close(pn_fd);+ printf(&quot;%s\n&quot;, pn_buf);+ break;+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [3/7] add write 90PN interface default: printf(&quot;cmd %d don&apos;t support\n&quot;, cmd); break; &#125;diff --git a/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.h b/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.hindex 1abe502..d5f5c48 100755--- a/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.h+++ b/custom_files/vendor/qcom/proprietary/&lt;Project&gt;/diag/PhoneInfoTest/PhoneInfoTest.h@@ -52,6 +52,11 @@ typedef enum &#123; WRITE_CUSTOMID, WRITE_PACKINGCODE, WRITE_SIMCODE,+// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [4/7] add write 90PN interface+ WRITE_90PN,+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [4/7] add write 90PN interface WRITE_END, READ_SSN , READ_MEID, @@ -65,6 +70,11 @@ typedef enum &#123; READ_CUSTOMID, READ_PACKINGCODE, READ_SIMCODE,+// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [5/7] add write 90PN interface+ READ_90PN,+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [5/7] add write 90PN interface READ_END, AT_CMD, @@ -123,6 +133,11 @@ static unsigned int adbcmd_code[40][2]=&#123; WRITE_CUSTOMID,81, WRITE_PACKINGCODE,91, WRITE_SIMCODE,121,+// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [6/7] add write 90PN interface+ WRITE_90PN, 131,+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [6/7] add write 90PN interface READ_SSN ,00, READ_MEID,110, READ_IMEI1,10,@@ -134,6 +149,11 @@ static unsigned int adbcmd_code[40][2]=&#123; READ_CUSTOMID,80, READ_PACKINGCODE,90, READ_SIMCODE,120,+// mz8023yt@163.com 20180424 begin &gt;&gt;&gt; [7/7] add write 90PN interface+ READ_90PN, 130,+// mz8023yt@163.com 20180424 end &lt;&lt;&lt; [7/7] add write 90PN interface AT_CMD,880, CUSTOM_CMD, 770, ADB_CMD_END,990 编译验证单编模块，编译更快，编译完成之后，push 到手机中执行看效果，最后将 90PN 文件 push 出来，确认是否真的有写到。 1234567891011121314151617181920## 配置 Android 工程[wangbing@ubuntu: ~/src] source build/envsetup.h[wangbing@ubuntu: ~/src] lunch &lt;Project&gt;## 单编[wangbing@ubuntu: ~/src]$ rm -rf out/target/product/&lt;Project&gt;/vendor/bin/PhoneInfoTest ~/[wangbing@ubuntu: ~/src]$ mmm vendor/qcom/proprietary/diag/PhoneInfoTest/## 导入手机[wangbing@ubuntu: ~/src]$ cp out/target/product/&lt;Project&gt;/vendor/bin/PhoneInfoTest ~/[wangbing@ubuntu: ~/src]$ adb push ~/PhoneInfoTest /vendor/bin## 验证[wangbing@ubuntu: ~/src]$ adb shell /data/data/PhoneInfoTest 13 1 90AZ01K1-S000500: succeed[wangbing@ubuntu: ~/src]$ adb shell /data/data/PhoneInfoTest 13 090AZ01K1-S00050## 导出到桌面，使用文本工具查看对应16进制字符再次确认C:\Users\wangbing&gt;adb pull /factory/90PN Desktop 产线工具前面有提到工厂产线生产时写入料号信息已经实现，这里也简单概述下，产线写 90PN 的相关实现逻辑。产线流水线有一个专门的写号站位，会将手机的很多信息统一写到手机的 NVRAM 中。这很多的信息中自然也包括 90PN 信息。而产线的工具实际上是调用高通开放的 API 接口实现和手机通信的，这个 API 接口其实就是 QXDM 工具中发送 cmd 是同样的东西。因此在验证阶段，我们用 QXDM 发送对应的 cmd 就可以实现产线工具同样的写 90PN 的效果。 写入 90PN 对应的 QXDM 指令是：Send_data 0x4b 0xc9 0xcc 0xff 12 &lt;data&gt;，其中 data 有格式要求，data 的格式是，”一次发一个字符的 ASCII 码的十进制数，用空格隔开”。 倘若我们要往 90PN 中写入 Hello 字符，我们应该这么干： 查一下 ASCII 码表，看看 Hello 中的 5 个字符的十进制格式的 ASCII 码是多少？查了下，分别是：72 101 108 108 111 接下里使用 QXDM 发送 Send_data 0x4b 0xc9 0xcc 0xff 12 72 101 108 108 111。 使用 adb shell /data/data/PhoneInfoTest 13 0 查看是否写入成功。 ASCII 码表百度百科 ASCII 码表]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>qcom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hexo] 精通 Markdown]]></title>
    <url>%2F2018%2F04%2F22%2Fhexo-Mastering-Markdown%2F</url>
    <content type="text"><![CDATA[原文链接: https://guides.github.com/features/mastering-markdown/ 百度搜索 Markdown GitHub，即可搜索到 Mastering Markdown · GitHub Guides 页面，找到原文。 前言Markdown 可以写一些轻量级格式的文档，并且它使用纯文本的方式就可以描述出来。使用纯文本的方式相对于复杂的 word 文档就带来一个非常大的优势，那就是可以很方便的使用版本控制工具去管理。本文不会详细的去介绍 Markdown 的详细语法，详细的语法，上面有给出 GitHub 的使用手册，这里仅仅介绍一些常用的语法。 超链接使用 [链接文字描述](超链接) 的方式可以很容易的添加超链接： [link to Google](http://google.com) link to Google 图片使用 ![图片描述](图片链接) 的方式可以很容易的添加图片，这个图片也可以是 gif 动态图： eg. ![adb input command demo](https://raw.githubusercontent.com/mz8023yt/blog.material/master/odm/gif/odm-tp-input-cmd.gif) 内嵌代码块在句子中使用 `&lt;code block&gt;` 在句子中嵌入代码块： eg. 使用 `printk` 在 kernel 中打印调试信息。 使用 printk 在 kernel 中打印调试信息。 引用在句首使用 &gt; 引用其他人的句子，句子前会有一个竖线 eg. &gt; 不经过自己充分思考就去问别人问题，是一种不礼貌的行为，尤其是向这个行业的各位专家们请教问题！ 不经过自己充分思考就去问别人问题，是一种不礼貌的行为，尤其是向这个行业的各位专家们请教问题！ 删除线使用 ~~ 或者 &lt;del&gt; 标记实现删除线效果。 eg. ~~我是被删除的~~ eg. &lt;del&gt;我也是被删除的&lt;del&gt; 我是被删除的我也是被删除的]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hexo] 升级 next 版本到 6.2.0]]></title>
    <url>%2F2018%2F04%2F22%2Fhexo-update-the-hexo-and-next%2F</url>
    <content type="text"><![CDATA[下载最新版本的 nexthttps://github.com/theme-next/hexo-theme-next/releases 修改语言为中文12345678910111213diff --git a/_config.yml b/_config.ymlindex 8a1abf3..cbd41d3 100644--- a/_config.yml+++ b/_config.yml@@ -7,7 +7,7 @@ title: Paul&apos;s blog subtitle: &quot;学而不思则罔 思而不学则殆&quot; description: &quot;但行好事 莫问前程&quot; author: Paul Wang-language: zh-Hans+language: zh-CN timezone: # URL 设置首页文章预览12345678910111213diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 5007812..9492813 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -254,7 +254,7 @@ excerpt_description: true # Automatically Excerpt. Not recommend. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt:- enable: false+ enable: true length: 150 # Post meta display settings 修改主题风格为 Mist1234567891011121314diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 9492813..e231be5 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -136,8 +136,8 @@ menu_settings: # --------------------------------------------------------------- # Schemes-scheme: Muse-#scheme: Mist+#scheme: Muse+scheme: Mist #scheme: Pisces #scheme: Gemini 添加标题栏页面123456789101112131415161718diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex e231be5..5bf65c3 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -118,10 +118,10 @@ index_with_subtitle: false # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded. menu: home: / || home- #about: /about/ || user- #tags: /tags/ || tags- #categories: /categories/ || th archives: /archives/ || archive+ categories: /categories/ || th+ tags: /tags/ || tags+ about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 取消侧栏目录自动编号12345678910111213diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 5bf65c3..74974d3 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -199,7 +199,7 @@ toc: enable: true # Automatically add list number to toc.- number: true+ number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 修改网站图标123456789101112131415161718diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 74974d3..2e315a7 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -45,10 +45,10 @@ cache: # For example, you put your favicons into `hexo-site/source/images` directory. # Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo. favicon:- small: /images/favicon-16x16-next.png- medium: /images/favicon-32x32-next.png- apple_touch_icon: /images/apple-touch-icon-next.png- safari_pinned_tab: /images/logo.svg+ small: /maziot/maziot-16x16.png+ medium: /maziot/maziot-32x32.png+ apple_touch_icon: /maziot/maziot-apple.png+ safari_pinned_tab: /maziot/maziot.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 修改博客头像12345678910111213diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 2e315a7..caa9ecc 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -192,7 +192,7 @@ links_layout: block # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif-#avatar: /images/avatar.gif+avatar: /maziot/avatar.jpg # Table Of Contents in the Sidebar toc: 添加侧栏社交链接123456789101112131415161718diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex caa9ecc..9a922b0 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -154,7 +154,12 @@ site_state: true # Key is the link label showing to end users. # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.-#social:+# 图标可以在 http://fontawesome.dashgame.com/ 网站上找+social:+ E-Mail: mailto:mz8023yt@163.com || envelope+ GitHub: https://github.com/mz8023yt || github+ Jianshu: https://www.jianshu.com/u/30fc01f695b9 || book+ Geeker: http://www.androidgeeker.com/ || android #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google 添加侧栏友情链接1234567891011121314151617181920diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 9a922b0..b325026 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -191,8 +191,13 @@ links_icon: link links_title: Links links_layout: block #links_layout: inline-#links:- #Title: http://example.com/+links:+ icon: http://fontawesome.dashgame.com/+ kernel: https://www.kernel.org/+ mipi: https://mipi.org/+ git: https://git-scm.com/+ hexo: https://hexo.io/+ next: http://theme-next.iissnan.com/ # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif 修改友情链接布局123456789101112131415diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex b325026..55a78f9 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -189,8 +189,8 @@ social_icons: # Blog rolls links_icon: link links_title: Links-links_layout: block-#links_layout: inline+#links_layout: block+links_layout: inline links: icon: http://fontawesome.dashgame.com/ kernel: https://www.kernel.org/ 添加字数统计https://github.com/theme-next/hexo-symbols-count-time npm install hexo-symbols-count-time --save 123456789101112131415161718diff --git a/_config.yml b/_config.ymlindex cbd41d3..025ef2d 100644--- a/_config.yml+++ b/_config.yml@@ -10,6 +10,13 @@ author: Paul Wang language: zh-CN timezone:+# Word Count+symbols_count_time:+ symbols: true+ time: true+ total_symbols: true+ total_time: true+ # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://yoursite.com 添加文章打赏1234567891011121314151617diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 1748ad2..a5c5d51 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -293,9 +293,9 @@ codeblock: #description: ex. subscribe to my blog by scanning my public wechat account # Reward-#reward_comment: Donate comment here-#wechatpay: /images/wechatpay.jpg-#alipay: /images/alipay.jpg+reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！+wechatpay: /maziot/weixin.png+alipay: /maziot/alipay.png #bitcoin: /images/bitcoin.png # Related popular posts 添加评论系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 4b0a05f..c751ba3 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -521,18 +521,29 @@ valine: # Gitment # Introduction: https://imsun.net/posts/gitment-introduction/ gitment:- enable: false- mint: true # RECOMMEND, A mint on Gitment, to support count, language and pro xy_gateway- count: true # Show comments count in post meta area- lazy: false # Comments lazy loading with a button- cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more- language: # Force language, or auto switch by theme- github_user: # MUST HAVE, Your Github Username- github_repo: # MUST HAVE, The name of the repo you use to store Gitment comme nts- client_id: # MUST HAVE, Github client id for the Gitment- client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment- proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/inter sect- redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol wh en mint enabled+ enable: true+ # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway+ mint: true+ # Show comments count in post meta area+ count: true+ # Comments lazy loading with a button+ lazy: false+ # Hide &apos;Powered by ...&apos; on footer, and more+ cleanly: true+ # Force language, or auto switch by theme+ language::- cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more- language: # Force language, or auto switch by theme- github_user: # MUST HAVE, Your Github Username- github_repo: # MUST HAVE, The name of the repo you use to store Gitment comments- client_id: # MUST HAVE, Github client id for the Gitment- client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment- proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect- redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled+ enable: true+ # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway+ mint: true+ # Show comments count in post meta area+ count: true+ # Comments lazy loading with a button+ lazy: false+ # Hide &apos;Powered by ...&apos; on footer, and more+ cleanly: true+ # Force language, or auto switch by theme+ language:+ # MUST HAVE, Your Github Username+ github_user: mz8023yt+ # MUST HAVE, The name of the repo you use to store Gitment comments+ github_repo: blog.comments+ # MUST HAVE, Github client id for the Gitment+ client_id: 3b0f546a740181c255a9+ # EITHER this or proxy_gateway, Github access secret token for the Gitment+ client_secret: 41b269fc8cc71a77e91b3485769b325e249b15dd+ # Address of api proxy, See: https://github.com/aimingoo/intersect+ proxy_gateway:+ # Protocol of redirect_uri with force_redirect_protocol when mint enabled+ redirect_protocol: # Baidu Share # Available value: 添加站内搜索123456789101112131415161718diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 55a78f9..4b0a05f 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -713,12 +713,12 @@ algolia_search: # Local search # Dependencies: https://github.com/theme-next/hexo-generator-searchdb local_search:- enable: false+ enable: ture # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1- top_n_per_article: 1+ top_n_per_article: 3 # unescape html strings to the readable one unescape: false 123456789101112131415161718diff --git a/_config.yml b/_config.ymlindex 025ef2d..b863a15 100644--- a/_config.yml+++ b/_config.yml@@ -10,6 +10,13 @@ author: Paul Wang language: zh-CN timezone:+# Search+search:+ path: search.xml+ field: post+ format: html+ limit: 10000+ # Word Count symbols_count_time: symbols: true 添加在线歌单hexo new page music 12345678910111213141516171819202122232425262728293031323334353637383940414243diff --git a/source/music/index.md b/source/music/index.mdnew file mode 100644index 0000000..07bf7ce--- /dev/null+++ b/source/music/index.md@@ -0,0 +1,13 @@+---+title: &apos;[Maziot] 网易云歌单&apos;+date: 2018-04-22 18:52:56+---++&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.7/dist/APlayer.min.css&quot;&gt;+&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.7/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;+&lt;div class=&quot;aplayer&quot;+ data-id=&quot;821903731&quot;+ data-server=&quot;netease&quot;+ data-type=&quot;playlist&quot;&gt;+&lt;/div&gt;+&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.1/dist/Meting.min.js&quot;&gt;&lt;/script&gt;diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex c751ba3..e44e5ec 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -122,6 +122,7 @@ menu: categories: /categories/ || th tags: /tags/ || tags about: /about/ || user+ music: /music/ || music #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeatdiff --git a/themes/next/languages/zh-CN.yml b/themes/next/languages/zh-CN.ymlindex 8b73150..db73de1 100644--- a/themes/next/languages/zh-CN.yml+++ b/themes/next/languages/zh-CN.yml@@ -14,6 +14,7 @@ menu: search: 搜索 schedule: 日程表 sitemap: 站点地图+ music: 音乐 commonweal: 公益 404 sidebar: overview: 站点概览]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Essays] 论工业社会及其未来]]></title>
    <url>%2F2018%2F04%2F21%2Fessays-Kassinski-s-warning%2F</url>
    <content type="text"><![CDATA[原文链接: http://www.ruanyifeng.com/blog/2017/09/unabomber.html 原标题: 卡辛斯基的警告 作者：阮一峰 11978年5月25日，美国西北大学的工程教授巴克利·克利斯（Buckley Crist），收到了邮政局退回的一个包裹。 这个包裹寄往芝加哥大学，但是收件人”查无此人”。克利斯教授不记得寄过它，可是发件人却写着自己的名字。他叫来了学校的保安。保安打开了包裹，里面是一颗炸弹，立刻爆炸了。保安身受重伤。 此后的18年，这样的案件一再发生。凶手一共寄出了16枚邮件炸弹，共炸死3人，炸伤23人。袭击对象主要是大学的理工科教授，所以凶手被称为”大学炸弹客”（Unabomber）。 FBI 想尽办法要抓住凶手。十几年的调查中，动用了500名特工，误抓了200多名嫌疑犯，查访上万民众，接了2万多通检举电话，花费500万美元，但是一无所获。凶手非常小心，没有留下任何线索。这个案件成了 FBI 历史上最昂贵的调查之一。 21995年4月，凶手又一次作案，一次性寄出了四样东西：两个邮件炸弹，炸死了加州林业协会的总裁吉卜特·莫里，炸断了耶鲁大学计算机科学教授大卫·加勒特的几根手指；一封警告信，警告1993年诺贝尔奖获得者遗传学家理查·罗伯特和菲利普·夏普，要求他们立刻停止基因研究；一篇发给《纽约时报》的长达3.5万字的文章，承诺如果美国主流媒体一字不改地全文刊登，他就将永久停止炸弹袭击。 FBI 局长和美国司法部长最终同意刊登这篇文章。1995年9月19日，它发表在当天的《纽约时报》和《华盛顿邮报》上，题目叫做《论工业社会及其未来》（Industrial Society and Its Future）。 读者惊讶地发现，这居然是一篇充满思辨的哲学论文，作者明显受过学术训练。论文声称，工业革命带来的是人类的灾难，技术使人类丧失自由，最终将导致社会的动荡甚至毁灭，人们应该摧毁现代工业体系。这就是凶手为什么袭击大学教授的原因，因为他们推动了技术的发展。 更让人吃惊的是，这篇论文很有说服力。许多人开始认真思考作者的观点，主流的知识分子杂志（比如《大西洋》、《纽约人》）专文讨论它。那位被炸断手指的耶鲁大学教授大卫·加勒特承认，文章的推断不无道理，工业文明时代，人类的未来，也许真的险恶重重。Java 语言的发明人计算机学家 Bill Joy 则说，他对文章预言的未来深感困扰。艺术家更是深受影响， 后来的许多小说和电影（比如《黑客帝国》），都能看到这篇论文的影子。 3论文发表以后，FBI 收到一条线索：有人举报，该文的写作风格和论点，很像出自他的弟弟泰德·卡辛斯基（Ted Kaczynski）之手。 1996年4月3日，卡辛斯基在蒙大拿州被逮捕，他住在远离人群的荒野之中，自己搭建了一个小木屋，里面堆满了炸弹原料。至此，邮包炸弹案宣告破案。 卡辛斯基的人生很不寻常。他生于1942年，从小就具有超人的数学天才， 16岁被哈佛大学数学系录取。 1962年进入密歇根大学攻读数学博士，只用了几个月就拿到了博士学位。指导教授说他的博士论文十分深奥，全美只有十几个人能看懂。25岁时，他被加州大学柏克莱分校聘为助理教授，是该校史上最年轻的教授。 卡辛斯基在柏克莱只待了不到2年，就辞职了，没有任何理由。他从此脱离学术界，过上了离群索居的生活，1971年，在父母的资助下，他在蒙大拿州一个偏僻的山区盖了一间小木屋，搬到那里去住了。屋子里没有电灯、电话、自来水。平日里他吃自己种的菜、猎捕的食物，晚上点蜡烛看书，砍柴做饭取暖。1978年，他在那里寄出了第一个邮件炸弹，攻击目标是在图书馆里面随机选择的。 被捕后，卡辛斯基拒绝了律师为其辩护。1998年，被判处终身监禁，不得保释。 4《论工业社会及其未来》这篇论文值得细细阅读，它对人类现状和未来的分析描述，是非常震撼的。 关于人类的现状，作者的第一句话就是：”工业文明带给人类的是极大的灾难。” “工业文明极大地增加了发达国家的人口预期寿命，但也破坏了社会的稳定性，令生活空虚无谓，剥夺了人类的尊严，导致了心理疾病的扩散，还严重地破坏了自然界。” 新技术的最大问题，就是剥夺人类的自由。”自由与技术进步不相容，技术越进步，自由越后退。” “新技术改变社会，最后人们会发现，自己将被强制去使用它。比如，自从有了汽车，城市的布局发生了很大改变，大多数人的住宅已经不在工作场所、购物区和娱乐区的步行距离之内，他们不得不依赖汽车。人们不再拥有不使用新技术的自由了。” 一项新技术诞生后，不太可能被拒绝使用，因为”每一项新技术单独考虑都是可取的”，然后人类就会依赖它。 “电力、下水道、无线电话……一个人怎么能反对这些东西呢？怎么能反对数不清的技术进步呢？所有的新技术汇总到一起，就创造出了这样一个世界。在这个世界中，普通人的命运不再掌握在他自己手中，而是掌握在政客、公司主管、技术人员和官僚手中。以遗传工程为例。很少人会反对消灭某种遗传病的基因技术，但是大量的基因修改，会使人变成一种人工设计制造的产品，而不是自然的创造物。” 设想一下，如果基因技术变得成熟和普及，那么政府将不得不管制这种技术，因为万一被滥用，后果不堪设想。这样的话，个人就没有选择，只能接受政府管制，其程度将是前所未有，因为政府将可以管到你的基因结构。 工业社会要想正常运作，必须遵循一整套严格的规则，这导致”现代人都被一张规则之网所笼罩，在所有重要方面，个人的行为都必须服从这些规则。”这导致所有人在本质上都高度类似。 “今天，在技术发达地区，人们的生活方式十分相像。芝加哥的一个基督教银行职员，东京的一个佛教银行职员，莫斯科的一个共产党银行职员，他们彼此之间的日常生活十分相像，而他们的生活与1000年以前人们的生活却非常不同。这就是技术进步的结果……” 最终，”技术完全控制地球上的一切，人类自由基本上将不复存在，因为个人无法对抗用超级技术武装起来的大型组织。只有极少数人握有真正的权力，但甚至就连他们的自由也是十分有限的，因为他们的行为也是受到管制的。” 5关于人类的未来，卡辛斯基假设 “计算机科学家成功地开发出了智能机器，这些机器无论做什么事都比人类强。在这种情况下，大概所有工作都会由巨大的、高度组织化的机器系统去做，而不再需要任何人类的努力。” 这时可能会有两种情况发生。”一种是允许机器在没有人类监督的情况下，自已做出所有的决策，另一种是人类保留对于机器的控制。” “如果我们允许机器自己做出所有的决策，人类的命运那时就全凭机器发落了。人们也许会反驳，人类决不会愚蠢到把全部权力都交给机器。但我们既不是说人类会有意将权力交给机器，也不是说机器会存心夺权。我们实际上说的是，人类可能会轻易地让自己沦落到一个完全依赖机器的位置，沦落到不能做出任何实际选择，只能接受机器的所有决策的地步。随着社会及其面临的问题变得越来越复杂，而机器变得越来越聪明，人们会让机器替他们做更多的决策。仅仅是因为机器做出的决策会比人的决策带来更好的结果。最后，维持体系运行所必需的决策已变得如此之复杂。以至于人类已无能力明智地进行决策。在这一阶段，机器实质上已处于控制地位。人们已不能把机器关上，因为我们已如此地依赖于机器，关上它们就等于是自杀。” 就算人们想尽办法，保留对机器的控制权，结果也会很糟。 “另一方面，也可能人类还能保持对机器的控制。在这种情况下，一般人也许可以控制自己的私人机器，如他的汽车或计算机，但对于大型机器系统的控制权将落入一小群精英之手—-就像今天一样。由于技术的改进，精英对于大众的控制能力将会极大提高，因为人不再必需工作，大众就成为了多余的人，成为了体系的无用负担。如果精英集团失去了怜悯心，他们完全可以决定灭绝人类大众。如果他们有些人情味，他们也可以使用宣传或其他心理学或生物学技术降低出生率，直至人类大众自行消亡，让这个世界由精英们独占。” “或者，如果精英集团是由软心肠的自由派人士组成的，他们将注意保证每个人的生理需求都得到满足，每一个孩子都在心理十分健康的条件下被抚养成人，每一个人都有一项有益于健康的癖好来打发日子，每一个可能会变得不满的人都会接受治疗以治愈其’疾病’。当然，生活是如此没有目的，以致于人们都不得不经过生物学的或心理学的改造，以去除他们的权力欲，或使他们的权力欲’升华’为无害的癖好。这些经过改造的人们也许能在这样一个社会中生活得平和愉快，但他们决不会自由。他们将被贬低到家畜的地位。” 6退一步说，如果前面的假设不成立，人工智能没有取得成功，人的工作还是必要的，但是”即使这种情况，机器也将承担越来越多的简单工作，而低能力的工人将越来越过剩（正如我们所见，这种事已经发生了。许多人很难或根本找不到工作，因为他们由于智力或心理原因，而不能达到体系所需要的训练水平）。” “对于那些找到工作的人，就业的要求会越来越高。他们将需要越来越多的训练，越来越强的能力，他们将不得不越来越可靠、越来越规矩、越来越驯服，因为他们将越来越像巨型有机体的细胞。他们的任务将越来越专门化，因而他们的工作在某种意义上也将越来越脱离真实世界，仅集中于现实的一块小碎片。体系将使用一切可以使用的心理学或生物学手段来设计制造人类，使之驯顺，使之具有体系要求的能力。” 机器接管了大部分具有真正重要性的工作以后，留给人类的（或者说普通人有能力从事的）都是一些相对不那么重要的工作。 “例如有人建议，大力发展服务业可以给人类提供工作机会。这样人们就可以把时间花在互相擦皮鞋上面，可以用出租车带着彼此到处瞎转，互相为对方做手工艺品，互相给对方端盘子等等。人类如果最终以这样的方式结局，那对于我们来说也实在是太可怜了，而且我们怀疑有多少人会觉得这样的无意义的忙碌等同于充实的生活。他们会去寻找危险的其他渲泄途径（毒品、犯罪、邪教、仇恨群体等），除非他们经过生物学或心理学的设计改造后适应了这种生活方式。” 7卡辛斯基的结论就是，未来要么人类无法幸存下来，要么个人空前地依赖大型组织，空前地”社会化”，人类的生理和心理是设计和改造的结果，而不是自然的产物。 唯一的解决方法就是放弃科学技术，”把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。” “我们希望已经说服了读者，体系无法通过改革来调和自由与技术。唯一的出路是摒弃整个工业-技术休系。这意味着革命，不一定是武装起义，但肯定是激烈而根本的社会性质变化。” 卡辛斯基认为，这个体系是由技术人员为了自己的利益和声望在推动前进。”体系需要科学家、数学家与工程师，否则就无法正常运作。”因此他选择这些人作为袭击目标。这样做当然是邪恶的，但是他对于人类命运的警告却理应受到重视。 卡辛斯基反复提及，引入新技术一定要慎而又慎。 “一项新技术被引入社会时，将会引发一长串其他变化，这些变化之中的大部分是不可预见的。历史经验告诉我们，技术进步给社会带来新问题的速度，远比它解决旧问题的速度要快。技术已将人类带入了一条无法轻易逃脱的死胡同。” 技术会有我们难以预测的长期后果。比如，抗生素的目的是消灭细菌，但是大量使用后却产生了难以杀死的超级细菌，人们不得不限制抗生素的使用；再比如，医疗技术提高了人类的寿命，但也因此导致了地球的人口激增、社会老龄化、生育率下降等重大的社会变化，这些恐怕都不是技术的发明者能想到的。如果新技术（比如机器人技术、基因工程、纳米技术）被恐怖主义组织掌握，后果就更可怕。如果不是真人，而是机器人在街头发动恐怖袭击，那会是怎样的情景？ 距离《论工业社会及其未来》的发表，已经过去了20多年，互联网和人工智能都变成了现实，基因技术开始萌芽。人类对于新技术的入迷简直到了无以复加的地步，恨不得越多越好，一项新技术还在实验室中，人们就开始计划如何尽快形成生产力，占领尽可能多的市场。卡辛斯基的预言似乎一步步正在变成现实，人类正毫不在意地亲手加速自己的毁灭。（正文完） 原文摘录《论工业社会及其未来》 工业革命极大增加了城市规模和城市人口比例，而人群聚集会增加压力与攻击性。 技术变革导致现代社会的变化十分迅速，因此整个社会不存在稳定的框架和价值观。 有些人急于拯救自由却不愿牺牲技术带来的所谓好处，他们会提出天真的新式社会构想来调和自由与技术。 所有人都理所当然地认为，每一个人都必需向技术的需要低头，而且理由十分充分：如果人的需求被摆在了优先于技术需要的地位，就会出现经济问题、失业、短缺甚至更糟。在我们的社会当中，”精神健康”的概念主要被定义为在多大程度一个人能够根据体系的需要行事并且不会流露出承受精神压力的迹象。 经济体系所能容纳的企业数是有限的，我们大多数人只有成为别人的雇员才可以生存。 工业-技术体系可能幸存也可能崩溃。假如该体系幸存下来，可能最终将会降低生理与心理的痛苦水平，但在此之前必须经历一段漫长而痛苦的调整期，而且人类与众多其他生命体也将付出惨重代价，永远沦为社会机器上的齿轮。更有甚者，假如这个体系幸存下来，将会导致不可避免的后果：没有任何方法能够改革或改进这一体系，使之不至于剥夺人的尊严与自主。 假如这一体系崩溃，结果依旧会十分痛苦。但是体系规模越大，崩溃造成的结果就越可怕。因此假如真要崩溃的话最好赶早不赶迟。 所以我们主张发动针对工业体系的革命。这场革命可能使用或不使用暴力，可能突然完成也可能在几十年时间里相对循序渐进地进行。我们无法预测这一点。但是我们的确为那些憎恨工业体系的人们勾勒了一套十分宽泛的方法，从而为反对这一特定社会形式的革命铺平道路。这不是一场政治革命。革命目标并非推翻政府，而是颠覆现存社会的经济与技术基础。 一般来说科学家都是这样。可能其中也有少数例外，但总体而言他们的动机既不是好奇也不是造福人类，而是完成权力过程的需要。其他动机对于许多科学家来说也有作用，例如金钱与地位。 科学技术也构成了群体权力运动，许多科学家都通过认同这一运动来满足自己的权力需求。 因此科学盲目地前进，不考虑人类种族的真正福祉或任何其他标准，仅仅服从科学家以及提供研究资金的政府官员与企业高管的心理需求。 体系需要科学家、数学家与工程师，否则就无法正常运作。 遗传工程的伦理规范事实上将成为管制人类遗传构造的手段。一部分人（多半是上层阶级）将决定如此这般的遗传工程合乎”道德”，如此这般的做法则不道德，因而他们将在实际上将自己的价值观强加于整个人口的遗传构造。即使伦理规范是以完全民主的方式选择出来的，多数族裔也会将他们自己的价值观强加于那些很可能对于如何 “道德地”运用遗传工程另有看法的少数族裔。真正能够保护自由的伦理规范只能是一挑，那就是禁止任何人类遗传工程。而我们可以十分有把握地说，这一点恰恰不可能在技术社会中得到实现。任何将遗传工程贬低成配角的规范都不可能维持下去，因为生物技术的巨大力量所产生的诱惑是无法抗拒的。特别是在大多数人看来，大量生物技术的应用显然且肯定是有益的（可以根除身体与精神疾病，赋予人们当今世界所需要的能力）。基因技术必将不可避免地得到大规模应用，但应用方式只能与工业-技术体系的需求相一致。 技术之所以是如此强有力的社会力量的另一个理由是，在给定社会的条件下技术进步只会不可逆地朝一个方向前进。只要某项技术发明被引进，人们就往往会对其产生依赖，除非它被某种更先进的发明所取代。人们不仅仅作为个人依赖这项新技术。甚至体系作为一个整体都会依赖它。（例如请想像一下，如果没有了计算机，今天的体系会怎么样）因此，体系只能朝向更加技术化的方向移动。在不至于颠覆整个技术体系的前提下，技术将会不断地逼迫自由后退。 技术的进步十分迅速并在许多方面威胁自由（拥挤、规章制度、个人对于大型组织越发严重的依赖、宣传与其他心理学技术、遗传工程、通过监视设备和计算机侵犯隐私，等等），阻挡任何一项对于自由的威胁都需要一场单独的社会斗争。那些想要保卫自由的人会被无数的新攻势及其发展速度所压倒，他们会变得微不足道并停止抵抗。分别反击这些威胁是无效的。只有把技术体系作为一个整体来反击才有成功的希望，但这就是革命而不是改革了。 人们倾向于想当然地认为，由于革命带来的变化比改革大，所以革命也就比改革更难发动。实际上，在某些条件下革命比改革容易得多。这是因为一场革命运动能够激发出人们极大的献身热情，而一场改革运动却不能。一场革命运动许诺一下子解决所有问题并创造整个新世界；它提供人民为之甘冒风险、甘作牺牲的理想。由于这些理由，推翻整个技术体系要比对技术的某一部分—-如遗传工程的应用发展—-进行有效、持久的限制容易得多。在适当的条件下，许许多多的人会热情地献身于推翻工业技术体系的革命。正如我们提到的那样，寻求限制技术的某些方面的改革者是为了避免不良后果而工作。然而，革命者是为了获得强力的报偿一一实现其革命理想—-而工作，因此他们比改革者更努力且更执著。 现代社会不是去改变那些使人们抑郁的条件，而是给人们抗抑郁药。 但另一方面，请假设今后几十年的压力超出了体系的承受能力。如果体系崩溃，可能会右一个混乱时期，”动乱年代”，就像在过去各个对代历史所记载的那样。不可能预见动乱年代最后会产生什么结果。但无论如何人类会被赋予一个新机会。最大的危险是工业化社会很可能在崩溃后不几年就开始重组其自身，肯定会有许多人（特别是权力饥渴型的人们）急于重新开动工厂。 工业体系将人类贬低到了被奴役的状态，而憎恨这种被奴役状态的人则面临两个任务。第一，我们必须增强体系内的社会紧张态势，以加快其崩溃或把它弱化到足够程度，使得反对体系的革命成为可能。第二，当体系充分弱化时，我们必须发展并宣传一种反对技术和工业社会的意识形态。当工业社会崩溃时，这种意识形态将有助于保证其残余被粉碎到无法修复的地步，这样体系就无法重组。工厂将被捣毁，技术书籍将被烧掉，等等。 工业体系的崩溃不会纯粹是革命行动的结果，它不会那么难以抵御革命的攻击，除非它自身内部的发展问题导致了极为严重的困难。因此如果体系崩溃，那么它或是自发崩溃，或是部分自发、部分由革命者促发的崩溃。如果崩溃是突如其来的，许多人都会死去，因为世界人口已如此过分膨胀，离开了先进技术就无法养活自己。甚至即使崩溃足够缓慢，人口的减少可以主要通过出生率的降低而不是死亡率的提高而实现，非工业化的过程也多半是极度混乱和极度痛苦的。幻想通过平稳控制的有序方式逐步废除技术是天真的，特别是要考虑到技术爱好者们的负隅顽抗。那么，致力于体系的崩溃是否因此就十分残酷呢？也许是，也许不是。首先，除非体系本来就已经陷入了深重的困难，无论如何都很可能最终自行崩溃，否者单靠革命者是不可能强行使其崩溃的。而且体系发展得规模越大，崩溃的后果就越严重。因此加速体系崩溃的革命者或许反倒控制了灾难的规模。 其次，我们必须权衡斗争与死亡和丧失自由与尊严这两方面的得失。对于我们之中的许多人来说，自由与尊严比长寿和避免肉体痛苦更重要。再者，我们早晚会死，死于为生存或为某一事业而战，强于活得空虚而无目的。 第三，体系的存续所带来的痛苦并不一定就比体系崩溃所带来的痛苦更少。在全世界范围内，体系已经招致、并且正在招致的巨大痛苦曾使人类千百年与他人以及环境和睦相处的古代文化被与其解接触的工业社会所摧毁。其结果就是全方位的经济、环境、社会和心理问题。工业杜会的侵扰所产生的影响之一，就是传统的人口控制在全球范围内一下子失去了平衡，因而产生了人口爆炸及其所有连带后果。接着就是心理疾病席卷了整个所谓”幸运”的西方社会。没有人知道臭氧层耗尽、温室效应及其他现在还不能预测的环境问题最终会为这个世界带来怎样的后果。而且就像核扩散已经显示的那样，我们无法防止新技术落入独裁者和不负责任的第三世界国家手中。愿意猜猜伊位克或北朝鲜将用遗传工程来干什么吗? “嗨！”技术爱好者们会说，”科学能解决所有这些问题！我们将征服饥荒、消灭心理病痛，让每一个人都健康而快乐！”是的，是的。他们200年前就是这么说的。人们曾指望工业社会能够消灭贫穷，使每一个人都快乐，等等。实际结果却不是那么回事。技术爱好者对社会问题的理解简直是无可救药地天真（或自欺欺人）。他们没有意识到（或故意视而不见）这样一个事实：当巨大的变化，即使是看上去有利的变化，被引入一个社会时，将会引发一长串其他变化，这些变化之中的大都分是不可预见的其结果则是社会的混乱。因此，技术爱好者们在试图消灭贫穷和疾病，设计制造驯顺、快乐的人格等等时，很可能会创造出比现在还糟糕的社会体系。例如，科学家们吹嘘说他们能够创造出新的、经遗传工程改造的粮食植物以消灭饥荒。然而，这将会允许人日无限膨胀下去，而众所周知，拥挤会导致紧张和攻击性的增强。这仅仅是技术会导致的可预见问题中的一个例子。我们强调指出，历史经验告诉我们，技术进步给社会带来新问题的速度远比它解决旧问题的速度要快。因此技术爱好者们要经过一个漫长的试错时期才能够为他们的美丽新世界排除掉所有的故障（假设他们最终能做到的话）。而与此同时所产生的痛苦将会如此巨大，以至于体系生存下去所带来的痛苦不见得就比体系崩溃更少。技术己将人类带入了一条无法轻易逃脱的死胡同。 更好的办法是把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。 现在的两个主要任务是在工业社会中促进社会紧张与不稳定，以及宣传一种反对技术和工业体系的意识形态。当体系变得足够紧张和不稳定时，一场反对技术的革命就有机会发动了。这一模式将十分类似于法国和俄国革命。在两国各自革命之前的几十年里，法国和俄国社会都显示出了越来越多的紧张与脆弱迹象。同时，提供一个与旧世界完全不同的新世界愿景的意识形态发展了起来。以俄国的情况为例，革命者积极从事于破坏旧秩序的工作。然后当旧体系面临着足够的额外紧张时（法国是财政危机，俄国是军事失败），它就会被革命一扫而光。我们预想的就是这样的道路。 大多数革命都有两个目标，一个目标是摧毁一个旧社会，另一个目标是建立革命者想像的新社会。法国和俄国的革命者没有能够成功地建立他们所梦想的新社会（这是十分幸运的事），但她们非常成功地摧毁了既存社会。 然而，一种意识形态如想争取到热情支持，除了负面理想外必须还有正面理想，决不能只破不立。我们的正面理想是自然，即野生自然，按照其本来面目运行的地球，不依赖于人类管理、摆脱人类干涉和控制的地球生灵。我们的野生自然也包括人类本性，即不受有组织社会管制、自主运行的个人，成为偶然性或自由意志或上帝（由你的宗教或哲学观念）的产物。 一个社会的经济与技术结构在决定一般人的生活方式方面远比政治结构更加重要。 我们不应主张无力或消极，我们应主张打破工业体系的权力，而这将大大增加个人和小群体的权力和自由。 （据称）贯穿整个历史，技术都是进步的，从未退步过，因此技术退步是不可能的。但这并非事实。对于”进步”的热情是现代社会形态的特殊现象，在大约十七世纪之前并不存在。]]></content>
      <categories>
        <category>Essays</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[ODM] TP 手势唤醒屏幕亮起来慢]]></title>
    <url>%2F2018%2F04%2F20%2Fodm-tp-gesture-warkup-screen-slow%2F</url>
    <content type="text"><![CDATA[问题描述客户测试人员报出 bug，使用 TP 手势唤醒手机，屏幕亮起来慢，而同平台的对比机不存在此问题。 解决思路由于整个屏幕唤醒的流程非常复杂，这里先将其简单划分为三块，(1)TP 识别手势上报手势键值 -&gt; (2)上层处理 TP 上报的手势键值 -&gt; (3)上层根据键值唤醒屏幕或者调起对应的 apk。不妨先做相关的对比试验看看具体慢是慢在哪一块？是 TP 识别手势耗时，还是上层处理手势值耗时，还是屏幕唤醒流程相比于对比机就是耗时？做实验对比 power key 唤醒和双击手势唤醒的时间，看看时间是否差不多。时间怎么看，需要找到亮屏瞬间对应的 log，手势上报键值瞬间对应的 log，以及 power key 按下瞬间对应的 log。使用这些 log 前面的间戳就可以计算出之间的耗时。那对应的 log 怎么找？可以这么干，使用 dmesg -w 或者 logcat -b kernel 实时打印 kernel log 出来，看看按 power key、熄屏双击以及亮屏瞬间都有哪些 log 打印，再从这些打印的 log 中去找当前动作对应的关键 log。最后发现亮屏瞬间 kernel 中没有 log，通过 kernel log 仅找到手势上报键值和按 power key 对应的 log。kernel 中没有亮屏对应 log 的话，那没有办法了，只能通过 logcat 抓取亮屏瞬间对应的 main log，最后找到的各个动作的对应关系为： 12345678910# power key[ 804.903664] [wind-tick][kpdpwr] start add timer[ 805.053863] [wind-tick][kpdpwr] start del timer# input keycode[ 225.105052] [Paul][TP][himax_wake_check_func][674] ret_event = 128 enable = 1[ 225.105060] [Paul][TP][himax_wake_check_func][692] gesture: double click# screen onPowerSaverService: mIsScreenOn = true 由于是性能问题，计算时间的话不能采用 eng 版本做实验，必须使用 user 版本。在 user 版本可以通过这条命令同时抓取 kernel log 和 main log。 12C:\Users\wangbing&gt;adb shellandroid$ logcat -b all | grep -E 'Paul|kpdpwr|mIsScreenOn' 对于手势和电源键分别抓取了 10 组数据，截取其中 3 组 log 如下： 12345678910111213141516171819## input keycode1-01 20:51:44.957 0 0 E [Paul][TP][himax_wake_check_func][692] gesture: double click1-01 20:51:45.676 2503 2503 D PowerSaverService: mIsScreenOn = true1-01 20:51:54.395 0 0 E [Paul][TP][himax_wake_check_func][692] gesture: double click1-01 20:51:55.124 2503 2503 D PowerSaverService: mIsScreenOn = true1-01 20:52:19.116 0 0 E [Paul][TP][himax_wake_check_func][692] gesture: double click1-01 20:52:19.848 2503 2503 D PowerSaverService: mIsScreenOn = true## power key01-01 20:44:12.082 0 0 W [wind-tick][kpdpwr] start add timer01-01 20:44:12.255 2503 2503 D PowerSaverService: mIsScreenOn = true01-01 20:44:16.933 0 0 W [wind-tick][kpdpwr] start add timer01-01 20:44:17.153 2503 2503 D PowerSaverService: mIsScreenOn = true01-01 20:44:21.748 0 0 W [wind-tick][kpdpwr] start add timer01-01 20:44:21.955 2503 2503 D PowerSaverService: mIsScreenOn = true 通过 10 组数据最后计算出来的平均值，发现手势唤醒需要 700ms 左右，而 power key 唤醒只需要 200ms 左右。说明: “(3)上层根据键值唤醒屏幕” 这块耗时在 200ms 左右，多出来 500ms 在 “(1)TP 识别手势上报手势键值 -&gt; (2)上层处理 TP 上报的手势键值” 这一段。然而对于手势唤醒 log 计算的时间 700ms 中并没有包含 “(1)TP 识别手势上报手势键值” 的时间，这个 700ms 是从手势上报键值的位置开始计算的，说明多出来的 500ms 仅仅是耗费在 “(2)上层处理 TP 上报的手势键值” 这块。 此问题，转给上层同事分析。 背景知识口袋模式是指在 TP 上报键值后，上层也接收到了，即将响应手势键值的时候，会去读取 psensor 的值，如果 psensor 的值过大，说明此时 psensor 是被遮挡的状态，则认为是在口袋中的 TP 误触行为，不去响应手势；否则正常响应。 分析结论最后定位问题耗时是在 TP 手势的口袋模式读取 psensor 数据的阶段。这里上层在读取 psensor 数据的时候，延时了 500ms 等待 psensor 数据稳定，导致手势唤醒慢。同步有做试验将这 500ms 延时去除，重新计算时间为 200ms 左右，唤醒时间正常，确认唤醒慢就是 500ms 延时导致。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>qcom</tag>
        <tag>touch</tag>
        <tag>gesture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 高通 LCD 框架分析]]></title>
    <url>%2F2018%2F04%2F11%2Fodm-lcm-frame%2F</url>
    <content type="text"><![CDATA[一. LCD 兼容1.1 lk 阶段启动流程概览lk 阶段框架不妨从 lk 阶段的 c 代码开始分析，第一个执行的 c 语言函数是 main.c 文件中的 kmain 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// file: src/bootable/bootloader/lk/kernel/main.cvoid kmain(void) // get us into some sort of thread context thread_init_early(); // early arch stuff arch_early_init()； // do any super early platform initialization platform_early_init(); board_init(); platform_clock_init(); qgic_init(); qtimer_init(); scm_init(); // do any super early target initialization target_early_init(); bs_set_timestamp(BS_BL_START); // deal with any static constructors call_constructors(); // bring up the kernel heap heap_init(); __stack_chk_guard_setup(); // initialize the threading system thread_init(); // initialize the dpc system dpc_init(); // initialize kernel timers timer_init(); // create a thread to complete system initialization thr = thread_create("bootstrap2", &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE); thread_resume(thr); // enable interrupts exit_critical_section(); // become the idle thread thread_become_idle();static int bootstrap2(void *arg) arch_init(); platform_init(); target_init(); target_keystatus(); target_sdc_init(); vib_timed_turn_on(VIBRATE_TIME); apps_init(); 简化一些与屏启动不相关的流程后的得到的函数调用关系为： 12345// file: src/bootable/bootloader/lk/kernel/main.cvoid kmain(void) |-- thread_create("bootstrap2", &amp;bootstrap2, NULL, 16, 8192); &lt;=&gt; static int bootstrap2(void *arg) |-- apps_init(); 这里可以看出，lk 在做完平台端必要的初始化后，会去启动所谓的 app，那么 app 是什么东西？如何定义？又在哪里被执行？将在下一小节中介绍。 1.2 lk 阶段 app 启动流程先看看 apps_init() 都干了些什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// file: src/bootable/bootloader/lk/app/app.c#include &lt;debug.h&gt;#include &lt;app.h&gt;#include &lt;kernel/thread.h&gt;extern const struct app_descriptor __apps_start;extern const struct app_descriptor __apps_end;static void start_app(const struct app_descriptor *app);/* one time setup */void apps_init(void)&#123; const struct app_descriptor *app; /* call all the init routines */ for (app = &amp;__apps_start; app != &amp;__apps_end; app++) &#123; if (app-&gt;init) app-&gt;init(app); &#125; /* start any that want to start on boot */ for (app = &amp;__apps_start; app != &amp;__apps_end; app++) &#123; if (app-&gt;entry &amp;&amp; (app-&gt;flags &amp; APP_FLAG_DONT_START_ON_BOOT) == 0) &#123; start_app(app); &#125; &#125;&#125;static int app_thread_entry(void *arg)&#123; const struct app_descriptor *app = (const struct app_descriptor *)arg; app-&gt;entry(app, NULL); return 0;&#125;static void start_app(const struct app_descriptor *app)&#123; thread_t *thr; printf("starting app %s\n", app-&gt;name); thr = thread_create(app-&gt;name, &amp;app_thread_entry, (void *)app, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE); if(!thr) &#123; return; &#125; thread_resume(thr);&#125; 从上面的代码可以看出，每一个 app 都使用 app_descriptor 描述，并具有一个 init 函数，一个 entry 函数和一个 flags 标识。在 apps_init() 中会去遍历一个 app 的列表，分别调用他们的 init 函数，对 app 进行初始化。初始化结束后，还会根据 flags 标识位决定是否调用 start_app(app) 函数创建一个线程运行 app 的 entry 函数。 那么问题来了，这里的 app 的列表是怎么来的？上面 app 是从 __apps_start 开始取出 app 元素，一直取到 __apps_end 才结束，那么 __apps_start 和 __apps_end 在哪里定义？代码中居然找不到，总有定义的地方吧，grep 搜一下，原来在链接脚本中。 12345[wangbing@ubuntu: lk]$ grep -rsn "__apps_start"arch/arm/trustzone-system-onesegment.ld:51: __apps_start = .;arch/arm/system-twosegment.ld:47: __apps_start = .;arch/arm/trustzone-test-system-onesegment.ld:52: __apps_start = .;arch/arm/system-onesegment.ld:47: __apps_start = .; 打开链接脚本看看，可以发现四个脚本描述 __apps_start 和 __apps_end 都一样，都是表示 .apps 端的起始结束地址。 12345678910111213.rodata : &#123; *(.rodata .rodata.* .gnu.linkonce.r.*) . = ALIGN(4); __commands_start = .; KEEP (*(.commands)) __commands_end = .; . = ALIGN(4); __apps_start = .; // 起始地址 KEEP (*(.apps)) __apps_end = .; // 结束地址 . = ALIGN(4); __rodata_end = . ;&#125; 看到这里疑问就解除了，app 列表是在从 .apps 段中取出来的。但是新的问题又来了，lk 驱动中是怎么将 app 对应的 app_descriptor 结构链接到 .apps 段中呢？那就好好看看 app.c 和 app.h 文件吧，其中 app.c 上面已经贴出来了，下面仅贴出 app.h 文件。 123456789101112131415161718192021222324252627// file: src/bootable/bootloader/lk/app/app.h#ifndef __APP_H#define __APP_H/* app support api */void apps_init(void); /* one time setup *//* app entry point */struct app_descriptor;typedef void (*app_init)(const struct app_descriptor *);typedef void (*app_entry)(const struct app_descriptor *, void *args);/* app startup flags */#define APP_FLAG_DONT_START_ON_BOOT 0x1/* each app needs to define one of these to define its startup conditions */struct app_descriptor &#123; const char *name; app_init init; app_entry entry; unsigned int flags;&#125;;#define APP_START(appname) struct app_descriptor _app_##appname __SECTION(".apps") = &#123; .name = #appname,#define APP_END &#125;;#endif 在 app.h 的最后几行提供了两个用于创建 app 的宏，分别是 APP_START 和 APP_END。搜索一下，看看别人是怎么用他们创建 app 的。 1234567---- APP_START Matches (7 in 7 files) ----aboot.c (bootloader\lk\app\aboot) line 5400 : APP_START(aboot)clock_tests.c (bootloader\lk\app\clocktests) line 119 : APP_START(clocktests)pci_tests.c (bootloader\lk\app\pcitests) line 247 : APP_START(pcitests)shell.c (bootloader\lk\app\shell) line 37 : APP_START(shell)string_tests.c (bootloader\lk\app\stringtests) line 283 : APP_START(stringtests)tests.c (bootloader\lk\app\tests) line 42 : APP_START(tests) 就以第一个 aboot.c 为例吧，看看它是怎么创建的。 12345// file: src/bootable/bootloader/lk/app/aboot/aboot.cAPP_START(aboot) .init = aboot_init,APP_END 将宏定义展开，没错，就是这里指定该结构存放在 .apps 段。 123struct app_descriptor _app_aboot __SECTION(".apps") = &#123; .name = aboot, .init = aboot_init,&#125;; 总结一下：通过 APP_START 和 APP_END 两个宏创建一个 app，这种方式创建的 app 会被链接到 .apps 段。在 lk 启动流程中，最后会遍历 .apps 段中所有的 app，分别执行其中的 init 和 entry 函数。这里就清楚了, app 对应的 app_descriptor 结构必须放在 apps 段中才可以被启动。 1.3 lk 阶段 lcd 兼容原理兼容原理概述先介绍下 lcd 的 id 寄存器：MIPI 组织规定各屏厂生产的 lcd ic 的 id 信息必须记录在 A1 寄存器(RDDDB: Read DDB start)中，A1 寄存器中除了第一个字节的供应商 id 是由 MIPI 组织分配的，其他字节供应商可以自定义，可以记录 ic id、ic version code 什么的。这个随便找一块 lcd 的 datasheet 看一下就明白了。 再简单介绍下 lcd 的兼容原理：原理其实很简单，其实就是代码中已经包含有多块 lcd 驱动程序，在开机过程中，会去读出实际接在手机上的 lcd 模组的 id，将读出的 id 和各个屏驱动中的 id 做对比，如果某一个 lcd 驱动的 id 和读出的 id 一样，则驱动匹配成功，就使用这个匹配上的驱动程序操作 lcd。 基于上面原理性的介绍，我们也就大概明确了稍后分析 lcd 兼容这部分代码需要理清的主线逻辑了，这里列举一下： 在哪里读取手机上实际接的 lcd 的 id？ 在哪里遍历所有的 lcd 驱动，并和实际读取的 id 做比对？ 兼容框架分析接下就是分析代码了，上一小节分析到 lk 阶段最后是启动各个 app，简单看了各个 app 的流程，最后发现 lk 的探测兼容部分是在 aboot 中实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// file: src/bootable/bootloader/lk/app/aboot/aboot.cAPP_START(aboot) .init = aboot_init,APP_ENDvoid aboot_init(const struct app_descriptor *app) |- target_display_init(device.display_panel); | |- do &#123; | | // (1) 依次遍历代码中的兼容的 lcd 驱动做初始化操作 | |- memcpy(oem.panel, (panel_name_my + panel_loop), 64); | |- gcdb_display_init(oem.panel, MDP_REV_50, (void *)MIPI_FB_ADDR); | | |- panel_name = oem.panel; | | |- oem_panel_select(panel_name, &amp;panelstruct, &amp;(panel.panel_info), &amp;dsi_video_mode_phy_db); | | | | | | | | // (2) 根据 panel_name 解析 supp_panels 数组，得到 panel 的编号 | | | |- panel_override_id = panel_name_to_id(supp_panels, ARRAY_SIZE(supp_panels), panel_name); | | | |- panel_id = panel_override_id; | | | |- init_panel_data(panelstruct, pinfo, phy_db); | | | | | | | | // (3) 根据解析出来 panel 编号，绑定对应的 lcd 驱动函数 | | | |- switch (panel_id) &#123; | | | | case ST7703_HSD_PANEL: | | | | ... ... | | | | case ST7703_BOE_PANEL: | | | | ... ... | | | | case HX83102B_HSD_PANEL: | | | | ... ... | | | | pinfo-&gt;mipi.panel_compare_id_read_cmds = HX83102_compare_id_page_command; | | | | pinfo-&gt;mipi.panel_compare_id_page_cmds = HX83102_compare_id_read_command; | | | | pinfo-&gt;mipi.compare_id = HX83102_COMPARE_ID; | | | | pinfo-&gt;mipi.signature = HX83102_SIGNATURE; | | | | ... ... | | | | break; | | | |- &#125; | | | | | |- msm_display_init(&amp;panel); | | |- msm_display_config(); | | |- mdss_dsi_config(panel); | | |- mdss_dsi_panel_initialize(mipi, mipi-&gt;broadcast); | | |- mdss_dsi_read_panel_signature(mipi); | | | | | | // (4) 使用绑定的 lcd 驱动函数读取手机实际接的 lcd 的 id | | |- chip_id = oem_panel_compare_chip_id(mipi); | | | |- mdss_dsi_cmds_tx(mipi, mipi-&gt;panel_compare_id_page_cmds, 1, 0); | | | |- mdss_dsi_cmds_tx(mipi, mipi-&gt;panel_compare_id_read_cmds, 1, 0); | | | |- mdss_dsi_cmds_rx(mipi, &amp;lp, 1, 1); | | | |- return (ntohl(*lp) &gt;&gt; 16) &amp; 0xFF; | | | | | | // (5) 将读取到的 id 和当前的驱动对应的 id 做比对，匹配返回 0，不匹配返回 1 | | |- if(chip_id == mipi-&gt;compare_id) | | | return 1; | | |- else | | return 0; | | | | // (1) 如果 id 匹配成功(ret = 0)或者所有屏驱动都遍历了，但没有一块屏匹配，则跳出循环，不再遍历 | |- if (!ret || ret == ERR_NOT_SUPPORTED) | break; | | // (1) 如果没有走到上面 break 的位置，则接着遍历下一个兼容的 lcd 驱动 |- &#125; while (++panel_loop &lt;= oem_panel_max_auto_detect_panels()); 上面贴出来的框图仅仅是将 lcd 兼容函数调用关系贴出来了，一些地方描述不是很详细，下面介绍一下上图中做有标号的地方。 标号1. 依次遍历代码中的兼容的 lcd 驱动做初始化操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// file: src/bootable/bootloader/lk/target/msm8952/target_display.c// 这里记录了目前代码中兼容的 lcd 的 panel name，看数组的第二维大小，得出每个 panel name 占用 64 字节的大小static char panel_name_my[5][64] = &#123; &#123;"st7703_hsd_55_720p_video"&#125;, &#123;"st7703_boe_55_720p_video"&#125;, &#123;"hx83102b_hsd_55_720p_video"&#125;, &#123;"ili9881p_panda_55_720p_video"&#125;, &#123;"ili9881c_hsd_55_720p_video"&#125;,&#125;;void target_display_init(const char *panel_name) &#123; ... ... do &#123; target_force_cont_splash_disable(false); // 每个 panel name 占用 64 字节的大小，这里依次取出数组中的 panel name memcpy(oem.panel, (panel_name_my + panel_loop), 64); // 将当前取出的 panel name 记录在 oem.panel 中，传递下去 ret = gcdb_display_init(oem.panel, MDP_REV_50, (void *)MIPI_FB_ADDR); // 如果 id 匹配成功(ret = 0)或者所有屏驱动都遍历了，但没有一块屏匹配，则跳出循环，不再遍历 if (!ret || ret == ERR_NOT_SUPPORTED) &#123; break; &#125; else &#123; target_force_cont_splash_disable(true); msm_display_off(); &#125; // 如果没有走到上面 break 的位置，则接着遍历下一个兼容的 lcd 驱动 // 循环的次数为代码中兼容的屏的个数 &#125; while (++panel_loop &lt;= oem_panel_max_auto_detect_panels()); ... ...&#125;// file: src/bootable/bootloader/lk/target/msm8952/oem_panel.c// 代码中兼容的屏的个数#define DISPLAY_MAX_PANEL_DETECTION 5uint32_t oem_panel_max_auto_detect_panels()&#123; // 原本是这段代码，需要根据 target_panel_auto_detect_enabled 函数判断当前处理器平台是否开启了兼容功能 // return target_panel_auto_detect_enabled() ? DISPLAY_MAX_PANEL_DETECTION : 0; // 现在是直接修改为使能兼容状态，返回兼容的屏的个数 return DISPLAY_MAX_PANEL_DETECTION;&#125; 标号2. 根据 panel_name 解析 supp_panels 数组，得到 panel 的编号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// file: src/bootable/bootloader/lk/dev/gcdb/display/panel_display.hstruct panel_list &#123; char name[MAX_PANEL_ID_LEN]; uint32_t id;&#125;;// file: src/bootable/bootloader/lk/target/msm8952/oem_panel.cenum &#123; ST7703_HSD_PANEL, ST7703_BOE_PANEL, HX83102B_HSD_PANEL, ILI9881P_PANDA_PANEL, ILI9881C_HSD_PANEL, UNKNOWN_PANEL&#125;;/* * The list of panels that are supported on this target. * Any panel in this list can be selected using fastboot oem command. */static struct panel_list supp_panels[] = &#123; &#123;"st7703_hsd_55_720p_video", ST7703_HSD_PANEL&#125;, &#123;"st7703_boe_55_720p_video", ST7703_BOE_PANEL&#125;, &#123;"hx83102b_hsd_55_720p_video", HX83102B_HSD_PANEL&#125;, &#123;"ili9881p_panda_55_720p_video", ILI9881P_PANDA_PANEL&#125;, &#123;"ili9881c_hsd_55_720p_video", ILI9881C_HSD_PANEL&#125;,&#125;;// file: src/bootable/bootloader/lk/dev/gcdb/display/panel_display.cint32_t panel_name_to_id(struct panel_list supp_panels[], uint32_t supp_panels_size, const char *panel_name)&#123; uint32_t i; int32_t panel_id = ERR_NOT_FOUND; if (!panel_name) &#123; dprintf(CRITICAL, "Invalid panel name\n"); return panel_id; &#125; // 根据 panel_name 解析 supp_panels 数组，得到 panel 的编号 for (i = 0; i &lt; supp_panels_size; i++) &#123; if (!strncmp(panel_name, supp_panels[i].name, MAX_PANEL_ID_LEN)) &#123; panel_id = supp_panels[i].id; break; &#125; &#125; return panel_id;&#125; 标号3. 根据解析出来 panel 编号，绑定对应的 lcd 驱动函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// file: src/bootable/bootloader/lk/target/msm8952/oem_panel.c// 需要包含屏供应商提供头文件#include "include/panel_st7703_co55swr8_video.h"#include "include/panel_st7703_boe55_video.h"#include "include/panel_hx83102b_hsd_video.h"#include "include/panel_ili9881p_panda5_video.h"#include "include/dsi_panel_ili9881c_hsd_huashi_video.h"static int init_panel_data(struct panel_struct *panelstruct, struct msm_panel_info *pinfo, struct mdss_dsi_phy_ctrl *phy_db)&#123; int pan_type = PANEL_TYPE_DSI; struct oem_panel_data *oem_data = mdss_dsi_get_oem_data_ptr(); switch (panel_id) &#123; case ST7703_HSD_PANEL: ... ... case ST7703_BOE_PANEL: ... ... // 等号右边的变量都来自 panel_hx83102b_hsd_video.h 头文件中 case HX83102B_HSD_PANEL: panelstruct-&gt;paneldata = &amp;HX83102_B_720p_hsd_video_panel_data; panelstruct-&gt;paneldata-&gt;panel_with_enable_gpio = 1; panelstruct-&gt;panelres = &amp;HX83102_B_720p_hsd_video_panel_res; panelstruct-&gt;color = &amp;HX83102_B_720p_hsd_video_color; panelstruct-&gt;videopanel = &amp;HX83102_B_720p_hsd_video_video_panel; panelstruct-&gt;commandpanel = &amp;HX83102_B_720p_hsd_video_command_panel; panelstruct-&gt;state = &amp;HX83102_B_720p_hsd_video_state; panelstruct-&gt;laneconfig = &amp;HX83102_B_720p_hsd_video_lane_config; // 读取屏 chip id 的 mipi cmd pinfo-&gt;mipi.panel_compare_id_read_cmds = HX83102_B_720p_video_compare_id_page_command; pinfo-&gt;mipi.panel_compare_id_page_cmds = HX83102_B_720p_video_compare_id_read_command; // 屏驱动文件中记录的屏 chip id pinfo-&gt;mipi.compare_id = HX83102_B_720P_VIDEO_COMPARE_ID; panelstruct-&gt;paneltiminginfo = &amp;HX83102_B_720p_hsd_video_timing_info; panelstruct-&gt;panelresetseq = &amp;HX83102_B_720p_hsd_video_reset_seq; panelstruct-&gt;backlightinfo = &amp;HX83102_B_720p_hsd_video_backlight; pinfo-&gt;mipi.panel_on_cmds = HX83102_B_720p_hsd_video_on_command; pinfo-&gt;mipi.num_of_panel_on_cmds = HX83102_B_720P_HSD_VIDEO_ON_COMMAND; pinfo-&gt;mipi.panel_off_cmds = HX83102_B_720p_hsd_video_off_command; pinfo-&gt;mipi.num_of_panel_off_cmds = HX83102_B_720P_HSD_VIDEO_OFF_COMMAND; memcpy(phy_db-&gt;timing, HX83102_B_720p_hsd_video_timings, TIMING_SIZE); pinfo-&gt;mipi.signature = HX83102_B_720P_HSD_VIDEO_SIGNATURE; break; ... ... case UNKNOWN_PANEL: default: memset(panelstruct, 0, sizeof(struct panel_struct)); memset(pinfo-&gt;mipi.panel_on_cmds, 0, sizeof(struct mipi_dsi_cmd)); pinfo-&gt;mipi.num_of_panel_on_cmds = 0; memset(pinfo-&gt;mipi.panel_off_cmds, 0, sizeof(struct mipi_dsi_cmd)); pinfo-&gt;mipi.num_of_panel_off_cmds = 0; memset(phy_db-&gt;timing, 0, TIMING_SIZE); pan_type = PANEL_TYPE_UNKNOWN; break; &#125; return pan_type;&#125; 标号4标号5. 探测位置标号4和标号5的位置比较简单，不涉及其他没有贴出来的变量或函数，就不再去详细介绍。 1.4 kernel 阶段 lcd 兼容原理兼容原理概述kernel 阶段的兼容相比 lk 阶段要简单的多，由于在 lk 阶段已经做过了遍历所有屏驱动探测 lcd 的动作，再加上 bootloader 可以通过 cmdline 传参机制传递信息到 kernel 中。这样的话，完全可以通过 cmdline 将 lk 阶段的探测到的屏名称直接传递到 kernel，kernel 拿到传递过来的 panel name 再去加载对应的屏驱动。 兼容框架分析lk 阶段将屏信息写入 cmdline。 123456789101112131415161718192021222324252627282930313233// file: src/bootable/bootloader/lk/app/aboot/aboot.cchar display_panel_buf[MAX_PANEL_BUF_SIZE];void aboot_init(const struct app_descriptor *app) |-- memset(display_panel_buf, '\0', MAX_PANEL_BUF_SIZE); |-- boot_linux_from_mmc(); |-- boot_linux(hdr-&gt;kernel_addr, hdr-&gt;tags_addr, hdr-&gt;cmdline, board_machtype(), hdr-&gt;ramdisk_addr, hdr-&gt;ramdisk_size); |-- cmdline = hdr-&gt;cmdline; |-- final_cmdline = update_cmdline(cmdline); | |-- target_display_panel_node(display_panel_buf, MAX_PANEL_BUF_SIZE); | |-- pbuf = display_panel_buf | | |-- gcdb_display_cmdline_arg(pbuf, buf_size); | | | | | | // 将屏供应商提供的头文件中的 panel config 保存到 pbuf 中 | | |-- panel_node = panelstruct.paneldata-&gt;panel_node_id; | | |-- strlcpy(pbuf, panel_node, buf_size); | | | | // 设置拷贝的目的地址为 cmdline_final(cmdline) | |-- dst = cmdline_final; | | | | // 设置拷贝的源地址为 display_panel_buf(panel config) | |-- src = display_panel_buf; | |-- if (have_cmdline) | | --dst; | | | | // 将 panel config 追加到 cmdline | |-- while ((*dst++ = *src++)); | |--return cmdline_final; | |-- update_device_tree((void *)tags, (const char *)final_cmdline, ramdisk, ramdisk_size); |-- fdt_appendprop_string(fdt, offset, (const char*)"bootargs", (const void*)cmdline); ... ... 待补充 kernel 阶段解析 cmdline 获取到 lk 传递过来的屏信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// file: src/kernel/msm-3.18/drivers/video/msm/mdss/mdss_dsi.cmodule_init(mdss_dsi_ctrl_driver_init);static int __init mdss_dsi_ctrl_driver_init(void) mdss_dsi_ctrl_register_driver(); platform_driver_register(&amp;mdss_dsi_ctrl_driver);static struct platform_driver mdss_dsi_ctrl_driver = &#123; .probe = mdss_dsi_ctrl_probe, .remove = mdss_dsi_ctrl_remove, .shutdown = NULL, .driver = &#123; .name = "mdss_dsi_ctrl", .of_match_table = mdss_dsi_ctrl_dt_match, &#125;,&#125;;// 匹配的 dts 节点在这里指定 "qcom,mdss-dsi-ctrl"static const struct of_device_id mdss_dsi_ctrl_dt_match[] = &#123; &#123;.compatible = "qcom,mdss-dsi-ctrl"&#125;, &#123;&#125;&#125;;static int mdss_dsi_ctrl_probe(struct platform_device *pdev) | |-- struct device_node *dsi_pan_node = mdss_dsi_config_panel(pdev, index); | | // 取出私有数据 |-- struct mdss_dsi_ctrl_pdata *ctrl_pdata = platform_get_drvdata(pdev); |-- char panel_cfg[MDSS_MAX_PANEL_LEN]; | | // 通过私有数据中的函数接口获取到屏的配置信息 |-- mdss_dsi_get_panel_cfg(panel_cfg, ctrl_pdata); | |-- ctrl = ctrl_pdata; | | | | // 这里通过 panel_intf_type 函数获取到屏的配置信息 | | // 这里获取到的字符串是 0:qcom,dsi_co55swr8_st7703_720p_video:1:none:cfg:single_dsi | |-- pan_cfg = ctrl-&gt;mdss_util-&gt;panel_intf_type(MDSS_PANEL_INTF_DSI); | |-- strlcpy(panel_cfg, pan_cfg-&gt;arg_cfg, sizeof(pan_cfg-&gt;arg_cfg)); | | // 通过 panel_cfg 找到对应屏的 dts 节点, panel_cfg 字符串就是从 cmd line 中解析出来的 |-- struct device_node *dsi_pan_node = mdss_dsi_find_panel_of_node(pdev, panel_cfg); | | // 拿到了对应的 dts 节点就可以去初始化 panel 了 |-- mdss_dsi_panel_init(dsi_pan_node, ctrl_pdata, ndx); | | | | // 将 panel nane 取出，写到 device info 中 | |-- panel_name = of_get_property(node, "qcom,mdss-dsi-panel-name", NULL); | |-- sprintf(wind_device_info.lcm_module_info.ic_name, "%s", panel_name); | | | | // 绑定上电和背光控制的操作函数，后面有章节专门介绍 | |-- ctrl_pdata-&gt;on = mdss_dsi_panel_on; | |-- ctrl_pdata-&gt;off = mdss_dsi_panel_off; | |-- ctrl_pdata-&gt;panel_data.set_backlight = mdss_dsi_panel_bl_ctrl; | |-- return dsi_pan_node; lk 阶段在将 panel_config 写进 cmdline，kernel 中解析出出 cmdline 中 panel_config 的 panel_node_id，找到 panel_node_id 同名的 dts 节点。最后将找到的 dts 节点中的 “qcom,mdss-dsi-panel-name” 属性值写进 device info。总结一下：这样的话就要求 panel_config-&gt;panel_node_id 要和屏 dts 节点名要相同。 二. LCD 移植2.1 lk 阶段 lcd 移植流程经过上面兼容框架的分析，现在接着思考下在 lk 阶段 porting 一块新的 lcd 需要修改哪些地方。 修改点1. 屏参数头文件将屏供应商提供的屏参数头文件，如 panel_hx83102b_hsd_video.h 文件添加到 src/bootable/bootloader/lk/dev/gcdb/display/include/ 目录下。这个屏参数头文件中，包含有屏的启动参数，屏的配置信息等，在 init_panel_data() 函数中会将使用到这些信息。 修改点2. target_display.c这里需要在 panel_name_my 中追加新添加的 panel name，这样在遍历 lcd 驱动的时候才会取出新添加的屏驱动做探测的动作。 1234567891011121314diff --git a/bootable/bootloader/lk/target/msm8952/target_display.c b/bootable/bootloader/lk/target/msm8952/target_display.cindex a4548d7..16bd60b 100644--- a/bootable/bootloader/lk/target/msm8952/target_display.c+++ b/bootable/bootloader/lk/target/msm8952/target_display.c@@ -59,6 +59,7 @@ #define TRULY_CMD_PANEL_STRING "1:dsi:0:qcom,mdss_dsi_truly_720p_cmd:1:none:cfg:single_dsi" static char panel_name_my[5][64] = &#123;+ &#123;"hx83102b_hsd_55_720p_video"&#125;, &#123;"st7703_hsd_55_720p_video"&#125;, &#123;"st7703_boe_55_720p_video"&#125;, &#123;"ili9881p_panda_55_720p_video"&#125;, &#123;"ili9881c_hsd_55_720p_video"&#125;, &#125;; 修改点3. oem_panel.c这里文件修改点比较多，有 5 修改点，分别是： 包含屏参数头文件。 在枚举中追加新兼容的屏的 panel id。 将新兼容屏的 panel name 和 panel id 匹配上，并追加到 supp_panels 数组中。 在 switch (panel_id) 位置绑定屏相关参数。 修改目前兼容的 lcd 的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667diff --git a/bootable/bootloader/lk/target/msm8952/oem_panel.c b/bootable/bootloader/lk/target/msm8952/oem_panel.cindex d838a8b..742053b 100644--- a/bootable/bootloader/lk/target/msm8952/oem_panel.c+++ b/bootable/bootloader/lk/target/msm8952/oem_panel.c@@ -66,6 +66,7 @@ #include "include/panel_st7703_co55swr8_video.h" #include "include/panel_st7703_boe55_video.h" #include "include/panel_ili9881p_panda5_video.h"+#include "include/panel_hx83102b_hsd_video.h" /*---------------------------------------------------------------------------*/ /* static panel selection variable */@@ -74,6 +75,7 @@ #define ID1_PIN 61 enum &#123;+ HX83102B_HSD_PANEL, ST7703_HSD_PANEL, ST7703_BOE_PANEL, ILI9881P_PANDA_PANEL,@@ -108,6 +110,7 @@ uint32_t panel_regulator_settings[] = &#123; * Any panel in this list can be selected using fastboot oem command. */ static struct panel_list supp_panels[] = &#123;+ &#123;"hx83102b_hsd_55_720p_video", HX83102B_HSD_PANEL&#125;, &#123;"st7703_hsd_55_720p_video", ST7703_HSD_PANEL&#125;, &#123;"st7703_boe_55_720p_video", ST7703_BOE_PANEL&#125;, &#123;"ili9881p_panda_55_720p_video", ILI9881P_PANDA_PANEL&#125;,@@ -191,6 +194,28 @@ static int init_panel_data(struct panel_struct *panelstruct, switch (panel_id) &#123;+ case HX83102B_HSD_PANEL:+ panelstruct-&gt;paneldata = &amp;HX83102_B_720p_hsd_video_panel_data;+ panelstruct-&gt;paneldata-&gt;panel_with_enable_gpio = 1;+ panelstruct-&gt;panelres = &amp;HX83102_B_720p_hsd_video_panel_res;+ panelstruct-&gt;color = &amp;HX83102_B_720p_hsd_video_color;+ panelstruct-&gt;videopanel = &amp;HX83102_B_720p_hsd_video_video_panel;+ panelstruct-&gt;commandpanel = &amp;HX83102_B_720p_hsd_video_command_panel;+ panelstruct-&gt;state = &amp;HX83102_B_720p_hsd_video_state;+ panelstruct-&gt;laneconfig = &amp;HX83102_B_720p_hsd_video_lane_config;+ pinfo-&gt;mipi.panel_compare_id_read_cmds = HX83102_B_720p_video_compare_id_page_command;+ pinfo-&gt;mipi.panel_compare_id_page_cmds = HX83102_B_720p_video_compare_id_read_command;+ pinfo-&gt;mipi.compare_id = HX83102_B_720P_VIDEO_COMPARE_ID;+ panelstruct-&gt;paneltiminginfo = &amp;HX83102_B_720p_hsd_video_timing_info;+ panelstruct-&gt;panelresetseq = &amp;HX83102_B_720p_hsd_video_reset_seq;+ panelstruct-&gt;backlightinfo = &amp;HX83102_B_720p_hsd_video_backlight;+ pinfo-&gt;mipi.panel_on_cmds = HX83102_B_720p_hsd_video_on_command;+ pinfo-&gt;mipi.num_of_panel_on_cmds = HX83102_B_720P_HSD_VIDEO_ON_COMMAND;+ pinfo-&gt;mipi.panel_off_cmds = HX83102_B_720p_hsd_video_off_command;+ pinfo-&gt;mipi.num_of_panel_off_cmds = HX83102_B_720P_HSD_VIDEO_OFF_COMMAND;+ memcpy(phy_db-&gt;timing, HX83102_B_720p_hsd_video_timings, TIMING_SIZE);+ pinfo-&gt;mipi.signature = HX83102_B_720P_HSD_VIDEO_SIGNATURE;+ break; case ST7703_BOE_PANEL: panelstruct-&gt;paneldata = &amp;st7703_boe55_720p_video_panel_data; panelstruct-&gt;paneldata-&gt;panel_with_enable_gpio = 1;@@ -895,7 +920,7 @@ uint32_t oem_panel_compare_chip_id(struct mipi_panel_info *mipi) return data; &#125;-#define DISPLAY_MAX_PANEL_DETECTION 3+#define DISPLAY_MAX_PANEL_DETECTION 4 static uint32_t auto_pan_loop = 0; uint32_t oem_panel_max_auto_detect_panels() 2.2 kernel 阶段 lcd 移植流程修改点1. 添加屏相关的 dtsi 文件咨询 FAE 要到 LCM 相关的 panel dtsi 文件. 添加到 src/kernel/msm-3.18/arch/arm/boot/dts/qcom/ 目录下:eg: src/kernel/msm-3.18/arch/arm/boot/dts/qcom/dsi-panel-st7703_boe55-video.dtsi此 dtsi 仅仅是在 mdss_mdp 节点下追加了一个子节点。 123456&amp;mdss_mdp &#123; dsi_boe55_st7703_720p_video: qcom,dsi_boe55_st7703_720p_video &#123; qcom,mdss-dsi-panel-name = "dsi_boe55_st7703_720p_video"; ... ... &#125;;&#125;; 问1: msm8937 是 64 位的处理器, 为什么是在 arch/arm/ 下添加文件, 而不是在 arch/arm64 目录下添加?答1: 其实 arch/arm64 是通过软链接方式链接到 arch/arm 目录下，因此不管在哪个目录修改都是可以生效的。 12[wangbing@ubuntu: ~/src/kernel/msm-3.18/arch/arm64/boot/dts]$ ls -llrwxrwxrwx 1 wangbing wangbing 26 Apr 3 23:07 qcom -&gt; ../../../arm/boot/dts/qcom 修改点2. 包含屏参数 dtsi 文件到 dts 中在 src/kernel/msm-3.18/arch/arm/boot/dts/qcom/msm8937-mdss-panels.dtsi 包含上一个修改点中添加的 dtsi 文件。目的是为了让追加的 panel 的 dtsi 在编译 dtb 的时候能够被编译到。 1#include "dsi-panel-st7703_boe55-video.dtsi" 问1: dtb 编译的时候是如何确定哪些文件(哪些 dts 和 dtsi 文件)会被编译呢?答1: 编译 dtb 文件也是根据 Makefile 规则编译的，在 src/kernel/msm-3.18/arch/arm/boot/dts/qcom/ 目录的 Makefile 决定哪些 dts 文件会编译成 dtb。编译的时候会编译 Makefile 中指定的 dtb 文件, 而这些 dtb 文件对应的源文件(dts文件)会依赖于相关的 dtsi 文件。编译的时候就会将 dts 以及依赖的 dtsi 一起编译(类似于c文件依赖h文件一样)。 问2: dsi-panel-st7703_boe55-video.dtsi 文件的依赖关系是?答2: 一直根据 grep 搜索对应关键字, 就可以找到依赖关系: 12345msm8937-mdss-panels.dtsi:34: #include "dsi-panel-st7703_boe55-video.dtsi"msm8937-mtp.dtsi:320: #include "msm8937-mdss-panels.dtsi"msm8937-pmi8937-mtp.dtsi:15: #include "msm8937-mtp.dtsi"msm8937-pmi8937-mtp.dts:17: #include "msm8937-pmi8937-mtp.dtsi"Makefile:196: msm8937-pmi8937-mtp.dtb \ 修改点3. 设置默认屏驱动(可选)1234567891011121314151617msm8937-mtp.dtsi (kernel\msm-3.18\arch\arm64\boot\dts\qcom) &amp;mdss_dsi0 &#123;+ qcom,dsi-pref-prim-pan = &lt;&amp;dsi_hsd_ili9881_720p_video&gt;; pinctrl-names = "mdss_default", "mdss_sleep"; pinctrl-0 = &lt;&amp;mdss_dsi_active &amp;mdss_te_active&gt;; pinctrl-1 = &lt;&amp;mdss_dsi_suspend &amp;mdss_te_suspend&gt;; qcom,platform-te-gpio = &lt;&amp;tlmm 24 0&gt;; qcom,platform-enable-gpio = &lt;&amp;tlmm 99 0&gt;; qcom,platform-reset-gpio = &lt;&amp;tlmm 60 0&gt;; qcom,platform-bklight-en-gpio = &lt;&amp;tlmm 98 0&gt;; &#125;; +&amp;dsi_hsd_ili9881_720p_video &#123;+ qcom,panel-supply-entries = &lt;&amp;dsi_panel_pwr_supply&gt;;+ qcom,mdss-dsi-pan-fps-update = "dfps_immediate_porch_mode_vfp";+&#125;; 三. LCD 背光3.1 lk 阶段背光驱动3.1.1 点亮背光位置1234567891011121314151617181920// file: src/bootable/bootloader/lk/app/aboot/aboot.cvoid aboot_init(const struct app_descriptor *app) target_display_init(device.display_panel); gcdb_display_init(oem.panel, MDP_REV_50, (void *)MIPI_FB_ADDR); /* 根据 panel 的协议绑定对应的背光控制函数 */ if (pan_type == PANEL_TYPE_DSI) panel.bl_func = mdss_dsi_bl_enable; msm_display_init(&amp;panel); pdata-&gt;power_func(1, &amp;(panel-&gt;panel_info);static int mdss_dsi_bl_enable(uint8_t enable) panel_backlight_ctrl(enable); target_backlight_ctrl(panelstruct.backlightinfo, enable); msm8952_wled_backlight_ctrl(enable); qpnp_wled_enable_backlight(enable); /* #define QPNP_WLED_MAX_BR_LEVEL 1638 */ qpnp_wled_set_level(gwled, QPNP_WLED_MAX_BR_LEVEL); qpnp_wled_enable(gwled, gwled-&gt;ctrl_base, enable); qpnp_ibb_enable(enable); 3.2 kernel 阶段背光驱动3.2.1 对上抛出的接口LCD 背光驱动是通过内核提供的 LED 子系统注册的驱动，因此对应用层抛出的接口创建在 /sys/class/leds/ 目录下。 C:\Users\wangbing&gt; adb shell # 读取手机当前设置的背光等级 android:/ # cat /sys/class/leds/lcd-backlight/brightness 74 # 设置背光等级为 100/255(手机变得更亮) android:/ # echo 100 &gt; /sys/class/leds/lcd-backlight/brightness android:/ # cat /sys/class/leds/lcd-backlight/brightness 100 如何查看 logcat log 确认当前设置的背光值, 可以通过 DisplayPowerController: Animating brightness: 关键字确认。 C:\Users\wangbing&gt;adb shell android:/ # logcat -s DisplayPowerController | grep &quot;brightness&quot; 01-01 01:26:21.588 1206 1246 I DisplayPowerController: Animating brightness: target=102, rate=0, asusAnimator=false 01-01 01:26:21.588 1206 1246 I DisplayPowerController: Animating brightness: target=102, rate=0, asusAnimator=false 01-01 01:26:21.591 1206 1246 I DisplayPowerController: Animating brightness: target=102, rate=0, asusAnimator=false 3.2.2 驱动注册流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// file: src/kernel/msm-3.18/drivers/video/msm/mdss/mdss_fb.cmodule_init(mdss_fb_init);int __init mdss_fb_init(void) platform_driver_register(&amp;mdss_fb_driver);static struct platform_driver mdss_fb_driver = &#123; .probe = mdss_fb_probe, .remove = mdss_fb_remove, .suspend = mdss_fb_suspend, .resume = mdss_fb_resume, .shutdown = mdss_fb_shutdown, .driver = &#123; .name = "mdss_fb", .of_match_table = mdss_fb_dt_match, .pm = &amp;mdss_fb_pm_ops, &#125;,&#125;;/* LED 设备，设备注册成功后，将会创建 /sys/class/leds/lcd-backlight 目录 */static struct led_classdev backlight_led = &#123; .name = "lcd-backlight", /* LED 设备的名字 */ .brightness = 127, /* 默认亮度为 127 */ .brightness_set = mdss_fb_set_bl_brightness, /* 设置亮度的函数 */ .max_brightness = 255, /* 最大亮度为 255 */&#125;;/* 注册 LED 设备的位置 */static int mdss_fb_probe(struct platform_device *pdev) backlight_led.brightness = mfd-&gt;panel_info-&gt;brightness_max; backlight_led.max_brightness = mfd-&gt;panel_info-&gt;brightness_max; if (led_classdev_register(&amp;pdev-&gt;dev, &amp;backlight_led))/* 设置 LED 亮度的函数 */static void mdss_fb_set_bl_brightness(struct led_classdev *led_cdev, enum led_brightness value) /* 如果传入的值比支持设置的最大值要大，则修改为支持的最大值 */ if (value &gt; mfd-&gt;panel_info-&gt;brightness_max) value = mfd-&gt;panel_info-&gt;brightness_max; /* 加了个 log 将 value 和 bl_lvl 打印出来，确认到这里的映射关系为: bl_lvl = value / 255 * 4096 */ /* 说明这里是将上层传递过来的 0~255 的亮度等级转化为实际 PMIC 支持的亮度等级 */ /* This maps android backlight level 0 to 255 into driver backlight level 0 to bl_max with rounding */ MDSS_BRIGHT_TO_BL(bl_lvl, value, mfd-&gt;panel_info-&gt;bl_max, mfd-&gt;panel_info-&gt;brightness_max); /* 设置屏幕背光，最终还是调用 panel 中绑定的函数 */ mdss_fb_set_backlight(mfd, bl_lvl); pdata-&gt;set_backlight(pdata, bl_lvl);/* 搜索看看 set_backlight 在哪里绑定了操作函数 */---- set_backlight Matches (13 in 5 files) ----mdss_dsi_panel_init in mdss_dsi_panel.c (msm\mdss) : ctrl_pdata-&gt;panel_data.set_backlight = mdss_dsi_panel_bl_ctrl;mdss_edp_device_register in mdss_edp.c (msm\mdss) : edp_drv-&gt;panel_data.set_backlight = mdss_edp_set_backlight;/* 实际控制背光的位置在这里 */static void mdss_dsi_panel_bl_ctrl(struct mdss_panel_data *pdata, u32 bl_level) /* 控制 PMI 的 WLED 引脚控制背光 */ led_trigger_event(bl_led_trigger, bl_level); 3.2.3 自问自答问1: 背光驱动没有实现 brightness_get 接口，为什么却可以通过 cat /sys/class/leds/lcd-backlight/brightness 节点获得亮度值?答1: 看了下读 brightness 节点的函数，在读取 /sys/class/leds/lcd-backlight/brightness 节点时。如果定义了 brightness_get 函数，则将会获取到的亮度值，传递给 backlight_led-&gt;brightness，然后将 backlight_led-&gt;brightness 值返回；如果没有定义 brightness_get 函数，则直接返回 backlight_led-&gt;brightness 的值。 问2: 现在的疑问就变成了，为什么没有通过 brightness_get 获取亮度值，backlight_led-&gt;brightness 也是准确的?答2: 看了下写 brightness 节点的函数，在写入亮度值 /sys/class/leds/lcd-backlight/brightness 节点时。同时将写入的值记录到了 backlight_led-&gt;brightness 变量中，因此读取的时候其实获取到的是上一次写入的值。 上述两个疑问涉及到的代码如下： 12345678910111213141516171819202122232425262728// file: src/kernel/msm-3.18/drivers/leds/led-class.c/* 定义了属性节点 */static DEVICE_ATTR_RW(brightness);/* 读属性时调用的函数 */static ssize_t brightness_show(struct device *dev, struct device_attribute *attr, char *buf) |-- struct led_classdev *led_cdev = dev_get_drvdata(dev); |-- led_update_brightness(led_cdev); | | | | // 如果定义了 brightness_get 函数，则将获取到的亮度值记录到 led_cdev-&gt;brightness | |-- if (led_cdev-&gt;brightness_get) | led_cdev-&gt;brightness = led_cdev-&gt;brightness_get(led_cdev); | | // 这里直接将 led_cdev-&gt;brightness 返回 |-- return sprintf(buf, "%u\n", led_cdev-&gt;brightness);/* 写属性时调用的函数 */static ssize_t brightness_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size) |-- struct led_classdev *led_cdev = dev_get_drvdata(dev); |-- ret = kstrtoul(buf, 10, &amp;state); |-- __led_set_brightness(led_cdev, state); | | // 先将写进的值保存到 led_cdev-&gt;brightness 中 |-- led_cdev-&gt;brightness = value; | | // 接着调用 brightness_set 函数控制 PMI 调整背光 |-- led_cdev-&gt;brightness_set(led_cdev, value); 四. LCD 上电4.1 LCD 上电前言每一块 lcd ic 在 spec 上都会详细的描述它们上电的时序要求。以往工厂生产的时候，经常会出现由于上电时序不对或者是各路电之前的延时过短不符合 spec 规范导致的花屏、读不到 panel id 甚至烧坏 ic 的情况。因此在阅读屏驱动框架的时候，必须要准确的找到上电这块的代码位置。目前我们公司大部分的 LCD 都有两路电，一路是给 ic 供电的 IOVDD，另一路是加在玻璃上的偏置电压(VSP、VSN)，同时在 spec 上电时序的描述中，还会多加一路 ic 的 reset 信号，spec 上会给出这三者详细的上电掉电时序要求。我们要做的就是去 check 这个位置，看看是不是符合 spec 要求，不符合就将其修改。一般来说修改也仅仅是修改偏置电压，交换 reset 和偏置电压的前后顺序，需改时序间的延时之类的。 4.2 lk 阶段开机上电位置12345678910111213141516171819202122232425262728// file: src/bootable/bootloader/lk/app/aboot/aboot.cvoid aboot_init(const struct app_descriptor *app) target_display_init(device.display_panel); gcdb_display_init(oem.panel, MDP_REV_50, (void *)MIPI_FB_ADDR); /* 根据 panel 的协议绑定对应的上电函数 */ if (pan_type == PANEL_TYPE_DSI) panel.power_func = mdss_dsi_panel_power; msm_display_init(&amp;panel); pdata-&gt;power_func(1, &amp;(panel-&gt;panel_info);static int mdss_dsi_panel_power(uint8_t enable, struct msm_panel_info *pinfo) if (enable) &#123; target_ldo_ctrl(enable, pinfo); mdss_dsi_panel_reset(enable); &#125; else &#123; mdss_dsi_panel_reset(enable); target_ldo_ctrl(enable, pinfo); &#125;int target_ldo_ctrl(uint8_t enable, struct msm_panel_info *pinfo) if (enable) &#123; regulator_enable(ldo_num); /* 使能 IOVDD */ wled_init(pinfo); /* 配置 VSP VSN 电压电流 */ qpnp_ibb_enable(true); /* 使能 VSP VSN */ &#125; else &#123; ... ... &#125; 4.3 kernel 阶段上下电位置123mdss_dsi_panel_power_ctrl mdss_dsi_panel_power_on msm_dss_enable_vreg 五. LCD 静电5.1 使能 esd check 功能屏 dtsi 中增加以下属性以开启 esd check 功能： &amp;mdss_mdp { dsi_co55swr8_st7703_720p_video: qcom,dsi_co55swr8_st7703_720p_video { ... ... /* 使能 esd check 机制 */ qcom,esd-check-enabled; /* 指定 esd check 的 command，cmd 最后一次字节是 check 的寄存器 */ qcom,mdss-dsi-panel-status-command = [ 14 01 00 01 05 00 01 68 06 01 00 01 05 00 01 09 14 01 00 01 05 00 01 CC 14 01 00 01 05 00 01 AF ]; /* 指定 esd check 的命令模式 */ qcom,mdss-dsi-panel-status-command-state = &quot;dsi_lp_mode&quot;; /* 指定 esd check 的校验模式 */ qcom,mdss-dsi-panel-status-check-mode = &quot;reg_read&quot;; /* 在 command 中指定指定过了 check 的寄存器，这里指定 check 对应寄存器的前几个字节 */ qcom,mdss-dsi-panel-status-read-length = &lt;1 3 1 1&gt;; /* 这个属性的含义还在摸索中 */ qcom,mdss-dsi-panel-max-error-count = &lt;2&gt;; /* 指定 esd check 读取的寄存器的标准值 */ qcom,mdss-dsi-panel-status-value = &lt;0xC0&gt; , &lt;0x80 0x73 0x04&gt;, &lt;0x0B&gt;,&lt;0xFD&gt;; ... ... }; }; 5.2 追踪 esd check 流程在 mdss_dsi.c 文件中解析 dts 中屏节点中设置的 esd 相关属性，相关代码流程如下： // file: src/kernel/msm-3.18/drivers/video/msm/mdss/mdss_dsi.c static int mdss_dsi_ctrl_probe(struct platform_device *pdev) mdss_dsi_config_panel(pdev, index); /* 根据 panel_cfg 指定的 panel 找到对应的 dts 节点 */ mdss_dsi_find_panel_of_node(pdev, panel_cfg); // file: src/kernel/msm-3.18/drivers/video/msm/mdss/mdss_dsi_panel.c mdss_dsi_panel_init(dsi_pan_node, ctrl_pdata, ndx); mdss_panel_parse_dt(node, ctrl_pdata); mdss_dsi_parse_panel_features(np, ctrl_pdata); /* 解析 dts 中 esd check 相关的参数 */ mdss_dsi_parse_esd_params(np, ctrl); dsi_panel_device_register(pdev, dsi_pan_node, ctrl_pdata); /* 根据 status_mode 绑定对应的 esd check 的函数 */ if (ctrl_pdata-&gt;status_mode == ESD_REG) ctrl_pdata-&gt;check_status = mdss_dsi_reg_status_check; // file: src/kernel/msm-3.18/drivers/video/msm/mdss/mdss_dsi_status.c module_init(mdss_dsi_status_init); mdss_dsi_status_init INIT_DELAYED_WORK(&amp;pstatus_data-&gt;check_status, check_dsi_ctrl_status); check_dsi_ctrl_status pdsi_status-&gt;mfd-&gt;mdp.check_dsi_status(work, interval); &gt; mdss_check_dsi_ctrl_status ctrl_pdata-&gt;check_status(ctrl_pdata); &gt; mdss_dsi_reg_status_check /* 读取寄存器状态 */ mdss_dsi_read_status(ctrl_pdata); /* 校验寄存器状态 */ ctrl_pdata-&gt;check_read_status(ctrl_pdata); &gt; mdss_dsi_gen_read_status(ctrl_pdata); mdss_dsi_cmp_panel_reg_v2(ctrl_pdata); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166static void mdss_dsi_parse_esd_params(struct device_node *np, struct mdss_dsi_ctrl_pdata *ctrl)&#123; u32 tmp; u32 i, status_len, *lenp; int rc; struct property *data; const char *string; struct mdss_panel_info *pinfo = &amp;ctrl-&gt;panel_data.panel_info; /* 获取 esd check 使能的标识位 */ pinfo-&gt;esd_check_enabled = of_property_read_bool(np, "qcom,esd-check-enabled"); /* 倘若未使能 esd check，此函数直接 return */ if (!pinfo-&gt;esd_check_enabled) return; ctrl-&gt;status_mode = ESD_MAX; /* 获取 esd check 的 check mode */ rc = of_property_read_string(np, "qcom,mdss-dsi-panel-status-check-mode", &amp;string); /* 根据获取到的 check mode 设置好 ctrl-&gt;status_mode 为对应的宏 */ if (!rc) &#123; if (!strcmp(string, "bta_check")) &#123; ctrl-&gt;status_mode = ESD_BTA; &#125; else if (!strcmp(string, "reg_read")) &#123; ctrl-&gt;status_mode = ESD_REG; ctrl-&gt;check_read_status = mdss_dsi_gen_read_status; &#125; else if (!strcmp(string, "reg_read_nt35596")) &#123; ctrl-&gt;status_mode = ESD_REG_NT35596; ctrl-&gt;status_error_count = 0; ctrl-&gt;check_read_status = mdss_dsi_nt35596_read_status; &#125; else if (!strcmp(string, "te_signal_check")) &#123; if (pinfo-&gt;mipi.mode == DSI_CMD_MODE) &#123; ctrl-&gt;status_mode = ESD_TE; &#125; else &#123; pr_err("TE-ESD not valid for video mode\n"); goto error; &#125; &#125; else &#123; pr_err("No valid panel-status-check-mode string\n"); goto error; &#125; &#125; /* 对于 ESD_BTA、ESD_BTA、ESD_MAX 这几种 check mode 不需要获取其他的属性参数 */ if ((ctrl-&gt;status_mode == ESD_BTA) || (ctrl-&gt;status_mode == ESD_TE) || (ctrl-&gt;status_mode == ESD_MAX)) return; /* 对于 ESD_REG 和 ESD_REG_NT35596 这两种 check 寄存器状态的模式，需要获取 check 哪些寄存器 */ mdss_dsi_parse_dcs_cmds(np, &amp;ctrl-&gt;status_cmds, "qcom,mdss-dsi-panel-status-command", "qcom,mdss-dsi-panel-status-command-state"); rc = of_property_read_u32(np, "qcom,mdss-dsi-panel-max-error-count", &amp;tmp); ctrl-&gt;max_status_error_count = (!rc ? tmp : 0); if (!mdss_dsi_parse_esd_status_len(np, "qcom,mdss-dsi-panel-status-read-length", &amp;ctrl-&gt;status_cmds_rlen, ctrl-&gt;status_cmds.cmd_cnt)) &#123; pinfo-&gt;esd_check_enabled = false; return; &#125; if (mdss_dsi_parse_esd_status_len(np, "qcom,mdss-dsi-panel-status-valid-params", &amp;ctrl-&gt;status_valid_params, ctrl-&gt;status_cmds.cmd_cnt)) &#123; if (!mdss_dsi_parse_esd_check_valid_params(ctrl)) goto error1; &#125; status_len = 0; lenp = ctrl-&gt;status_valid_params ?: ctrl-&gt;status_cmds_rlen; for (i = 0; i &lt; ctrl-&gt;status_cmds.cmd_cnt; ++i) status_len += lenp[i]; data = of_find_property(np, "qcom,mdss-dsi-panel-status-value", &amp;tmp); tmp /= sizeof(u32); if (!IS_ERR_OR_NULL(data) &amp;&amp; tmp != 0 &amp;&amp; (tmp % status_len) == 0) &#123; ctrl-&gt;groups = tmp / status_len; &#125; else &#123; pr_err("%s: Error parse panel-status-value\n", __func__); goto error1; &#125; ctrl-&gt;status_value = kzalloc(sizeof(u32) * status_len * ctrl-&gt;groups, GFP_KERNEL); if (!ctrl-&gt;status_value) goto error1; ctrl-&gt;return_buf = kcalloc(status_len * ctrl-&gt;groups, sizeof(unsigned char), GFP_KERNEL); if (!ctrl-&gt;return_buf) goto error2; rc = of_property_read_u32_array(np, "qcom,mdss-dsi-panel-status-value", ctrl-&gt;status_value, ctrl-&gt;groups * status_len); if (rc) &#123; pr_debug("%s: Error reading panel status values\n", __func__); memset(ctrl-&gt;status_value, 0, ctrl-&gt;groups * status_len); &#125; return;error2: kfree(ctrl-&gt;status_value);error1: kfree(ctrl-&gt;status_valid_params); kfree(ctrl-&gt;status_cmds_rlen);error: pinfo-&gt;esd_check_enabled = false;&#125;static int mdss_dsi_read_status(struct mdss_dsi_ctrl_pdata *ctrl)&#123; int i, rc, *lenp; int start = 0; struct dcs_cmd_req cmdreq; rc = 1; lenp = ctrl-&gt;status_valid_params ?: ctrl-&gt;status_cmds_rlen; for (i = 0; i &lt; ctrl-&gt;status_cmds.cmd_cnt; ++i) &#123; memset(&amp;cmdreq, 0, sizeof(cmdreq)); cmdreq.cmds = ctrl-&gt;status_cmds.cmds + i; cmdreq.cmds_cnt = 1; cmdreq.flags = CMD_REQ_COMMIT | CMD_REQ_RX; cmdreq.rlen = ctrl-&gt;status_cmds_rlen[i]; cmdreq.cb = NULL; cmdreq.rbuf = ctrl-&gt;status_buf.data; if (ctrl-&gt;status_cmds.link_state == DSI_LP_MODE) cmdreq.flags |= CMD_REQ_LP_MODE; else if (ctrl-&gt;status_cmds.link_state == DSI_HS_MODE) cmdreq.flags |= CMD_REQ_HS_MODE; rc = mdss_dsi_cmdlist_put(ctrl, &amp;cmdreq); if (rc &lt;= 0) &#123; pr_err("%s: get status: fail\n", __func__); return rc; &#125; memcpy(ctrl-&gt;return_buf + start, ctrl-&gt;status_buf.data, lenp[i]); start += lenp[i]; &#125; return rc;&#125;static bool mdss_dsi_cmp_panel_reg_v2(struct mdss_dsi_ctrl_pdata *ctrl)&#123; int i, j; int len = 0, *lenp; int group = 0; lenp = ctrl-&gt;status_valid_params ?: ctrl-&gt;status_cmds_rlen; for (i = 0; i &lt; ctrl-&gt;status_cmds.cmd_cnt; i++) len += lenp[i]; /* 这里比对寄存器中读取出来的值和 dts 中理论上寄存器中的值 */ for (j = 0; j &lt; ctrl-&gt;groups; ++j) &#123; for (i = 0; i &lt; len; ++i) &#123; printk("lcd esd return_buf[%d] = 0x%x status_value = 0x%x %s %d\n", i, ctrl-&gt;return_buf[i], ctrl-&gt;status_value[group + i], __func__, __LINE__); if (ctrl-&gt;return_buf[i] != ctrl-&gt;status_value[group + i]) break; &#125; if (i == len) return true; group += len; &#125; return false;&#125; 六. LCD 框架6.1 lk 阶段 lcd 框架分析对于 i2c、spi、usb 总线下的设备，写驱动程序的时候，涉及到两部分，分别是总线驱动和设备驱动。以 i2c 为例，总线驱动和设备驱动各自有对应的分工，总线驱动负责控制 i2c 控制器(片上外设)，将 i2c 控制器寄存器相关的控制逻辑封装成符合 i2c 规范的 start、stop、ask、sendbyte、readbyte 等接口函数。至于设备驱动，只需要根据设备的 datasheet 并按照总线的规范调用总线提供的接口函数，就可以实现和设备的通信。和我们熟悉的 i2c、spi、usb 一样，mipi dsi 协议也是一样的，也分为总线驱动和设备驱动。我们分析框架，对于总线驱动部分只需要找到对应的接口函数即可，暂不去深入分析 mipi 总线驱动，重点看看点亮一块屏，设备驱动端上电时序，如下 init code，以及让 lcd 显示一帧图片需要如何操作。 未完待续。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>qcom</tag>
        <tag>lcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] TP 相关 debug 流程]]></title>
    <url>%2F2018%2F04%2F11%2Fodm-tp-debug-flow%2F</url>
    <content type="text"><![CDATA[一 常见问题1.1 触摸失效 确认是否是 TP 的问题使用 otg 接鼠标看看能否正常点击？otg 鼠标可以的话，用 otg 鼠标打开指针位置，再触摸，看看有没有指针。这步操作可以确认是 TP 的问题，还是 UI 响应的问题。 确认驱动有没有注册上在没有重启手机(不重启手机是怕重启后不良现象丢失)保留着不良现象的前提下，查看 TP 相关的 proc、sys 节点是否创建成功？有节点说明驱动正常注册上了，没有则驱动没有注册上。如果不良现象重启还能复现的话(重启动作最后才能做，先做好其他的验证)，可以抓取开机 log 确认 i2c 驱动是否注册上了，这样最为准确。 确认有没有中断如果驱动注册上了，还是失效的话，需要查看 /proc/interrupts 节点，看看有没有检测到 TP 的中断。 123456C:\Users\wangbing&gt;adb shell cat /proc/interrupts CPU0 CPU1 CPU2 CPU3 3: 103643 54431 40430 34763 GIC 20 arch_timer 5: 76002 33111 25707 15604 GIC 39 arch_mem_timer 6: 37 0 0 0 GIC 240 72: 3496 0 0 0 msmgpio 65 hxcommon 这里的 “hxcommon” 是中断名称，3496 是中断计数，cat 查看之后，触摸几下，再次执行上面的命令。看看中断计数是否有增加，有增加说明有中断产生。 确认有没有报点如果中断有捕捉到，但还是失效的话，再看看有没有报点信息。部分 TP 支持动态的开关 debug log，开启 debug log 示例如下： 12345C:\Users\wangbing&gt;adb shellandroid:/ # cd proc/android_touch/android:/proc/android_touch # echo 3 &gt; debug_levelandroid:/proc/android_touch # cat debug_level3 开启 debug log 再看看有没有报点 log 打印。 12C:\Users\wangbing&gt;adb shell dmesg -c &gt; 0 &amp;&amp; adb shell dmesg -w | findstr &quot;HX83102&quot;[53300.503826] [HX83102] Finger 1=&gt; X:347, Y:734 W:82, Z:82, F:1, N:0 查看 IC 工作状态部分 TP 预留有查看寄存器信息的 proc 节点，具体的使用方法根据各家的 proc 节点实现而定，详细的使用方法需要仔细阅读节点读写函数。 12345678910111213141516171819202122232425C:\Users\wangbing&gt;adb shellandroid:/ # cd proc/android_touch/android:/proc/android_touch # echo &quot;r:x8F&quot; &gt; registerandroid:/proc/android_touch # cat registercommand: 00,00,00,8F0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00android:/proc/android_touch # echo &quot;r:x8F&quot; &gt; registerandroid:/proc/android_touch # cat registercommand: 00,00,00,8F0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 这里看 cat 8F 寄存器得到的第一次字节，在亮屏报点模式下，8F 寄存器的值是 0x00，在熄屏手势模式下，8F 寄存器的值是 0x20，和 spec 描述相符合，说明工作状态正常。 确认 IC 是否异常有些时候，可能是某一次 TP IC 在唤醒屏幕的时候 reset 过程出现问题，或者是莫名奇妙的出现问题，这谁也说不准。可以按 power key 多亮灭屏几次(会重新给 TP 上下电，做 reset IC 的动作)，看触摸是否可以恢复正常。 确认是否是单体不良做个交叉实现验证下：找一台正常手机，接不良机器的屏，看是否还是不良。将正常机器的屏，接上不良机主板，看不良是否跟着屏走。 1.2 熄屏手势失效 确认上层手势开关设置是否生效我们知道手势的开关控制是驱动在 proc 目录下创建对应的控制节点，上层通过写这些节点将手势的开关信息传递到驱动中。手势失效的情况，应该先 cat 这些 proc 节点，看看手势的开关控制信息是否真正的传递到了驱动中。一般驱动中都会在读写手势的 fops 中加点 log，最好是通过 log 确认，这样最为准确。 确认 TP 睡眠时有没有成功进入手势模式一般供应商在 tp suspend 函数中进入手势模式的位置都有对应的 debug 的 log，这里直接通过 log 确认就好。没有的话一定要自己加一句。部分 TP 支持查看状态寄存器，这种确认方式最为有效。 确认是否有手势键值上报如果确实开了手势，并且 TP 已经进入了手势模式，看看有没有手势键值上报，一般上报手势键值的位置都要加好对应的 log，通过 log 确认下有没有手势键值上报，如果调试的时候忘记了加 log，可以使用 getevent 看看 TP 对应的 input 设备有没有上报 input 事件，这样也可以确认。如果有键值上报，说明上层没有响应，上层的问题，由于有做口袋模式，那顺便看看距离传感器功能是不是正常的。没有上报，还是驱动这块的问题，再接着分析。 确认熄屏手势是否产生中断如果进入了手势模式，但没有键值上报，那就要看看 /proc/interrupts 节点，看看有没有检测到 TP 的中断，没有检测到，估计就是 TP IC 单体不良，交给供应商分析就好。如果检测到中断，还是没有上报，估计就是驱动中哪里出了问题，要打开 TP debug log 开关，好好分析 log 了，同样建议约供应商一起看 log 分析。 二 常用 TP debug 手段2.1 adb shell inputinput 命令是用来向设备发送模拟操作的命令，不同的 Android 版本支持的选项有所不同，Android 8.0 系统的 input 说明如下：1234567891011121314151617181920212223C:\Users\wangbing&gt;adb shell inputUsage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: dpad keyboard mouse touchpad gamepad touchnavigation joystick touchscreen stylus trackballThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) draganddrop &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 使用 input 命令，可以实现唤醒屏幕，上滑解锁，点击屏幕，输入字符等操作。 1234567891011121314// 唤醒屏幕C:\Users\wangbing&gt;adb shell input keyevent &quot;KEYCODE_POWER&quot;// 上滑，从 (360 900) 滑动到 (360 300)C:\Users\wangbing&gt;adb shell input swipe 360 900 360 300// 左滑C:\Users\wangbing&gt;adb shell input swipe 200 720 600 720// 触摸C:\Users\wangbing&gt;adb shell input tap 340 360// 向获得焦点的 EditText 控件输入内容C:\Users\wangbing&gt;adb shell input text &quot;hello,world&quot; 将上面的命令组合起来后依次执行对应的效果如下： C:\Users\wangbing&gt;adb shell input keyevent &quot;KEYCODE_POWER&quot; &amp;&amp; adb shell input swipe 360 900 360 300 &amp;&amp; adb shell input swipe 200 720 600 720 &amp;&amp; adb shell input tap 340 360 &amp;&amp; adb shell input text &quot;hello,world&quot; 2.2 adb shell getevent1234567891011121314C:\Users\wangbing&gt;adb shell getevent -helpUsage: getevent [-t] [-n] [-s switchmask] [-S] [-v [mask]] [-d] [-p] [-i] [-l] [-q] [-c count] [-r] [device] -t: show time stamps -n: don&apos;t print newlines -s: print switch states for given bits -S: print all switch states -v: verbosity mask (errs=1, dev=2, name=4, info=8, vers=16, pos. events=32, props=64) -d: show HID descriptor, if available -p: show possible events (errs, dev, name, pos. events) -i: show all device info and possible events -l: label event types and names in plain text -q: quiet (clear verbosity mask) -c: print given number of events then exit -r: print rate events are received 2.3 adb shell sendevent1234C:\Users\wangbing&gt;adb shell sendevent --helpusage: sendevent DEVICE TYPE CODE VALUESends a Linux input event.]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>qcom</tag>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 获取 eMMC 总容量需求实现]]></title>
    <url>%2F2018%2F03%2F26%2Fodm-gets-the-total-capacity-of-eMMC%2F</url>
    <content type="text"><![CDATA[问题描述现时代的安卓手机厂商都喜欢自己克客制化 Android 系统，做一套具有品牌特点的 UI 界面。我们客户也不例外，由于客户克制化了 UI 界面后，在 setting 中显示手机存储容量的界面上，需要读取 /data/data/emmc_total_size 节点获取 eMMC(Flash) 的大小。因此驱动这边需要实现 /data/data/emmc_total_size 这个节点，将 eMMC 大小传递到上层。 功能实现kernel 中的需要创建 sys 节点，这里修改了 mmc.c 和 card.h 两个文件，具体修改的 diff 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.cindex dc2e206..b9d567a 100755--- a/drivers/mmc/core/mmc.c+++ b/drivers/mmc/core/mmc.c@@ -591,7 +591,9 @@ static int mmc_read_ext_csd(struct mmc_card *card，u8 *ext_csd) &#123; int err = 0，idx; unsigned int part_size;+// mz8023yt@163.com 20180324 begin &gt;&gt;&gt; [1/6] add the mmc total size debug node+ unsigned int size = 0;+// mz8023yt@163.com 20180324 end &lt;&lt;&lt; [1/6] add the mmc total size debug node BUG_ON(!card); if (!ext_csd)@@ -636,6 +638,14 @@ static int mmc_read_ext_csd(struct mmc_card *card，u8 *ext_csd) /* Cards with density &gt; 2GiB are sector addressed */ if (card-&gt;ext_csd.sectors &gt; (2u * 1024 * 1024 * 1024) / 512) mmc_card_set_blockaddr(card);+// mz8023yt@163.com 20180324 begin &gt;&gt;&gt; [1/6] add the mmc total size debug node + size = card-&gt;ext_csd.sectors &gt;&gt; 20;+ card-&gt;mmc_total_size = 1;+ while ((size &gt; 0) &amp;&amp; (size &gt;&gt; 1) &gt; 0) &#123;+ size = size &gt;&gt; 1;+ card-&gt;mmc_total_size = card-&gt;mmc_total_size * 2;+ &#125;+// mz8023yt@163.com 20180324 end &lt;&lt;&lt; [1/6] add the mmc total size debug node &#125; card-&gt;ext_csd.raw_card_type = ext_csd[EXT_CSD_CARD_TYPE];@@ -986,6 +996,14 @@ out: return err; &#125; +// mz8023yt@163.com 20180324 begin &gt;&gt;&gt; [2/6] add the mmc total size debug node+static unsigned int get_emmc_total_size(struct mmc_card *card)+&#123;+ BUG_ON(!card);+ return card-&gt;mmc_total_size;+&#125;+// mz8023yt@163.com 20180324 end &lt;&lt;&lt; [2/6] add the mmc total size debug node MMC_DEV_ATTR(cid，"%08x%08x%08x%08x\n"，card-&gt;raw_cid[0]，card-&gt;raw_cid[1], card-&gt;raw_cid[2]，card-&gt;raw_cid[3]); MMC_DEV_ATTR(csd，"%08x%08x%08x%08x\n"，card-&gt;raw_csd[0]，card-&gt;raw_csd[1],@@ -1013,6 +1031,10 @@ MMC_DEV_ATTR(enhanced_rpmb_supported，"%#x\n", card-&gt;ext_csd.enhanced_rpmb_supported); MMC_DEV_ATTR(rel_sectors，"%#x\n"，card-&gt;ext_csd.rel_sectors); +// mz8023yt@163.com 20180324 begin &gt;&gt;&gt; [3/6] add the mmc total size debug node+MMC_DEV_ATTR(emmc_total_size，"%d\n"，get_emmc_total_size(card));+// mz8023yt@163.com 20180324 end &lt;&lt;&lt; [3/6] add the mmc total size debug node static struct attribute *mmc_std_attrs[] = &#123; &amp;dev_attr_cid.attr, &amp;dev_attr_csd.attr,@@ -1034,6 +1056,9 @@ static struct attribute *mmc_std_attrs[] = &#123; &amp;dev_attr_raw_rpmb_size_mult.attr, &amp;dev_attr_enhanced_rpmb_supported.attr, &amp;dev_attr_rel_sectors.attr,+// mz8023yt@163.com 20180324 begin &gt;&gt;&gt; [4/6] add the mmc total size debug node+ &amp;dev_attr_emmc_total_size.attr,+// mz8023yt@163.com 20180324 end &lt;&lt;&lt; [4/6] add the mmc total size debug node NULL, &#125;; ATTRIBUTE_GROUPS(mmc_std);================================================================================diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.hold mode 100644new mode 100755index f6cec9c..8dc3599--- a/include/linux/mmc/card.h+++ b/include/linux/mmc/card.h@@ -431,6 +431,10 @@ struct mmc_card &#123; u8 *cached_ext_csd; bool cmdq_init; struct mmc_bkops_info bkops;++// mz8023yt@163.com 20180324 begin &gt;&gt;&gt; [5/6] add the mmc total size debug node+ unsigned int mmc_total_size;+// mz8023yt@163.com 20180324 end &lt;&lt;&lt; [5/6] add the mmc total size debug node &#125;; sys 节点创建好了，接下来创建到 /data/data/ 目录下的链接文件。创建链接文件需要修改 device 目录下的 init 配置文件。 123456789101112131415diff --git a/project_name/init.target.rc b/project_name/init.target.rcindex 45902de..e3a3f08 100755--- a/project_name/init.target.rc+++ b/project_name/init.target.rc@@ -87,6 +87,10 @@ on post-fs-data mkdir /persist/data/tz 0700 system system mkdir /data/vendor/hbtp 0750 system system mkdir /data/misc/dts 0770 media audio+# mz8023yt@163.com 20180326 begin &gt;&gt;&gt; [6/6] add the mmc total size debug node+ symlink /sys/devices/soc/7824900.sdhci/mmc_host/mmc0/mmc0:0001/emmc_total_size /data/data/emmc_total_size+ chmod 0777 /data/data/emmc_total_size+# mz8023yt@163.com 20180326 end &lt;&lt;&lt; [6/6] add the mmc total size debug node # add by qiancheng 20171128 start setprop persist.sys.fp.subid 0 如何验证找到一台 16+2 的手机，先看看 sys 下的节点功能是否生效。找不到节点的话，可以先 find 下节点名，找到节点路径。 123456C:\Users\wangbing&gt;adb shellandroid:/ # cd sysandroid:/sys # find -name "emmc_total_size"./devices/soc/7824900.sdhci/mmc_host/mmc0/mmc0:0001/emmc_total_sizeandroid:/sys # cat devices/soc/7824900.sdhci/mmc_host/mmc0/mmc0:0001/emmc_total_size16 找到路径后下次直接 cat 就可以了。 12C:\Users\wangbing\Desktop\unlock&gt;adb shell cat /sys/devices/soc/7824900.sdhci/mmc_host/mmc0/mmc0:0001/emmc_total_size16 sys 节点已经生效了，再看看到 /data/data 的链接文件有没有功能。 12345C:\Users\wangbing\Desktop\unlock&gt;adb shell cat /data/data/emmc_total_size16C:\Users\wangbing\Desktop\unlock&gt;adb shell ls -l /data/data/emmc_total_sizelrwxrwxrwx 1 root root 70 1970-01-01 02:27 /data/data/emmc_total_size -&gt; /sys/devices/soc/7824900.sdhci/mmc_host/mmc0/mmc0:0001/emmc_total_size 核心模块查看代码前后逻辑，发现这里计算 ROM 容量的大小是通过计算 eMMC 的 sector(扇区) 的个数乘以 sector 的大小计算到的总容量。EMMC 中的 ROM 由扇区(sector)组成，扇区有 512Byte 和 4KB 两种大小。 具体的扇区的大小是记录在 Extended CSD register 的 ExtCSD[61] 中. 拥有的扇区的个数是记录在 Extended CSD register 的 ExtCSD[215:212] 中. 详细的信息请查阅 《JESD84-B51》 协议手册 7.4 小节。 相关代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define EXT_CSD_DATA_SECTOR_SIZE 61 /* R */#define EXT_CSD_SEC_CNT 212 /* RO，4 bytes */static int mmc_read_ext_csd(struct mmc_card *card，u8 *ext_csd) &#123; ... ... /* * The EXT_CSD format is meant to be forward compatible. As long * as CSD_STRUCTURE does not change，all values for EXT_CSD_REV * are authorized，see JEDEC JESD84-B50 section B.8. */ // 读取 emmc 协议版本号 card-&gt;ext_csd.rev = ext_csd[EXT_CSD_REV]; if (card-&gt;ext_csd.rev &gt;= 2) &#123; // 读取 sector 的个数，保存在 card-&gt;ext_csd.sectors 中 card-&gt;ext_csd.sectors = ext_csd[EXT_CSD_SEC_CNT + 0] &lt;&lt; 0 | ext_csd[EXT_CSD_SEC_CNT + 1] &lt;&lt; 8 | ext_csd[EXT_CSD_SEC_CNT + 2] &lt;&lt; 16 | ext_csd[EXT_CSD_SEC_CNT + 3] &lt;&lt; 24; /** * 这里根据 sector 个数计算 ROM 大小，并换算成 GB 单位 * 一个 sector 的大小为 512Byte = 2048(512*8)bit * 以 16G 为例，先看看 16G 有几个 sector * 理论上有 16G = 16*1024M = 16*1024*1024K = 16*1024*1024*1024B = 16*1024*1024*2 sector * 将这个值 16*1024*1024*2 右移 20 位后得出 16*2=32 * 但实际上，没有这么多扇区，看后面 log 上打印出来的 size = 29 */ size = card-&gt;ext_csd.sectors &gt;&gt; 20; card-&gt;mmc_total_size = 1; while ((size &gt; 0) &amp;&amp; (size &gt;&gt; 1) &gt; 0) &#123; size = size &gt;&gt; 1; card-&gt;mmc_total_size = card-&gt;mmc_total_size * 2; &#125; // [ 6.691712] [Paul][EMMC] size = 29 // [ 6.691714] [Paul][EMMC] mmc_total_size = 16+ printk("[Paul][EMMC] size = %d\n"，size);+ printk("[Paul][EMMC] mmc_total_size = %d"，card-&gt;mmc_total_size); ... ... /* eMMC v4.5 or later */ if (card-&gt;ext_csd.rev &gt;= 6) &#123; // [ 6.691726] [Paul][EMMC] ext_csd[EXT_CSD_DATA_SECTOR_SIZE] = 0+ printk("[Paul][EMMC] ext_csd[EXT_CSD_DATA_SECTOR_SIZE] = %d"，ext_csd[EXT_CSD_DATA_SECTOR_SIZE]); // 这里根据 EXT_CSD_DATA_SECTOR_SIZE 确定一个扇区的大小 // 上面 log 说明扇区大小为 512Byte if (ext_csd[EXT_CSD_DATA_SECTOR_SIZE] == 1) card-&gt;ext_csd.data_sector_size = 4096; else card-&gt;ext_csd.data_sector_size = 512; &#125;&#125; 总结下就是:读取 eMMC Extended CSD 寄存器中的第 61 位获取到扇区大小，这里获取到的是 512KB/扇区。读取 eMMC Extended CSD 寄存器中的第 212~215 这四位获取到 eMMC 拥有的扇区数目。然后使用扇区大小乘以扇区数目，得到 ROM 容量，最后通过移位操作将得到的扇区容量换算成 GB 为单位的大小值。最后在 sys 节点中将这个计算出的 GB 为单位的大小值传递给上层。 扩展思考上面仅仅是实现了从 emmc 内部动态的读取出 ROM 的容量，那么如果我们要动态获取到 RAM 容量要怎么操作? 思路1: 通过读取 /proc/meminfo 节点，获取到 MemTotal 的大小对应的字符串(获取前27个字符)，通过解析这段字符串，得到 MemTotal 大小，再换算成 GB 单位即可。 1234567891011121314151617181920212223242526272829303132333435C:\Users\wangbing&gt;adb shell cat /proc/meminfoMemTotal: 1853224 kBMemFree: 28664 kBMemAvailable: 798400 kBBuffers: 30224 kBCached: 837224 kBSwapCached: 5068 kBActive: 808916 kBInactive: 480956 kBActive(anon): 387560 kBInactive(anon): 131520 kBActive(file): 421356 kBInactive(file): 349436 kBUnevictable: 105380 kBMlocked: 105380 kBSwapTotal: 633748 kBSwapFree: 556328 kBDirty: 0 kBWriteback: 0 kBAnonPages: 527880 kBMapped: 437540 kBShmem: 13324 kBSlab: 141104 kBSReclaimable: 53496 kBSUnreclaim: 87608 kBKernelStack: 32016 kBPageTables: 41228 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 1560360 kBCommitted_AS: 89069992 kBVmallocTotal: 244318144 kBVmallocUsed: 182136 kBVmallocChunk: 243976548 kB]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>eMMC</tag>
        <tag>sys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Tiny4412] 移植 Linux4.4 到 Tiny4412 开发板上]]></title>
    <url>%2F2018%2F03%2F19%2Ftiny4412-porting-linux4-4-support-dts%2F</url>
    <content type="text"><![CDATA[一. 前言一直以来都是基于 Linux-2.6 内核学习嵌入式，但是工作之后发现，主流的 kernel 早已经不再使用 platform device 结构去描述设备信息了，而是换成了更为简洁的 device tree 方式。 这里贴出 wowotech 的 device tree 的引言：作为一个多年耕耘在linux 2.6.23内核的开发者，各个不同项目中各种不同周边外设驱动的开发以及各种琐碎的、扯皮的俗务占据了大部分的时间。当有机会下载3.14的内核并准备学习的时候，突然发现linux kernel对于我似乎变得非常的陌生了，各种新的机制，各种framework、各种新的概念让我感到阅读内核代码变得举步维艰。 还好，剖析内核的热情还在，剩下的就交给时间的。首先进入视线的是Device Tree机制，这是和porting内核非常相关的机制，如果想让将我们的硬件平台迁移到高版本的内核上，Device Tree是一个必须要扫清的障碍。 参考文章：Device Tree 背景介绍 二. 移植 U-Boot本小节主要是修改 U-Boot 源码，让其支持 dts 方式启动内核。 2.1 获取 U-Boot 源码u-boot 使用的是友善之臂提供的 u-boot 源码，可以在友善之臂光盘获取。U-Boot 源码光盘路径：Disk-A\uboot\uboot_tiny4412-20130729.tgz 我同时上传了一份到我的 github 上，可以通过 git clone 获取到。 12345678910## 克隆 git 仓库获取源码user@lenovo:~/workspace/tiny4412$ git clone git@github.com:tiny4412/source.code.git## 进入 u-boot 源码目录user@lenovo:~/workspace/tiny4412$ cd source.code/uboot/friendlyarm/user@lenovo:~/workspace/tiny4412/source.code/uboot/friendlyarm$ lsuboot_tiny4412-20130729.tgz## 解压 u-bootuser@lenovo:~/workspace/tiny4412/source.code/uboot/friendlyarm$ tar -zxvf uboot_tiny4412-20130729.tgz -C ~/workspace/tiny4412/ 2.2 修改源码以支持 dts 方式启动前面已经提到，友善之臂光盘中提供的 u-boot 不支持引导 uImage 格式的 kernel，也不支持 device tree。针对这两个问题，对 u-boot 要做以下修改： 开启了 MMU 的话，u-boot 访问的都是虚拟地址，因为后期要使用 dnw 工具烧写文件到开发板 RAM 中，需要指定烧写到 RAM 中的具体物理地址，因此需要关闭 MMU。 123456789101112131415diff --git a/include/configs/tiny4412.h b/include/configs/tiny4412.hold mode 100644new mode 100755index 2e83d54..413da6e--- a/include/configs/tiny4412.h+++ b/include/configs/tiny4412.h@@ -308,7 +308,9 @@ #define CONFIG_SYS_MONITOR_LEN (256 &lt;&lt; 10) /* 256 KiB */ #define CONFIG_IDENT_STRING " for TINY4412" -#define CONFIG_ENABLE_MMU+#undef CONFIG_ENABLE_MMU #ifdef CONFIG_ENABLE_MMU #define CONFIG_SYS_MAPPED_RAM_BASE 0xc0000000 关闭 MMU 后，还需要修改 u-boot 的链接地址到真实物理地址范围内。 123456789101112diff --git a/board/samsung/tiny4412/config.mk b/board/samsung/tiny4412/config.mkold mode 100644new mode 100755index dd7ec07..cc3488e--- a/board/samsung/tiny4412/config.mk+++ b/board/samsung/tiny4412/config.mk@@ -9,5 +9,7 @@ # published by the Free Software Foundation. # #-CONFIG_SYS_TEXT_BASE = 0xc3e00000+CONFIG_SYS_TEXT_BASE = 0x43e00000 开启设备树相关功能宏控，使其支持设备树。 1234567891011121314diff --git a/include/configs/tiny4412.h b/include/configs/tiny4412.hindex 413da6e..b52dfa0 100755--- a/include/configs/tiny4412.h+++ b/include/configs/tiny4412.h@@ -28,6 +28,11 @@ #ifndef __CONFIG_H #define __CONFIG_H +#define CONFIG_OF_LIBFDT+#define CONFIG_SYS_BOOTMAPSZ (20 &lt;&lt; 20) /* * High Level Configuration Options * (easy to change) 原生的 u-boot 使用 bootm 命令只可以引导 zImage 类型的 kernel，不支持 uImage，通过修改 bootm 命令可以使其支持 uImage。 123456789101112131415161718192021222324252627282930313233343536373839diff --git a/common/cmd_bootm.c b/common/cmd_bootm.cold mode 100644new mode 100755index 04622dd..2cf6ea9--- a/common/cmd_bootm.c+++ b/common/cmd_bootm.c@@ -591,6 +591,10 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) int ret; boot_os_fn *boot_fn; + int iszImage = 0;+ #ifdef CONFIG_SECURE_BOOT #ifndef CONFIG_SECURE_BL1_ONLY security_check();@@ -627,6 +631,10 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) images.legacy_hdr_valid = 1; + iszImage = 1;+ goto after_header_check; &#125; #endif@@ -723,8 +731,14 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) #if defined(CONFIG_ZIMAGE_BOOT) after_header_check:- images.os.os = hdr-&gt;ih_os;- images.ep = image_get_ep (&amp;images.legacy_hdr_os_copy);++ if (iszImage) &#123;+ images.os.os = hdr-&gt;ih_os;+ images.ep = image_get_ep (&amp;images.legacy_hdr_os_copy);+ &#125;+ #endif #ifdef CONFIG_SILENT_CONSOLE 2.3 安装交叉编译器对于 kernel 和 u-boot 编译，最好使用同一个编译器，不妨在这 u-boot 编译之初，先配置一个同时支持 u-boot 以及 linux-4.4 版本的交叉编译器。我个人使用的是 arm-none-eabi-gcc 编译器，可以访问 GNU Arm Embedded Toolchain 获取，也可以通过我的 git 仓库获取。 123456789101112131415161718192021222324## 克隆 git 仓库获取交叉编译器user@lenovo:~/workspace/tiny4412$ git clone git@github.com:tiny4412/tool.chain.git## 找到交叉编译器user@lenovo:~/workspace/tiny4412$ cd tool.chain/compiler/user@lenovo:~/workspace/tiny4412/tool.chain/compiler$ lsgcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2## 解压到 /opt 目录user@lenovo:~$ sudo tar -jxvf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2 -C /opt/## 将交叉编译器路径添加到 PATH 环境变量中，并追加到配置文件中user@lenovo:~$ export PATH=/opt/gcc-arm-none-eabi-5_4-2016q3/bin:$PATH &gt;&gt; .bashrc## 执行配置文件，使环境变量生效user@lenovo:~$ . .bashrc## 查看交叉编译器版本号，确认交叉编译配置 okuser@lenovo:~$ arm-none-linux-gnueabi-gcc -vUsing built-in specs.Target: arm-none-linux-gnueabiConfigured with: /opt/FriendlyARM/mini2440/build-toolschain/working/src/gcc-4.4.3/configure --build=i386-build_redhat-linux-gnu --host=i386-build_redhat-linux-gnu --target=arm-none-linux-gnueabi --prefix=/opt/FriendlyARM/toolschain/4.4.3 --with-sysroot=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --enable-languages=c,c++ --disable-multilib --with-arch=armv4t --with-cpu=arm920t --with-tune=arm920t --with-float=soft --with-pkgversion=ctng-1.6.1 --disable-sjlj-exceptions --enable-__cxa_atexit --with-gmp=/opt/FriendlyARM/toolschain/4.4.3 --with-mpfr=/opt/FriendlyARM/toolschain/4.4.3 --with-ppl=/opt/FriendlyARM/toolschain/4.4.3 --with-cloog=/opt/FriendlyARM/toolschain/4.4.3 --with-mpc=/opt/FriendlyARM/toolschain/4.4.3 --with-local-prefix=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --disable-nls --enable-threads=posix --enable-symvers=gnu --enable-c99 --enable-long-long --enable-target-optspaceThread model: posixgcc version 4.4.3 (ctng-1.6.1) 2.4 配置编译 U-Boot修改 U-Boot 编译器为交叉编译器。 123456789101112131415diff --git a/Makefile b/Makefileold mode 100644new mode 100755index 48e8eaa..04e0132--- a/Makefile+++ b/Makefile@@ -157,7 +157,7 @@ export ARCH CPU BOARD VENDOR SOC # set default to nothing for native builds ifeq ($(HOSTARCH),$(ARCH))-CROSS_COMPILE ?=+CROSS_COMPILE ?= arm-none-eabi- endif # load other configuration 配置编译 U-Boot。 12345user@lenovo:~/workspace/tiny4412/uboot.support.dts$ make distclean user@lenovo:~/workspace/tiny4412/uboot.support.dts$ make clean user@lenovo:~/workspace/tiny4412/uboot.support.dts$ make tiny4412_configConfiguring for tiny4412 board...user@lenovo:~/workspace/tiny4412/uboot.support.dts$ make -j24 2.5 烧写 U-Boot 到 SD 卡在烧写的时候经常遇到这两个错误： 在 uboot 根目录下执行 sd_fusing.sh 脚本，报错如下： 1234567891011## 在 uboot 根目录下执行 sd_fusing.sh 脚本user@lenovo:~/workspace/tiny4412/uboot.support.dts$ sudo ./sd_fuse/tiny4412/sd_fusing.sh /dev/sdb/dev/sdb reader is identified.Error: u-boot.bin NOT found, please build it &amp; try again../sd_fuse/tiny4412/sd_fusing.sh: 49: exit: Illegal number: -1## 找不到 mkbl2 镜像user@lenovo:~/workspace/tiny4412/uboot.support.dts/sd_fuse/tiny4412$ sudo ./sd_fusing.sh /dev/sdb/dev/sdb reader is identified.Error: can not find host tool - mkbl2, stop../sd_fusing.sh: 54: exit: Illegal number: -1 在 uboot 根目录下执行 sd_fusing.sh 脚本报错是因为脚本中使用的相对路径访问的 uboot 镜像，只有在 src/sd_fuse/tiny4412/ 目录下执行，路径才对的上。另外找到 mkbl2 是因为执行 uboot 需要依赖 mkbl2。这个文件是三星官方给的，可以在 src/sd_fuse/ 目录下执行 make 生成。 1234user@lenovo:~/workspace/tiny4412/uboot.support.dts/sd_fuse/tiny4412$ cd ../user@lenovo:~/workspace/tiny4412/uboot.support.dts/sd_fuse$ makegcc -o mkbl2 V310-EVT1-mkbl2.c gcc -o sd_fdisk sd_fdisk.c 正确的烧写流程： 123456789101112131415161718192021222324252627282930user@lenovo:~/workspace/tiny4412/uboot.support.dts$ cd sd_fuse/user@lenovo:~/workspace/tiny4412/uboot.support.dts/sd_fuse$ makegcc -o mkbl2 V310-EVT1-mkbl2.c gcc -o sd_fdisk sd_fdisk.cuser@lenovo:~/workspace/tiny4412/uboot.support.dts/sd_fuse$ cd tiny4412/user@lenovo:~/workspace/tiny4412/uboot.support.dts/sd_fuse/tiny4412$ sudo ./sd_fusing.sh /dev/sdb/dev/sdb reader is identified.---------------------------------------BL1 fusing记录了16+0 的读入记录了16+0 的写出8192 bytes (8.2 kB, 8.0 KiB) copied, 0.096504 s, 84.9 kB/s---------------------------------------BL2 fusing记录了28+0 的读入记录了28+0 的写出14336 bytes (14 kB, 14 KiB) copied, 0.2371 s, 60.5 kB/s---------------------------------------u-boot fusing记录了569+1 的读入记录了569+1 的写出291484 bytes (291 kB, 285 KiB) copied, 2.68892 s, 108 kB/s---------------------------------------TrustZone S/W fusing记录了184+0 的读入记录了184+0 的写出94208 bytes (94 kB, 92 KiB) copied, 0.923827 s, 102 kB/s---------------------------------------U-boot image is fused successfully.Eject SD card and insert it again. 将 u-boot 下载 SD 卡后，将 SD 卡插入 Tiny4412 中，使用 SD 启动方式，可以进入 u-boot 命令行。 12345678910111213141516171819202122232425262728293031323334U-Boot 2010.12-00000-gef514bc-dirty (Mar 28 2018 - 21:58:58) for TINY4412CPU: S5PC220 [Samsung SOC on SMP Platform Base on ARM CortexA9] APLL = 1400MHz, MPLL = 800MHzBoard: TINY4412DRAM: 1023 MiBvdd_arm: 1.2vdd_int: 1.0vdd_mif: 1.1BL1 version: N/A (TrustZone Enabled BSP)Checking Boot Mode ... SDMMCREVISION: 1.1MMC Device 0: 7460 MBMMC Device 1: 3728 MBMMC Device 2: N/A*** Warning - using default environmentNet: No ethernet found.Hit any key to stop autoboot: 0 reading kernel..device 0 Start 1057, Count 12288 MMC read: dev # 0, block # 1057, count 12288 ... 12288 blocks read: OKcompletedreading RFS..device 0 Count 13345, Start 2048 MMC read: dev # 0, block # 13345, count 2048 ... 2048 blocks read: OKcompletedWrong Image Format for bootm commandERROR: can't get kernel image!TINY4412 # 在 u-boot 中执行以下命令，可以将 u-boot 从 sd 中拷贝到 emmc 中，以后便可以通过 emmc 启动了。但是很遗憾，我试验下来并不行，原因暂时没有找到。 12345678910111213141516171819## 将 u-boot 从 SD 卡复制到 DDR 中TINY4412 # mmc read 0 0x40000000 1 390MMC read: dev # 0, block # 1, count 912 ... 912 blocks read: OK## 打开 EMMCTINY4412 # emmc open 1eMMC OPEN Success.!! !!!Notice!!!!You must close eMMC boot Partition after all image writing!!eMMC boot partition has continuity at image writing time.!!So, Do not close boot partition, Before, all images is written.!## 将 DDR 地址中的 u-boot 写到 EMMCTINY4412 # mmc write 1 0x40000000 0 390MMC write: dev # 1, block # 0, count 912 ... 912 blocks written: OK## 关闭 EMMCTINY4412 # emmc close 1eMMC CLOSE Success.!! 三. 移植 Kernel主要是配置好 dts 移植好 usb 网卡驱动，这些操作我都已经做好了，可以直接访问 github 获取。具体的修改内容可以查看 github 仓库的提交记录。 123456789101112131415user@lenovo:~/workspace/tiny4412$ git clone git@github.com:tiny4412/linux-4.4.x.gituser@lenovo:~/workspace/tiny4412$ cd linux-4.4.x/## 清除内核配置user@lenovo:~/workspace/tiny4412/linux-4.4.x$ make distcleanuser@lenovo:~/workspace/tiny4412/linux-4.4.x$ make clean## 配置内核user@lenovo:~/workspace/tiny4412/linux-4.4.x$ make exynos_defconfig## 使配置生效，生成 .config 文件user@lenovo:~/workspace/tiny4412/linux-4.4.x$ make menuconfig## 开始编译user@lenovo:~/workspace/tiny4412/linux-4.4.x$ make -j24 uImage LOADADDR=0x40008000## 将内核 uImage 拷贝到根目录下，方便后面使用 dts 下载。user@lenovo:~/workspace/tiny4412/linux-4.4.x$ ./maziot.sh 'arch/arm/boot/dts/exynos4412-tiny4412.dtb' -&gt; './exynos4412-tiny4412.dtb''arch/arm/boot/uImage' -&gt; './uImage' 四. 构建根文件系统已经做好，可以直接访 github 获取。 1user@lenovo:~/workspace/tiny4412$ git clone git@github.com:tiny4412/rootfs.git 如何使用呢？ 开发板在 u-boot 中设置 bootargs 启动参数 123# nfs 启动方式的 root 属性格式为 nfsroot=&lt;服务器IP地址&gt;:&lt;服务器上的文件目录&gt; ip=&lt;开发板IP地址&gt;:&lt;服务器IP地址&gt;:&lt;网关&gt;:&lt;子网掩码&gt;::eth0:offsetenv bootargs 'root=/dev/nfs rw nfsroot=192.168.1.7:/home/user/workspace/tiny4412/rootfs ethmac=1C:6F:65:34:51:7E ip=192.168.1.100:192.168.1.7:192.168.1.1:255.255.255.0::eth0:off console=ttySAC0,115200 init=/linuxrc'save]]></content>
      <categories>
        <category>Tiny4412</category>
      </categories>
      <tags>
        <tag>tiny4412</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 客退按电源键无法熄屏]]></title>
    <url>%2F2018%2F03%2F18%2Fodm-power-key-can-not-close-screen%2F</url>
    <content type="text"><![CDATA[问题描述最近做的一个项目客退一台手机，不良现象为： 手机亮屏状态下，按 power key 无法熄屏。 亮屏状态下，长按 power key 功能正常。 手机接上 usb 或者 otg 线后，按 power key 可以正常熄屏。 解决思路很明显，差异点在 usb 上，查看 usb 相关的 log，发现 otg 插拔的 log 不断的在打印，说明 otg 检测这块有问题。 1234&lt;4&gt;[78943.472855] (4)[12294:kworker/4:4] report the otg cable in int event&lt;4&gt;[78943.506079] (4)[12294:kworker/4:4] report the otg cable out int event&lt;4&gt;[78943.586288] (4)[12294:kworker/4:4] report the otg cable in int event&lt;4&gt;[78943.613871] (4)[12294:kworker/4:4] report the otg cable out int event 这里虽然只贴出了4句，其实打了4000句都不止，一直在打印。 使用万用表量取开机状态下的 usb 各个引脚的电压，正常机器和异常机器各个引脚的电压值如下表： USB Pin Normal Normal OTG Normal charge Normal PC Bad Bad usb charge VBUS 0V 5V 5V 5V 0.7-2.3V 5V DM 0V 0V 0V 0V 0V 0V DP 0V 0V 0V 0V 0.35V 0V ID 1.8V 0V 1.8V 1.8V 0.35V 0V GND 0V 0V 0V 0V 0V 0V 这里的 VBUS 是在 0.7~2.3V 之间不断的跳变，而 USB host 会根据 VBUS 的边沿动作产生中断。 很明显，usb pin 硬件上出现了异常，看起来像 DP 和 ID 脚短接导致。用万用表量了一下，果然是 DP 和 ID 脚短接了。使用一台正常机器，短接 ID 和 DP 引脚，复现出不良现象。 背景知识OTG 插拔亮屏需求此项目有做 OTG 设备插拔时亮屏(唤醒屏幕)的需求。即，熄屏状态下插入或者拔出 OTG 设备，系统检测到 USB 设备则会唤醒屏幕。 OTG 设备检测原理该设备支持OTG，下面说下设备的发现过程： 作为从设备插入PC端口时： 系统检测到VBUS上的XEINT28上升沿触发中断，因为PC端会有一个5V从VBUS给过来，进入中断处理函数进一步确认ID脚状态，ID脚为低则状态错误，ID脚为高表示设备应该切换到从设备模式 通知usb gadget使能vbus，按照device模式使能PHY。gadget在probe时注册了一个SPI软中断IRQ_USB_HSOTG，用于响应数据接收 开启usb clk，使能PHY，此时外部5V电源供给系统XuotgVBUS，gadget收到IRQ_USB_HSOTG中断要求重启OTG core USB DP（高速设备为DP，低速设备为DM）上产生一个高电平脉冲，此时PC识别到一个USB设备插入，windows会提示用户 后续就是SETUP，GET DISCRIPTOR的过程 作为主设备发现设备插入时： 系统检测到ID脚上XEINT29下降沿触发中断（实际是插入的usb公口第四脚直接连接到第五脚地上面），进入中断处理，切换到主设备模式 关中断，使能DC5V给VBUS上电，唤醒ehci与ohci usb core在内核初始化时注册了一个名为khubd的内核线程，由khubd监控port event。（实际过程我理解是从设别由VUBS供电后，会在DP或DM上产生一个高电平脉冲ehci在接收到脉冲信号后识别到设备插入，仅仅是理解，这一点未验证） khubd获取port，speed后交给ehci，接下来就是usb的SETUP，GET DISCRIPTOR过程 MTK 回复USB设备插入拔出的动作，分Host、Device两种情况： 手机作为device，通过USB线连接到Host（比如PC），此时VBUS电压由PC提供，产生中断给手机，然后手机与PC端进行USB握手交互， 手机作为Host，通过USB OTG线连接到USB设备（比如u盘、鼠标），此时外设端将USB_ID信号接地，产生中断给手机，然后手机端通过Boost芯片产生5V VBUS电压给USB设备，并进行USB握手交互。 分析结论因此，此问题不是 power key 的问题，而是因为 DP 和 ID 短接，导致不断的触发 OTG 的插拔动作，OTG 不断的唤醒屏幕，导致屏幕无法熄屏。这也就解释了，为什么手机接上 usb 或者 otg 线后，按 power key 就可以正常熄屏。看表格中最后一列，接上 USB 设备后，USB 各个pin的电平是稳定的，不会触发OTG检测机制。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>mtk</tag>
        <tag>otg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Linux] 内核启动流程分析]]></title>
    <url>%2F2018%2F03%2F10%2Flinux-boot-flow%2F</url>
    <content type="text"><![CDATA[一. 内核编译初体验1.1 获取 Linux 内核视频和资料可以访问百问网论坛获取。下载好资料后在 “JZ2440资料光盘” 文件中可以获取到内核和对应的补丁文件。 内核源码包：光盘/system/linux-2.6.22.6.tar.bz2 内核补丁包：光盘/system/linux-2.6.22.6_jz2440.patch。 1.2 解压内核并给内核打补丁将获取到的内核文件放在虚拟机 ~/workspace/jz2440/package 目录下。 123user@vmware:~/workspace/jz2440/package$ tar -jxf linux-2.6.22.6.tar.bz2 -C ../user@vmware:~/workspace/jz2440/package$ cd ../linux-2.6.22.6/user@vmware:~/workspace/jz2440/linux-2.6.22.6$ patch -p1 &lt; ../package/linux-2.6.22.6_jz2440.patch 先介绍一下打补丁的方式： 1patch -pnum &lt; &lt;补丁文件&gt; 打到哪里补丁文件中会指出，-p 选项则表示忽略补丁文件的前级目录，num 表示忽略的目录级数。 1.3 配置内核方式一：通过 menu 菜单直接配置使用这种方式，从头到尾每一项都要我们自己配置。 1make menuconfig 方式二：使用默认配置文件配置，默认配置的文件位于：arch/arm/configs。12make s3c2440_defconfigmake menuconfig 方式三：使用厂家提供的配置文件配置。12cp config_ok .configmake menuconfig 所有的配置目的与结果都是生成一个 .config 文件，看看 .config 都有什么东西？随便截取一段出来看看： 12345678## Ethernet (10 or 100Mbit)#CONFIG_NET_ETHERNET=yCONFIG_MII=y# CONFIG_SMC91X is not setCONFIG_DM9000=y# CONFIG_CS89x0 is not set 不难看出 .config 文件中其实就是很多配置项，可以配置为 y、m 和数值，甚至有很多的配置项被注释掉了，后面跟着 is not set 字符串。为什么 is not set 格式还有必须要注释？这样约定格式有什么意义？ … … 待补充 1.4 开始编译内核直接 make 就可以执行编译的过程了，将会在 arch/arm/boot/zImage。但实际编译过程可能由于使用的交叉编译器工具链的区别会出现一些错误，请自行百度解决。或者使用 make uImage 编译生成 uImage，那么什么是 uImage？zImage 是 ARM Linux 常用的一种压缩映像文件，而 uImage 是 U-boot 专用的映像文件，它是在 zImage 之前加上一个长度为 0x40 的”头部”，说明这个映像文件的类型、加载位置、生成时间、大小等信息。换句话说，如果直接从 uImage 的 0x40 位置开始执行，zImage 和 uImage没有任何区别。另外，Linux2.4 内核不支持 uImage，Linux2.6 内核加入了很多对嵌入式系统的支持，uImage 在 u-boot 里用 bootm 加载，而 zImage 用 go 加载。 二. 内核实现剪裁的方式？2.1 追踪分析 CONFIG_DM9000 配置项我们都知道 Linux 是一个可剪裁的内核，内核具备哪些功能，我们可以手动配置，而配置内核我们之前已经了解过了，通过三种方式，最终通过 .config 文件确认内核具备哪些功能。我们以 CONFIG_DM9000 为例，看看内核是如何通过 .config 实现功能剪裁的。在 kernel 中 grep 搜索一下，看看 CONFIG_DM9000 这个宏出现在哪些文件中。 我们给出现 CONFIG_DM9000 宏的文件分个类，大概有此 4 类： C 语言源码 子目录的 Makefile include/config/auto.conf include/linux/autoconf.h 源码中使用到的宏定义只能是定义在 c 文件或者头文件中的，那很显然，源码中使用的宏定义就是在 include/linux/autoconf.h 文件中定义的。看看这个文件的内容，仍然以 CONFIG_DM9000 为例，截取一部分看看： 123#define CONFIG_DM9000 1#define CONFIG_SOLARIS_X86_PARTITION 1#define CONFIG_SERIAL_NONSTANDARD 1 如果你仔细的对比 .config 和 autoconf.h 文件，很容易发现这个规律： 配置为 y 的选项，在 autoconf.h 文件中被定义成为了一个值为 1 的宏。 配置为 m 的选项，在 autoconf.h 文件中没有被定义为宏。 配置为数值的选项，在 autoconf.h 文件中被定义成为了一个值为对应数值的宏。 接下来我们看看字目录下的 Makefile，在此此前先插播一下子目录的 makefile 的规则。子目录下的 Makefile 通常都是将源文件加入到编译命令中。一般的格式是这样的： 12obj-y += yyy.o # 静态方式编译进内核obj-m += mmm.o # 模块方式编译进内核 因此，子目录的 Makefile 多半是这样的(继续以 CONFIG_DM9000 为例)： 1obj-$(CONFIG_DM9000) += dm9dev9000c.o 很显然，子目录的 Makefile 是使用了 CONFIG_DM9000 变量，那 CONFIG_DM9000 变量是在哪里定义的呢？看来看去也就只能是在 include/config/auto.conf 文件定义了，但是 Makefile 中只能引用 Makefile 中定义的变量，这个 auto.conf 又是什么东西？子目录中如果真的引用了 auto.conf 文件的内容，那就只有一种可能，某个 Makefile 将 auto.conf 文件包含进 Makefile 中了。没错，还真的是这样，看看顶层 Makefile： 1-include include/config/auto.conf 这里尝试包含 auto.conf 文件。由于使用 -include 进行声明，所以即使这两个文件不存在也不会报错退出。 2.2 必要的总结一下配置的目的只有一个，根据我们想要内核具备的功能，通过配置项的方式，配置好并保存在 .config 文件中。而在编译的时候，会自动的创建 auto.conf 和 autoconf.h 两个文件，一个在源码中作为宏控开关量，控制着哪些代码被编译；一个在 Makefile 控制做为宏控开关量，控制着哪些文件被编译进内核。 三. 内核从哪里开始执行从 Makefile 开始分析，在顶层 Makefile 里面看看 make uImage 和 make 的过程： 12345# make uImagezImage Image xipImage bootpImage uImage: vmlinux# makeall: vmlinux 可以发现都是依赖 vmlinux，接下来再看看 vmlinux 依赖些什么？ 123456789101112131415161718192021222324252627282930313233vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCEvmlinux-init := $(head-y) $(init-y)head-y := arch/arm/kernel/head.o arch/arm/kernel/init_task.oinit-y := init/init-y := $(patsubst %/, %/built-in.o, $(init-y))最后会将 init 目录下的所有文件编译成为一个 init/built-in.ovmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)core-y := usr/core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/core-y := $(patsubst %/, %/built-in.o, $(core-y))最后编译结果为 usr/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ipc/built-in.o security/built-in.o crypto/built-in.o block/built-in.olibs-y := lib/libs-y := arch/arm/lib/ $(libs-y)libs-y := $(libs-y1) $(libs-y2)libs-y1 := $(patsubst %/, %/lib.a, $(libs-y))libs-y2 := $(patsubst %/, %/built-in.o, $(libs-y)最后编译结果为 lib/lib.a lib/built-in.odrivers-y := drivers/ sound/drivers-y := $(patsubst %/, %/built-in.o, $(drivers-y)最后编译结果为 drivers/built-in.o sound/built-in.onet-y := net/net-y := $(patsubst %/, %/built-in.o, $(net-y))最后编译结果为 net/built-in.ovmlinux-lds := arch/$(ARCH)/kernel/vmlinux.lds链接脚本位置 可以看出，vmlinux 将内核中的各个目录下编译出来的 .o 文件分成了几大类，最终几乎将所有的代码包含在 vmlinux 中。Make 追踪下来回比较麻烦，其实还有更简单粗暴的方法，直接根据 make 命令的控制台输出确认。通过在 make uImage 命令加一个 V=1 的属性值打印更详细的 log 信息。 123user@vmware:~/workspace/jz2440/linux-2.6.22.6$ rm -rf vmlinuxuser@vmware:~/workspace/jz2440/linux-2.6.22.6$ make uImage V=1 arm-linux-ld -EL -p --no-undefined -X -o vmlinux -T arch/arm/kernel/vmlinux.lds arch/arm/kernel/head.o arch/arm/kernel/init_task.o init/built-in.o --start-group usr/built-in.o arch/arm/kernel/built-in.o arch/arm/mm/built-in.o arch/arm/common/built-in.o arch/arm/mach-s3c2410/built-in.o arch/arm/mach-s3c2400/built-in.o arch/arm/mach-s3c2412/built-in.o arch/arm/mach-s3c2440/built-in.o arch/arm/mach-s3c2442/built-in.o arch/arm/mach-s3c2443/built-in.o arch/arm/nwfpe/built-in.o arch/arm/plat-s3c24xx/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ipc/built-in.o security/built-in.o crypto/built-in.o block/built-in.o arch/arm/lib/lib.a lib/lib.a arch/arm/lib/built-in.o lib/built-in.o drivers/built-in.o sound/built-in.o net/built-in.o --end-group .tmp_kallsyms2.o 最关键的一句，我没有分行，建议复制出来看看，和我们之前分析 Makefile 得出的结论是一致的。 通过上面的分析，得出两个结论： 最先执行文件：arch/arm/kernel/head.S 内核链接脚本：arch/arm/kernel/vmlinux.lds 四. 分析内核启动过程4.1 建立 source insight 工程 添加所有文件 删除 arch 目录 添加公用的代码arch/arm/boot/arch/arm/common/arch/arm/configs/arch/arm/kernel/arch/arm/lib/arch/arm/mach-s3c2410/arch/arm/mach-s3c2440/arch/arm/mm/arch/arm/nwfpe/arch/arm/oprofile/arch/arm/plat-s3c24xx/arch/arm/tools/arch/arm/vfp/ 删除 include 目录 添加非 asm 开头的目录include/acpi/include/config/include/crypto/include/Kbuildinclude/keys/include/linux/include/math-emu/include/media/include/mtd/include/net/include/pcmcia/include/rdma/include/rxrpc/include/scsi/include/sound/include/video/ 添加 include/asm-arm/ 目录下的文件(目录不添加) 添加 include/asm-arm/ 目录下的目录include/asm-arm/arch-s3c2410/include/asm-arm/hardware/include/asm-arm/plat-s3c24xx/include/asm-arm/mach/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 在 system 只读分区新增 shell 脚本]]></title>
    <url>%2F2018%2F03%2F05%2Fodm-add-file-to-system-partition%2F</url>
    <content type="text"><![CDATA[问题来源电力达人需求需要动态的控制 AAL 的 CABC。客户需求，电力达人切换手机工作模式的时候会自动调用 /system/etc/ 目录下的脚本文件，而这些脚本需要我们实现。 解决思路 参考指纹 ca ta 的拷贝，将文件拷贝到 src/out/ 下目标目录中。 参考指纹赋权限的方式，在 init.rc 中追加 sh 脚本的权限。 实现方式第一步：将脚本放入代码工程中 随便放在哪个目录里面都是可以的。 123alps\kernel-3.18\drivers\misc\mediatek\video\common\aal20\aal_shell\pwr-balance.shalps\kernel-3.18\drivers\misc\mediatek\video\common\aal20\aal_shell\pwr-normal.shalps\kernel-3.18\drivers\misc\mediatek\video\common\aal20\aal_shell\pwr-ultra.sh 第二步：修改 device.mk 文件, 将脚本拷贝到 /system/etc 目录下 在 alps\device\ginreen\”ProjectName”\device.mk 追加: 123PRODUCT_COPY_FILES += kernel-3.18/drivers/misc/mediatek/video/common/aal20/aal_shell/pwr-normal.sh:system/etc/pwr-normal.shPRODUCT_COPY_FILES += kernel-3.18/drivers/misc/mediatek/video/common/aal20/aal_shell/pwr-balance.sh:system/etc/pwr-balance.shPRODUCT_COPY_FILES += kernel-3.18/drivers/misc/mediatek/video/common/aal20/aal_shell/pwr-ultra.sh:system/etc/pwr-ultra.sh 源文件于目标文件通过冒号分隔, 冒号前是源文件, 冒号后是目标文件。源文件默认根目录是 alps 目录, 目标文件默认根目录是 alps\out\target\product\”ProjectName” 目录。 第三步：修改 init.mt6755.rc 文件, 给脚本设置执行权限 可以修改以下这几个文件，这里我是修改的 init.mt6755.rc 文件。 123alps\device\mediatek\mt6755\init.mt6755.rcalps\device\ginreen\&quot;ProjectName&quot;\init.project.rcalsp\system\core\rootdir\init.rc 在 alps\device\mediatek\mt6755\init.mt6755.rc 文件中追加一项： 1234on init chmod 0755 /system/etc/pwr-balance.sh chmod 0755 /system/etc/pwr-normal.sh chmod 0755 /system/etc/pwr-ultra.sh 发现文件成功拷贝到了 /system/etc/ 目录下，但是赋的权限并没有生效。说明直接参考指纹赋权限的方式不行。接下来找原因，参考 online 的文档，找到原因，是因为 /system/ 分区是只读分区，分区挂载后，就没有修改文件的能力，包括改权限都改不了。需要在文件系统挂载之前，先挂在为 rw 的权限，修改好脚本的权限后再重新挂在为 ro。就像这样操作： 123456on init mount ext4 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/system /system rw wait chmod 0755 /system/etc/pwr-balance.sh chmod 0755 /system/etc/pwr-normal.sh chmod 0755 /system/etc/pwr-ultra.sh unmount /system 但是还是发现权限没有成功赋上。后续提交 case 给 MTK 无果。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>system</tag>
        <tag>mtk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 动态开启关闭 LTE CA band]]></title>
    <url>%2F2018%2F02%2F26%2Fodm-dynamic-control-LTE-CA-band%2F</url>
    <content type="text"><![CDATA[问题描述客户在定义项目的时候，之前单软多硬仅仅做了三个 modem 模块。但是后来客户又要求要求在 TW 的基础上删除 LTE band，再克制化一个 modem。 解决思路(1) 再克制化一个 modem，增加一个单软多硬的 modem 参考 MTK online [FAQ19715] How to disable/enable CA for LTE-A。可以修改 modem 端直接关闭 CA。但是需要多一个 modem 版本配置，需要通过单软多硬实现。但是倘若使用单软多硬再多加一个配置的话，需要较大的管控力度。 (2) 使用 AT command 在 AP 端动态的开关 CA band 可以通过 AT+ECASW 来开关 CA 功能，该 AT command 设定后会写入 NVRAM，但是需要重启或是 EFUN=0 -&gt; 1 之后使用的参数会生效。命令格式如下： 1234567891011AT+ECASW – LTE CA switch (Proprietary Command)Description To turn on/off LTE CA.Command FormatCommand Response+ECASW=&lt;mode&gt;+ECASW? +ECASW: &lt;mode&gt;+ECASW=? +ECASW: (list of supported &lt;mode&gt;s)Field&lt;mode&gt;: integer 0 – turn off LTE CA 1 – turn on LTE CA 思路验证联想到客户售后指令就是通过 AT 和 NV 交互获取 NV 的信息。因此想增加一个 PhoneInfoTest 的子命令实现 CA 的关闭和开启。不料却发现，根本不需要这么干，PhoneInfoTest 里面的 command 24 就是 AT command 的接口，使用下面格式可以直接执行 AT command，但是要求要是 eng 的版本才有权限。 1C:\Users\wangbing&gt;adb shell /data/data/PhoneInfoTest 88 0 "AT command" 客户售后指令 PhoneInfoTest 里面支持 AT command，使用 eng 版本的手机，进入 adb 执行以下命令关闭 LTE CA。 1234567891011121314C:\Users\wangbing&gt;adb shellandroid:/ # /data/data/PhoneInfoTest 88 0 AT+ECASW=0android:/ # /data/data/PhoneInfoTest 88 0 AT+ECASW=0 debug&lt;&lt;adb&gt;&gt; command: 24,adbcmd:880,atoi(cmd1)=88,atoi(cmd1)=0&lt;&lt;adb&gt;&gt; ATsend 387&lt;&lt;adb&gt;&gt; AT: AT+ECASW=0&lt;&lt;adb&gt;&gt; connectTarget 156,connc_socket=1&lt;&lt;adb&gt;&gt; single modem mode and try to connect socket 1.&lt;&lt;adb&gt;&gt; sendDataToRild(AT+ECASW=0) 121&lt;&lt;adb&gt;&gt; rx...&lt;&lt;adb&gt;&gt; rx... got len: 6 rx:OK&lt;&lt;adb&gt;&gt;OK 接下来就是给射频验证了，看看使用 AT command 关闭 CA 是否生效。射频给出答复，关闭 CA 生效了。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>mtk</tag>
        <tag>modem</tag>
        <tag>AT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ODM] 开机卡死在 android logo 界面]]></title>
    <url>%2F2018%2F02%2F09%2Fodm-boot-stopped-at-android-logo%2F</url>
    <content type="text"><![CDATA[问题描述最近做的一个 MTK 平台的项目客退一台手机，不良现象为: 开机卡死在 android logo 界面，无法正常进入系统。 背景知识android 手机开机一般都有三帧 boot logo，第一帧是 “Power by android”，第二帧一般是各个手机品牌商的品牌 logo，第三帧就是定制的开机动画了。此问题是没有跳转到第二帧，卡死在第一帧，所以关键看第一帧到第二帧期间哪里出了问题。 贴出同事总结的 Android logo 加载流程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173[第一张 logo 显示在 lk 启动流程中介绍][第二张 logo 初始化显示位置]alps\device\mediatek\mt6755\init.mt6755.rc# Update the second boot logoservice bootlogoupdater /vendor/bin/boot_logo_updater class core oneshot // vendor\mediatek\proprietary\external\boot_logo_updater\boot_logo_updater.cmain(void) // 获得启动模式，即启动的原因，并设置相应的属性节点值 int ret = update_boot_reason(); fd = open(BOOT_MODE_PATH, O_RDWR); // /sys/class/BOOT/BOOT/boot/boot_mode s = read(fd, (void *)&amp;boot_mode, sizeof(boot_mode)); property_get(BOOT_PACKAGE_SYS_PROPERTY, propVal, "0"); // sys.boot.reason" property_set(BOOT_REASON_SYS_PROPERTY, propVal); // persist.sys.bootpackage // 设置背光亮度 set_int_value(LCD_BACKLIGHT_PATH, 120); // /sys/class/leds/lcd-backlight/brightness write_to_file(path, buf, strlen(buf)); int fd = open(path, O_RDWR); int count = write(fd, buf, size); close(fd); // 都不在文件中了：查看 Android.mk // LOCAL_C_INCLUDES += $(LOCAL_PATH)/../libshowlogo/ // 最终此文件中找到了对应的函数实现，代码路径为： // vendor\mediatek\proprietary\external\libshowlogo set_draw_mode(DRAW_ANIM_MODE_FB); //Charging_animation.cpp set_draw_mode(int draw_mode) // 设置显示模式全局变量，有两种显示模式 // #define DRAW_ANIM_MODE_FB 1 // #define DRAW_ANIM_MODE_SURFACE 0 draw_anim_mode = draw_mode; // 获得对应平台的 fstab 文件，获得 logo.img 挂载位置，然后读取 logo // 然后初始化显示设备，有两种显示方式： // 1. 直接在 fb 内核中显示 // 2. 在 surface 中显示 anim_init(); //Charging_animation.cpp anim_init() // 获得对应平台的 fstab 文件，然后获得其挂载分区 /logo // 读取对应的 logo 镜像文件 anim_logo_init(); int ret = property_get("ro.hardware", propbuf, ""); snprintf(fstab_filename, sizeof(fstab_filename), FSTAB_PREFIX"%s", propbuf); fstab = fs_mgr_read_fstab(fstab_filename); rec = fs_mgr_get_entry_for_mount_point(fstab, LOGO_MNT_POINT); fd = open(rec-&gt;blk_device, O_RDONLY); logo_addr = (unsigned int*)malloc(LOGO_BUFFER_SIZE); // (1) skip the image header len = read(fd, logo_addr, 512); // get the image len = read(fd, logo_addr, LOGO_BUFFER_SIZE - 512); close(fd); // 1. 在 fb 中显示 logo if (draw_anim_mode == (DRAW_ANIM_MODE_FB)) &#123; anim_fb_init(); // 打开 fb0, fb_fd = open(FB_NODE_PATH, O_RDWR); // 获得屏相关的信息参数 ioctl(fb_fd, FBIOGET_VSCREENINFO, &amp;vinfo); ioctl(fb_fd, FBIOGET_FSCREENINFO, &amp;finfo); // 将显示屏映射到进程的地址空间中 fb_size = finfo.line_length * vinfo.yres; dec_logo_addr = (unsigned int*) malloc(fb_size); lk_fb_addr =(unsigned int*)mmap(0, fb_size*3, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0); charging_fb_addr = (unsigned int*)((unsigned int)lk_fb_addr + fb_size); kernel_fb_addr = (unsigned int*)((unsigned int)charging_fb_addr + fb_size); fb_addr = lk_fb_addr; // 设置本地的屏的相关参数 phical_screen.bits_per_pixel = vinfo.bits_per_pixel; phical_screen.fill_dst_bits = vinfo.bits_per_pixel; phical_screen.red_offset = vinfo.red.offset; phical_screen.blue_offset = vinfo.blue.offset; phical_screen.width = vinfo.xres; phical_screen.height = vinfo.yres; phical_screen.allignWidth = finfo.line_length/(vinfo.bits_per_pixel/8); phical_screen.needAllign = 1; phical_screen.need180Adjust = 1; phical_screen.fb_size = fb_size; // 设置旋转参数 if(0 == strncmp(MTK_LCM_PHYSICAL_ROTATION, "270", 3)) 。。。 phical_screen.rotation = 270; // 2. 在 surface 中显示 logo 初始化 &#125; else &#123; anim_surface_init(); surfaceControl = client-&gt;createSurface(String8("charging-surface"), dinfo_width, dinfo_height, PIXEL_FORMAT_BGRA_8888); SurfaceComposerClient::openGlobalTransaction(); surfaceControl-&gt;setLayer(2000000); SurfaceComposerClient::closeGlobalTransaction(); // data structure to access surface content surface = surfaceControl-&gt;getSurface(); phical_screen.width = dinfo.w; phical_screen.height = dinfo.h; // for we adjust the roration avove, so no need to consider rotation phical_screen.rotation = 0; phical_screen.need180Adjust = 0; ANativeWindow* window = surface.get(); status_t result = native_window_api_connect(window, NATIVE_WINDOW_API_CPU); err = window-&gt;dequeueBuffer(window, &amp;buf, &amp;fenceFd); sp&lt;Fence&gt; mFence(new Fence(fenceFd)); mFence-&gt;wait(Fence::TIMEOUT_NEVER); gb = new GraphicBuffer(buf, false); phical_screen.needAllign = 1; phical_screen.allignWidth = gb-&gt;getStride(); window-&gt;cancelBuffer(window, buf, fenceFd); // use PIXEL_FORMAT_RGBA_8888 for surface flinger phical_screen.bits_per_pixel = 32; phical_screen.fill_dst_bits = 32; fb_size = dinfo.w * dinfo.h* 4; dec_logo_addr = malloc(fb_size); phical_screen.fb_size = fb_size; &#125; // 显示 logo, 其实就是 // 1. 从 logo.img 中读出对应的 logo // 2. 将 logo 填充到显示缓冲区中即可 show_kernel_logo(); anim_show_logo(kernel_logo_position); // 此参数为 kernel logo 在 logo.img 中的 index ，static int kernel_logo_position = KERNEL_LOGO_INDEX ; if (draw_anim_mode == (DRAW_ANIM_MODE_FB)) &#123; anim_set_buffer_address(index); fill_animation_logo(index, fb_addr, dec_logo_addr, logo_addr,phical_screen); // 显示图片 anim_fb_disp_update(); &#125; else &#123; ARect tmpRect; tmpRect.left = 0; tmpRect.top = 0; tmpRect.right = phical_screen.width; tmpRect.bottom = phical_screen.height; status_t lockResult = surface-&gt;lock(&amp;outBuffer, &amp;tmpRect); SLOGD("[libshowlogo: %s %d]outBuffer.bits = %d\n",__FUNCTION__,__LINE__, (int)outBuffer.bits); SLOGD("[libshowlogo: %s %d]surface-&gt;lock return = 0x%08x, %d\n",__FUNCTION__,__LINE__,lockResult,lockResult); if (0 == lockResult) &#123; fill_animation_logo(index, (void *)outBuffer.bits, dec_logo_addr, logo_addr,phical_screen);// 显示图片 surface-&gt;unlockAndPost(); &#125; &#125; // 相关资源的释放 anim_deinit(); anim_logo_deinit(); free_fstab(); free(logo_addr); logo_addr = NULL; free(dec_logo_addr); if (draw_anim_mode == (DRAW_ANIM_MODE_FB)) &#123; anim_fb_deinit(); munmap(lk_fb_addr, fb_size*3); close(fb_fd); &#125; else &#123; anim_surface_deinit(); surface = surfaceControl-&gt;getSurface(); ANativeWindow* window = surface.get(); native_window_api_disconnect(window,NATIVE_WINDOW_API_CPU); surfaceControl-&gt;clear(); client-&gt;dispose(); &#125; 分析思路(1) 先回读镜像，回读了 pl lk boot(但不知道手机的软件版本)，通过和正式版本的镜像对比，发现回读的镜像和 WW B18 一致，确认到手机软件版本为 WW B18。(2) 和 WW B18 的镜像对比，发现 pl lk boot 镜像和版本中的镜像一致，没有损坏。(3) 焊接串口，抓取串口 log，通过 fastboot 在 user 版本下抓取完整的开机 uart log。 12C:\Users\wangbing&gt;fastboot oem p2u onC:\Users\wangbing&gt;fastboot continue (4) 对比不良机和正常机开机串口 log，发现，不良机在 init 进程中找不到 boot_logo_updater，没有正常启动 boot_logo_updater 程序(此服务用于加载 kernel 阶段的 boot logo，对应开机的客户品牌 logo 图片)。 1234567891011[ 5.119985] &lt;5&gt;.(5)[1:init]init: Starting service &apos;healthd&apos;...[ 5.121544] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/boot_logo_updater&apos; (No such file or directory), disabling &apos;bootlogoupdater&apos;[ 5.123102] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/wmt_loader&apos; (No such file or directory), disabling &apos;wmt_loader&apos;[ 5.124484] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/wmt_launcher&apos; (No such file or directory), disabling &apos;wmt_launcher&apos;[ 5.125082] &lt;5&gt;.(4)[314:healthd]binder: 314:314 binder_context_mgr_node is NULL[ 5.125087] &lt;5&gt;.(4)[314:healthd]binder: 314:314 transaction failed 29189, size 0-0[ 5.125094] &lt;5&gt;.(4)[314&apos;(ndor/bin/ccci_mdinit&apos; (No such file or directory), disabling &apos;ccci_mdinit&apos;[ 5.133184] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/ccci_fsd&apos; (No such file or directory), disabling &apos;ccci3_fsd&apos;[ 5.134526] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/ccci_mdinit&apos; (No such file or directory), disabling &apos;ccci3_mdinit&apos;[ 5.135973] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/ccci_rpcd&apos; (No such file or directory), disabling &apos;ccci_rpcd&apos;[ 5.137324] &lt;5&gt;.(5)[1:init]init: cannot find &apos;/vendor/bin/terservice&apos; (No such file or directory), disabling &apos;terservice&apos; (5) boot_logo_updater 服务编译版本后会打包在 /system/vendor/bin 目录下，而 /vendor/bin/ 是通过软链接方式链接到 /system/vendor/bin 目录的。 123C:\Users\wangbing&gt;adb shellandroid:/ # ls -l vendorlrwxrwxrwx 1 root root 14 1970-01-01 08:00 vendor -&gt; /system/vendor (6) boot_logo_update 程序打不开，有两个怀疑点，要么是 /system/vendor/bin 目录下的执行文件有问题，要么是从 /vendor/ 到 /system/vendor/ 的软链接没有生效。(7) 试图连接下 adb，想确认下软连接有没有生效，很遗憾，无法连接。(8) 回读不良机的 system 镜像，使用 ext2explore.exe 解压确认，发现不良原因确实是 boot_logo_updater 损坏，导致无法加载第二帧 logo。 分析结论客退机 system 分区损坏，导致无法加载 boot_logo_updater 程序引导第二帧 boot logo；同时 init 进程无法成功执行，导致无法开机。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>boot</tag>
        <tag>system</tag>
        <tag>mtk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Protocol] MIPI 协议扫盲]]></title>
    <url>%2F2018%2F01%2F27%2Fprotocol-mipi-eliminate-illiteracy%2F</url>
    <content type="text"><![CDATA[MIPI扫盲 - What the hell is mipi？ MIPI扫盲 - D-PHY介绍（一） MIPI扫盲 - D-PHY介绍（二） MIPI扫盲 - CSI-2介绍（一） MIPI扫盲 - CSI-2介绍（二） MIPI扫盲 - CSI-2介绍（三） MIPI扫盲 - CSI-2介绍（四） MIPI扫盲 - DBI介绍 MIPI扫盲 - DCS介绍 MIPI扫盲 - DSI介绍（一） MIPI扫盲 - DSI介绍（二） MIPI扫盲 - Lattice CrossLink介绍 MIPI扫盲 - Lattice CSI-2 / DSI DPHY Receiver IP介绍]]></content>
      <categories>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>mipi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[U-Boot] 如何获取最新的 U-Boot]]></title>
    <url>%2F2018%2F01%2F24%2Fu-boot-get-latest-u-boot%2F</url>
    <content type="text"><![CDATA[一. U-Boot 简介1.1 U-Boot 是什么？U-Boot，全称 Universal Boot Loader，是遵循 GPL 条款的开源项目。U-Boot 是一种普遍用于嵌入式系统中的 BootLoader。 1.2 BootLoader 又是什么？Bootloader 的定义：Bootloader 是在操作系统运行之前执行的一小段程序，通过这一小段程序，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。意思就是说如果我们要想让一个操作系统在我们的板子上运转起来，我们就必须首先对我们的板子进行一些基本配置和初始化，然后才可以将操作系统引导进来运行。BootLoader 的主要运行任务就是将内核映象从硬盘上读到 RAM 中，然后跳转到内核的入口点去运行，即开始启动操作系统。 1.3 Windows 电脑和嵌入式设备启动流程对比PC 机上电启动流程：上电 -&gt; BIOS -&gt; Windows -&gt; 识别 C盘、D盘 嵌入式设备上电启动流程：上电 -&gt; BootLoader -&gt; Linux Kernel -&gt; 挂载根文件系统 二. 获取最新的 U-Boot访问 U-Boot 官网：http://www.denx.de/wiki/U-Boot/WebHome 点击 Source Code，进入源码界面。这里提示说要获取 U-Boot 的发布版本可以通过 FTP 服务器。 点击 FTP Server 进入 FTP 服务器文件列表界面。这里有各个版本的 U-Boot，当然也就包括最新版。 其实可以直接访问 FTP Server 获取各个版本的 U-Boot。]]></content>
      <categories>
        <category>U-Boot</category>
      </categories>
      <tags>
        <tag>u-boot</tag>
        <tag>bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Git] Git 的安装及配置]]></title>
    <url>%2F2018%2F01%2F23%2Fgit-how-to-use-git%2F</url>
    <content type="text"><![CDATA[一. 安装配置 git1. Ubuntu 下安装 git1user@ubuntu:~$ sudo apt-get install git 2. 配置邮箱和用户名12user@ubuntu:~$ git config --global user.name mz8023ytuser@ubuntu:~$ git config --global user.email mz8023yt@163.com 3. 配置命令别名12user@ubuntu:~$ git config --global alias.st statususer@ubuntu:~$ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt; %Creset' --abbrev-commit" 4. 生成 ssh 秘钥对1user@ubuntu:~$ ssh-keygen -t rsa -C mz8023yt@163.com 5. 将 shh 公钥添加到代码托管平台1user@ubuntu:~$ cat ~/.ssh/id_rsa.pub 登录 github、coding、oschina，添加 shh 公钥。将 cat 打印出来的 id_rsa.pub 公钥添加到托管平台账户中。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 内核调试手段之 printk]]></title>
    <url>%2F2018%2F01%2F23%2Fmini2440-printk%2F</url>
    <content type="text"><![CDATA[一. 内核打印函数 printk 介绍1.1 前言内核提供了 printk 函数在内核运行时打印信息，类似于 C 语言中的 printf 函数。 使用方式： 1printk(&lt;日志级别&gt; "打印内容"); 什么是日志级别? 日志级别表示这句 log 的严重等级，总共有 8 个级别，分别是 0-7，数字越小级别越高。kernel 中可以设置屏蔽一些低级别的 log 不打印出来。printk 的日志级别定义在 linux-2.6.32.2/inlcude/linux/kernel.h 中： 12345678#define KERN_EMERG "&lt;0&gt;" /* system is unusable */ #define KERN_ALERT "&lt;1&gt;" /* action must be taken immediately */ #define KERN_CRIT "&lt;2&gt;" /* critical conditions */ #define KERN_ERR "&lt;3&gt;" /* error conditions */ #define KERN_WARNING "&lt;4&gt;" /* warning conditions */ #define KERN_NOTICE "&lt;5&gt;" /* normal but significant condition */ #define KERN_INFO "&lt;6&gt;" /* informational */ #define KERN_DEBUG "&lt;7&gt;" /* debug-level messages */ 简单解释一下： 紧急事件消息，系统崩溃前的提示，表示系统不可用 报告事件，表示必须立刻采取措施 临界条件，通常涉及严重的硬件或软件失败 错误条件，驱动程序通常用此等级报告硬件错误 警告条件，对可能出现的问题进行警告 正常又重要的信息，用于提醒 提示信息，打印运行时的提示信息 调试信息，调试级别的消息 Kernel 中可以修改 /proc/sys/kernel/printk 节点修改 printk 打印相关的配置。 12[root@FriendlyARM /]# cat /proc/sys/kernel/printk7 4 1 7 其实这四个值是在kernel/printk.c 中被定义的，这四个数值分别表示： 123456int console_printk[4] = &#123; DEFAULT_CONSOLE_LOGLEVEL, /* console_loglevel 7 */ DEFAULT_MESSAGE_LOGLEVEL, /* default_message_loglevel 4 */ MINIMUM_CONSOLE_LOGLEVEL, /* minimum_console_loglevel 1 */ DEFAULT_CONSOLE_LOGLEVEL, /* default_console_loglevel 7 */&#125;; 简单解释一下： 当前控制台日志级别：优先级高于该值的消息将被打印至控制台 默认的消息日志级别：将用该优先级来打印没有优先级的消息 最高的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级) 默认的控制台日志级别：控制台日志级别的缺省值 当 printk 的消息日志级别小于当前控制台日志级别 DEFAULT_CONSOLE_LOGLEVEL 时，才会被打印出来。 1.2 示例模块文件一：print_level.c1234567891011121314151617181920212223242526272829303132#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;static int __init mod_init(void)&#123; printk(KERN_EMERG "hello! KERN_EMERG = %s\n", KERN_EMERG ); printk(KERN_ALERT "hello! KERN_ALERT = %s\n", KERN_ALERT ); printk(KERN_CRIT "hello! KERN_CRIT = %s\n", KERN_CRIT ); printk(KERN_ERR "hello! KERN_ERR = %s\n", KERN_ERR ); printk(KERN_WARNING "hello! KERN_WARNING = %s\n", KERN_WARNING); printk(KERN_NOTICE "hello! KERN_NOTICE = %s\n", KERN_NOTICE ); printk(KERN_INFO "hello! KERN_INFO = %s\n", KERN_INFO ); printk(KERN_DEBUG "hello! KERN_DEBUG = %s\n", KERN_DEBUG ); return 0;&#125;static void __exit mod_exit(void)&#123; printk(KERN_EMERG "goodbye! KERN_EMERG = %s\n", KERN_EMERG ); printk(KERN_ALERT "goodbye! KERN_ALERT = %s\n", KERN_ALERT ); printk(KERN_CRIT "goodbye! KERN_CRIT = %s\n", KERN_CRIT ); printk(KERN_ERR "goodbye! KERN_ERR = %s\n", KERN_ERR ); printk(KERN_WARNING "goodbye! KERN_WARNING = %s\n", KERN_WARNING); printk(KERN_NOTICE "goodbye! KERN_NOTICE = %s\n", KERN_NOTICE ); printk(KERN_INFO "goodbye! KERN_INFO = %s\n", KERN_INFO ); printk(KERN_DEBUG "goodbye! KERN_DEBUG = %s\n", KERN_DEBUG );&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件二：Makefile1234567891011121314obj-m += print_level.oKERNEL = /home/user/workspace/mini2440/linux-2.6.32.2SHARE = /home/user/boardall: make -C $(KERNEL) M=`pwd` modules rm -rf $(SHARE)/* cp -f *.ko $(SHARE)/ make clean @echo "\033[31m &gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt; \033[0m"clean: make -C $(KERNEL) M=`pwd` modules clean rm -f app 1.3 加载模块加载卸载模块打印的信息： 12345678910111213141516[root@FriendlyARM /mnt]# insmod print_level.ko hello! KERN_EMERG = &lt;0&gt;hello! KERN_ALERT = &lt;1&gt;hello! KERN_CRIT = &lt;2&gt;hello! KERN_ERR = &lt;3&gt;hello! KERN_WARNING = &lt;4&gt;hello! KERN_NOTICE = &lt;5&gt;hello! KERN_INFO = &lt;6&gt;[root@FriendlyARM /mnt]# rmmod print_levelgoodbye! KERN_EMERG = &lt;0&gt;goodbye! KERN_ALERT = &lt;1&gt;goodbye! KERN_CRIT = &lt;2&gt;goodbye! KERN_ERR = &lt;3&gt;goodbye! KERN_WARNING = &lt;4&gt;goodbye! KERN_NOTICE = &lt;5&gt;goodbye! KERN_INFO = &lt;6&gt; 修改控制台日志级别： 123[root@FriendlyARM /mnt]# cat /proc/sys/kernel/printk7 4 1 7[root@FriendlyARM /mnt]# echo 4 4 1 7 &gt; /proc/sys/kernel/printk 修改后加载卸载模块打印的信息： 1234567891011[root@FriendlyARM /mnt]# dmesg -c &gt; 0 # 清空缓冲区 [root@FriendlyARM /mnt]# insmod print_level.ko hello! KERN_EMERG = &lt;0&gt;hello! KERN_ALERT = &lt;1&gt;hello! KERN_CRIT = &lt;2&gt;hello! KERN_ERR = &lt;3&gt;[root@FriendlyARM /mnt]# rmmod print_level goodbye! KERN_EMERG = &lt;0&gt;goodbye! KERN_ALERT = &lt;1&gt;goodbye! KERN_CRIT = &lt;2&gt;goodbye! KERN_ERR = &lt;3&gt; 可以看出，只打印了 0-3 级别的 log 信息，完整的 log 信息可以用 dmesg 查看。dmesg 命令被用于检查和控制内核的环形缓冲区。kernel 会将运行时的打印信息存储在 ring buffer 中。没有及时查看到的信息，可利用 dmesg 来查看。 1234567891011121314151617[root@FriendlyARM /mnt]# dmesg hello! KERN_EMERG = &lt;0&gt;hello! KERN_ALERT = &lt;1&gt;hello! KERN_CRIT = &lt;2&gt;hello! KERN_ERR = &lt;3&gt;hello! KERN_WARNING = &lt;4&gt;hello! KERN_NOTICE = &lt;5&gt;hello! KERN_INFO = &lt;6&gt;hello! KERN_DEBUG = &lt;7&gt;goodbye! KERN_EMERG = &lt;0&gt;goodbye! KERN_ALERT = &lt;1&gt;goodbye! KERN_CRIT = &lt;2&gt;goodbye! KERN_ERR = &lt;3&gt;goodbye! KERN_WARNING = &lt;4&gt;goodbye! KERN_NOTICE = &lt;5&gt;goodbye! KERN_INFO = &lt;6&gt;goodbye! KERN_DEBUG = &lt;7&gt; 二. 封装 printk 打造一个专属的打印函数2.1 前言每次调试的时候都要加行号，加函数名调试，实在是太麻烦了，为什么不自己封装一个专属的 print log 的函数呢? 1#define log(fmt, arg...) printk(KERN_INFO "[Paul][%s][%d] "fmt"\n", __func__, __LINE__, ##arg); 其中 __func__ __LINE__ 分别表示当前函数名和行号。 2.2 示例模块文件一：log_module.c12345678910111213141516171819202122232425262728#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;/* simple log */#define log(fmt, arg...) printk(KERN_INFO "[Paul][%s][%d] "fmt"\n", __func__, __LINE__, ##arg);#define err(fmt, arg...) printk(KERN_ERR "[Paul][%s][%d] ERROR!!! "fmt"\n", __func__, __LINE__, ##arg);/* detail log */#define dbg(fmt, arg...) printk(KERN_INFO "%s:\n[Paul][%s][%d] "fmt"\n", __FILE__, __func__, __LINE__, ##arg);static int __init mod_init(void)&#123; log("hello everyone"); log("my name is %s", "Paul"); log("my age is %d", 24); log("using hex is 0x%02x", 24); return 0;&#125;static void __exit mod_exit(void)&#123; dbg("goodbye, everyone");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件二：Makefile1234567891011121314obj-m += log_module.oKERNEL = /home/user/workspace/mini2440/linux-2.6.32.2SHARE = /home/user/boardall: make -C $(KERNEL) M=`pwd` modules rm -rf $(SHARE)/* cp -f *.ko $(SHARE)/ make clean @echo "\033[31m &gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt; \033[0m"clean: make -C $(KERNEL) M=`pwd` modules clean rm -f app 2.3 加载模块加载模块，看看打印效果。 123456789[root@FriendlyARM /mnt]# insmod log_module.ko [Paul][mod_init][14] hello everyone[Paul][mod_init][15] my name is Paul[Paul][mod_init][16] my age is 24[Paul][mod_init][17] using hex is 0x18[root@FriendlyARM /mnt]# rmmod log_module/home/user/workspace/mini2440/linux_driver/02_printk/02_log/log_module.c:[Paul][mod_exit][23] goodbye, everyone]]></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 初识 Linux 内核模块]]></title>
    <url>%2F2018%2F01%2F22%2Fmini2440-module%2F</url>
    <content type="text"><![CDATA[一. 编写一个内核模块1.1 什么是内核模块Linux 内核是模块化组成的，它允许内核在运行时动态地向其中插入或从中删除代码。这些代码被一并组合在一个单独的二进制镜像中，即所谓的可装载内核模块中，或简称为模块。支持模块的好处是基本内核镜像尽可能的小，因为可选的功能和驱动程序可以利用模块形式再提供。模块允许我们方便地删除和重新载入内核代码，也方便了调试工作。而且当热插拔新设备时，可通过命令载入新的驱动程序。模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。总之，模块是一个为内核或其他内核模块提供使用功能的代码块。 1.2 最简单的内核模块创建一个目录专门保存 linux 驱动代码，并开始编写第一个内核模块： 123user@ubuntu:~$ mkdir -p workspace/mini2440/driver.with.linuxuser@ubuntu:~$ cd workspace/mini2440/driver.with.linux/user@ubuntu:~/workspace/mini2440/driver.with.linux$ mkdir -p module/simplest_module/ 文件一：simplest_module.c123456789101112131415161718#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;static int __init mod_init(void)&#123; printk(KERN_INFO "simplest module init ok!\n"); return 0;&#125;static void __exit mod_exit(void)&#123; printk(KERN_INFO "simplest module exit ok!\n");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件二：Makefile12345678obj-m += simplest_module.oKERNEL = /home/user/workspace/mini2440/linux-2.6.32.2all: make -C $(KERNEL) M=`pwd` modulesclean: make -C $(KERNEL) M=`pwd` modules clean 1.3 编译加载模块执行 make 命令，编译内核模块。 1234567891011user@vmware:~/mini2440/driver.with.linux/module/simplest_module/$ makemake -C /home/user/workspace/mini2440/linux-2.6.32.2 M=`pwd` modulesmake[1]: Entering directory '/home/user/workspace/mini2440/linux-2.6.32.2' Building modules, stage 2. MODPOST 1 modulesmake[1]: Leaving directory '/home/user/workspace/mini2440/linux-2.6.32.2'user@vmware:~/mini2440/driver.with.linux/module/simplest_module/$ lsMakefile Module.symvers simplest_module.c simplest_module.mod.cmodules.order readme.txt simplest_module.ko simplest_module.mod.osimplest_module.o 生成的 simplest_module.ko 文件就是可动态加载的内核模块。使用 insmod 命令加载模块到内核中，将会执行 module_init(mod_init) 指定的 mod_init 函数。 12[root@FriendlyARM /mnt]# insmod simplest_module.kosimplest module init ok! 使用 rmmod 命令卸载模块，将会执行 module_exit(mod_exit) 指定的 mod_exit 函数。 12[root@FriendlyARM /mnt]# rmmod simplest_modulesimplest module exit ok! 使用 modprobe -r 卸载模块，同 rmmod 功能。 12[root@FriendlyARM /mnt]# modprobe -r simplest_modulesimplest module exit ok! 二. 带参数的内核模块2.1 前言Linux 内核允许模块在加载的时候指定参数。模块接受参数传入的机制能够根据参数的不同提供多种不同的服务，增加了模块的灵活性。模块参数必须使用 module_param 宏来声明，通常放在文件头部。 module_param 需要 3 个参数：变量名称、类型以及用于 sysfs 入口的访问掩码。模块最好为参数指定一个默认值，以防加载模块的时候忘记传参而带来错误。 内核模块支持的参数类型有： bool、 invbool、 charp、 int、 short、 long、 uint、 ushort 和 ulong。 访问掩码的值在定义， S_IRUGO 表示任何人都可以读取该参数，但不能修改。 2.2 示例模块文件一：param_module.c12345678910111213141516171819202122232425262728293031#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;char* name = "unknow";int age = -1;module_param(name, charp, S_IRUGO);module_param(age, int, S_IRUGO);static int __init mod_init(void)&#123; if(!strcmp(name, "unknow") || -1 == age) &#123; printk(KERN_INFO "usage: insmod param_module name=&lt;str&gt; age=&lt;int&gt;\n"); return -1; &#125; printk(KERN_INFO "hello %s, your age is %d\n", name, age); printk(KERN_INFO "param module init ok!\n"); return 0;&#125;static void __exit mod_exit(void)&#123; printk(KERN_INFO "param module exit ok!\n");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件二：Makefile12345678910111213obj-m += param_module.oKERNEL = /home/user/workspace/mini2440/linux-2.6.32.2SHARE = /home/user/boardall: make -C $(KERNEL) M=`pwd` modules rm -rf $(SHARE)/* cp -f *.ko $(SHARE)/ make clean @echo "\033[31m &gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt; \033[0m"clean: make -C $(KERNEL) M=`pwd` modules clean rm -f app 2.3 加载模块不带参数加载，加载失败，提示加载参数使用方法： 123[root@FriendlyARM /mnt]# insmod param_module.kousage: insmod param_module name=&lt;str&gt; age=&lt;int&gt;insmod: cannot insert 'param_module.ko': Operation not permitted 带参数加载，加载成功： 12345[root@FriendlyARM /mnt]# insmod param_module.ko name="bean" age=20hello bean, your age is 20param module init ok![root@FriendlyARM /mnt]# rmmod param_moduleparam module exit ok! 三. 多个c文件编译成一个模块3.1 前言有的时候，一个驱动模块设计到功能过多，都写在一个文件中导致单个文件过大，文件结构复杂，不便于阅读和修改。那么如何将多个文件编译成为一个驱动模块呢?单个文件 main.c 编译成模块，Makefile 中只需要指定 obj-m 为对应的 .o 文件即可。 1obj-m += main.o 多个文件 tp_touch.c tp_gesture.c tp_firmware.c 编译成模块 tp_mstar.ko，需要这么干： 12obj-m += tp_mstar.otp_mstar-objs = tp_touch.o tp_gesture.o tp_firmware.o 3.2 示例模块文件一：tp_common.h12345678910#ifndef __TP_COMMON_H__#define __TP_COMMON_H__#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;void tp_print_support_gesture(void);void tp_print_firmware_version(void);#endif /* __TP_COMMON_H__ */ 文件二：tp_touch.c12345678910111213141516171819#include "tp_common.h"static int __init mod_init(void)&#123; tp_print_support_gesture(); tp_print_firmware_version(); printk(KERN_INFO "touch module init ok!\n"); return 0;&#125;static void __exit mod_exit(void)&#123; printk(KERN_INFO "touch module exit ok!\n");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件三：tp_firmware.c123456#include "tp_common.h"void tp_print_firmware_version(void)&#123; printk(KERN_INFO "msg2836 tp firmware version = 0x10.0x06!\n");&#125; 文件四：tp_gesture.c123456#include "tp_common.h"void tp_print_support_gesture(void)&#123; printk(KERN_INFO "msg2836 tp support C M W O V e gesture\n");&#125; 文件五：Makefile1234567891011121314obj-m += tp_mstar.otp_mstar-objs = tp_touch.o tp_gesture.o tp_firmware.oKERNEL = /home/user/workspace/mini2440/linux-2.6.32.2SHARE = /home/user/boardall: make -C $(KERNEL) M=`pwd` modules rm -rf $(SHARE)/* cp -f *.ko $(SHARE)/ make clean @echo "\033[31m &gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt; \033[0m"clean: make -C $(KERNEL) M=`pwd` modules clean rm -f app 3.3 加载模块加载模块，不难发现，三个文件被编译成了一个模块，三个文件的 log 都打印出来了。 123456[root@FriendlyARM /mnt]# insmod tp_mstar.kothe matar msg2836 tp support C M W O V e gesturethe matar msg2836 tp firmware version = 0x10.0x06!touch module init ok[root@FriendlyARM /mnt]# rmmod tp_mstartouch module exit ok! 四. 模块导出符号给另一个模块使用4.1 前言对于模块文件中定义的函数和变量，其他模块如果想要引用的话，被引用的函数或者变量需要使用 EXPORT_SYMBOL(x) 宏导出符号，其中 x 是导出的函数名或者变量名，而引用这个函数或者变量的模块做一下外部声明即可使用。 4.2 示例模块文件一：test_module.c1234567891011121314151617181920212223#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;extern int calculate_add(int x, int y);extern int calculate_sub(int x, int y);static int __init mod_init(void)&#123; printk(KERN_INFO "[%s][%d] 10 - 5 = %d\n", __func__, __LINE__, calculate_add(10, 5)); printk(KERN_INFO "[%s][%d] 10 - 5 = %d\n", __func__, __LINE__, calculate_sub(10, 5)); printk(KERN_INFO "test module init ok!\n"); return 0;&#125;static void __exit mod_exit(void)&#123; printk(KERN_INFO "test module exit ok!\n");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件二：calculate.c1234567891011121314151617181920212223242526272829303132#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;int calculate_add(int x, int y)&#123; printk(KERN_INFO "[%s][%d] is running\n", __func__, __LINE__); return x + y;&#125;EXPORT_SYMBOL(calculate_add);int calculate_sub(int x, int y)&#123; printk(KERN_INFO "[%s][%d] is running\n", __func__, __LINE__); return x - y;&#125;EXPORT_SYMBOL(calculate_sub);static int __init mod_init(void)&#123; printk(KERN_INFO "calculate module init ok!\n"); return 0;&#125;static void __exit mod_exit(void)&#123; printk(KERN_INFO "calculate module exit ok!\n");&#125;module_init(mod_init);module_exit(mod_exit);MODULE_LICENSE("GPL"); 文件三：Makefile1234567891011121314obj-m += test_module.oobj-m += calculate.oKERNEL = /home/user/workspace/mini2440/linux-2.6.32.2SHARE = /home/user/boardall: make -C $(KERNEL) M=`pwd` modules rm -rf $(SHARE)/* cp -f *.ko $(SHARE)/ make clean @echo "\033[31m &gt;&gt;&gt;&gt;&gt;&gt; make all successful &lt;&lt;&lt;&lt;&lt;&lt; \033[0m"clean: make -C $(KERNEL) M=`pwd` modules clean rm -f app 4.3 加载模块若一个模块(模块A)引用了另一个模块(模块B)导出的符号，那么要求加载模块A的时候，模块B就已经被加载进内核了。否则的话，模块A将无法成功加载进内核。 1234[root@FriendlyARM /mnt]# insmod test_module.kotest_module: Unknown symbol calculate_addtest_module: Unknown symbol calculate_subinsmod: cannot insert 'test_module.ko': unknown symbol in module or invalid parameter 可以看出模块 test_module 没有加载成功，提示说找不到一些符号。 12345678[root@FriendlyARM /mnt]# insmod calculate.kocalculate module init ok![root@FriendlyARM /mnt]# insmod test_module.ko[calculate_add][6] is running[mod_init][9] 10 - 5 = 15[calculate_sub][13] is running[mod_init][10] 10 - 5 = 5test module init ok! 加载依赖的 calculate 模块之后，test_module 正常加载了。]]></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hexo] 基于 Hexo 和 github 搭建个人博客]]></title>
    <url>%2F2018%2F01%2F21%2Fhexo-build-the-personal-blog%2F</url>
    <content type="text"><![CDATA[一. 前言二. 配置博客环境2.1 nodejs2.1.1 node 介绍安装 nodejs 的目的是为了使用 hexo 组件，关于 node 和 hexo 是什么东西，我一个做嵌入式开发的小伙子并不懂，具体还请各位自行访问其官网或者百度了解。 2.1.2 下载 nodejs百度搜索 nodejs 或者直接点击访问 https://nodejs.org/zh-cn/ nodejs 官网下载最新版本的版本的 nodejs，由于我使用的是 Ubuntu 平台，下载后在 ~/download 目录下有对应的 linux 版本 nodejs 压缩包。 12user@lenovo:~/download$ lsnode-v8.9.4-linux-x64.tar.xz 2.1.3 解压 nodejs这里我是直接在 ~/ 目录下创建了一个 ~/opt/ 目录，用来安装 nodejs 软件。 12user@lenovo:~$ mkdir optuser@lenovo:~$ tar Jxf download/node-v8.9.4-linux-x64.tar.xz -C opt/ 为什么不直接将 nodejs 安装在 /opt 目录下呢？其实我也是逼不得已，我之前确实是有将 nodejs 解压到 /opt 目录下，并成功配置好环境变量后，查看 nodejs 版本也是 ok 的。但是执行 npm install -g hexo 的时候，提示说没有权限，然而加上 sudo，还是不行，最后只能在自己 ~/ 目录下创建一个安装软件的 /opt 目录了。 2.1.4 配置环境变量上述解压步骤执行完之后，nodejs 就已经安装好了，我们直接在 /home/user/opt/node-v8.9.4-linux-x64/bin 目录下敲 node 命令是可以执行的。但是在终端的其他的位置则无法使用 node 命令，原因其实很简单，我们在 shell 中执行的每一条命令都有其对应的可执行文件，理论上要执行这些文件都需要切换到可执行文件对应的目录或者通过可执行文件的全路径指定。可是这样实在是太麻烦了，linux 博大精深，不可能没有应对机制，shell 有一个机制，在 shell 中解析命令的时候，会先在当前目录下找命令的可执行文件，如果当前目录下找不到的话，则会根据 PATH 环境指定的目录再去找可执行文件。这就豁然开朗了，也就明白了为什么我们要配置环境变量，为的是不管在哪一个目录下都可以直接使用 node 命令，而不需要指定 node 全路径。 12user@lenovo:~$ echo "export PATH=$PATH:/home/user/opt/node-v8.9.4-linux-x64/bin" &gt;&gt; .bashrcuser@lenovo:~$ . .bashrc 2.1.5 验证 nodejs 是否配置成功在任意目录下，执行任意一条 node 命令即可验证配置是否生效。就用最简单的 node 查看版本号的命令吧。 12user@lenovo:~$ node -vv8.9.4 2.2 git &amp; github2.2.1 git 和 github 介绍git 是一个版本控制工具，github 是一个代码托管平台。版本控制是干什么的呢？详细介绍请移步廖雪峰的git教程托管平台又是什么东西呢？我们将其类比为百度网盘这样的云端备份就可以了。我们本地的 code 使用 git 来管理，同时我们将 code 拷贝一份到 github 上，做备份用，只不过这个备份的副本，其他人也可以修改，这其实就是 git 的协作功能。 2.2.2 安装 git直接使用 Ubuntu 的软件包管理器安装即可。 1user@lenovo:~$ sudo apt-get install git 备注：apt-get 是高级包装工具(Advanced Packaging Tools)是 Debian 及其衍生发行版(eg.Ubuntu)的软件包管理器。APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了 Unix 系统上管理软件的过程，apt-get 命令一般需要 root 权限执行，所以一般跟着 sudo 命令。 2.2.3 配置 git因为 git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和 Email 地址。 12user@lenovo:~$ git config --global user.name mz8023ytuser@lenovo:~$ git config --global user.email mz8023yt@163.com 有没有经常敲错命令？比如 git status？哎 status 这个单词真心不好记。如果敲 git st 就表示 git status 那就简单多了，当然这种偷懒的办法我们是极力赞成的。我们只需要敲一行命令，告诉 git，以后 st 就表示 status： 12user@lenovo:~$ git config --global alias.st statususer@lenovo:~$ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 2.2.5 创建 ssh 秘钥对git 和 github 之间是通过 ssh 加密协议通信的，因此需要创建一对 ssh 秘钥对。 1user@lenovo:~$ ssh-keygen -t rsa -C mz8023yt@163.com 2.2.6 创建 github 仓库第一步，肯定是注册一个 github 账号了，我的账户名是 mz8023yt。第二步，创建 mz8023yt.github.io 仓库。由于我们是通过 github.io 机制搭建个人博客，因此需要创建和用户名同名的 github.io 仓库。第三步，创建一个 blog 仓库，这个仓库是 hexo blog 的源码。第四步，将 ssh 公钥添加到 github 中。 2.3 hexo2.3.1 hexo 介绍什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.3.2 安装 hexo安装 Hexo 相当简单。然而在安装前，必须检查电脑中是否已安装下列应用程序： Node.js Git 上面这两个工具我们已经安装好了，因此接下来只需要使用 npm 即可完成 Hexo 的安装。 12345user@lenovo:~$ npm install -g hexo-clinpm WARN deprecated swig@1.4.2: This package is no longer maintained... ...+ hexo@3.4.4added 253 packages in 24.503s 查看一下 hexo 的版本号，确认 hexo 安装成功。 12345678910111213141516user@lenovo:~$ hexo -vhexo-cli: 1.0.4os: Linux 4.10.0-28-generic linux x64http_parser: 2.7.0node: 8.9.4v8: 6.1.534.50uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 2.3.3 获取 hexo 站点源文件安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 12345678user@lenovo:~$ mkdir bloguser@lenovo:~$ cd blog/user@lenovo:~/blog$ hexo initINFO Cloning hexo-starter to ~/blog正克隆到 '/home/user/blog'...... ...added 315 packages in 12.99sINFO Start blogging with Hexo! 2.3.4 使用 git 管理网站源文件这一步不是必须的，但我还是觉得很有必要。为什么我觉得很有必要，比如说换电脑了或者重装系统了，源码还是有备份的。 12345user@lenovo:~/blog$ git init初始化空的 Git 仓库于 /home/user/blog/.git/user@lenovo:~/blog$ git remote add mz8023yt git@github.com:mz8023yt/blog.gituser@lenovo:~/blog$ git add --alluser@lenovo:~/blog$ git commit -m "feature: start the blog with hexo" 2.3.5 修改配置文件1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type:+ type: git+ repo: https://github.com/mz8023yt/mz8023yt.github.io.git+ branch: master 2.3.6 生成博客页面并部署使用以下命令进行网站的部署： hexo c: hexo clean 清除生成的静态页面 hexo g: hexo generate 重新生成博客静态页面 hexo d: hexo deploy 部署到 github.io 仓库 1234user@lenovo:~/blog$ hexo c &amp;&amp; hexo g &amp;&amp; hexo d... ...INFO 28 files generated in 620 msERROR Deployer not found: git 报错了，不慌，百度说这样可以解决，试试。 12345user@lenovo:~/blog$ npm install --save hexo-deployer-gitnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"linux","arch":"x64"&#125;)+ hexo-deployer-git@0.3.1added 16 packages in 7.932s 再来一次。 12345user@lenovo:~/blog$ hexo c &amp;&amp; hexo g &amp;&amp; hexo dTo git@github.com:mz8023yt/mz8023yt.github.io.git * [new branch] HEAD -&gt; master分支 master 设置为跟踪来自 git@github.com:mz8023yt/mz8023yt.github.io.git 的远程分支 master。INFO Deploy done: git 很好，成功了，访问 https://mz8023yt.github.io/ 看看。 三. 更换 next 主题hexo 默认的主题不是很好看，在 hexo 文档中心中有对应的文档介绍如何更换主题以及给出众多官网推荐的主题。 3.1 为什么选择 next我个人选择 nxet 是基于以下几个理由： 界面简洁美观 支持点击跳转的侧栏目录 支持代码高亮 详细清晰的官网文档 3.2 安装 next 主题既然都说了，next 官方文档特别的详细清晰，那就直接跳转到官方文档去看看吧。官网给出了两种方式获取 next 主题的方式，一种是直接 clone 仓库，一种则是直接下载打包好的 next 稳定版本。获取到 next 主题包后，解压所下载的压缩包至站点的 themes 目录下， 并将解压后的文件夹名称更改为 next。最后将 hexo 站点配置文件 中的 theme 修改为 next。 12345678910 # git diff _config.yml@@ -72,7 +72,7 @@ pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/-theme: landscape+theme: next # Deployment ## Docs: https://hexo.io/docs/deployment.html 3.3 配置 hexo 站点3.3.1 修改站点语言为中文这里直接修改站点配置文件的 language 为 zh-Hans 即可。这里可能有的小伙伴会觉得有点奇怪，zh-Hans 是什么东西？不应是 zh-CN 吗？其实这是因为 next 主题中将中文对应的资源文件命名为 zh-Hans。 12345678910 # git diff _config.yml@@ -7,7 +7,7 @@ title: Hexo subtitle: description: author: John Doe-language:+language: zh-Hans timezone: # URL 3.3.2 修改站点描述信息123456789101112131415 # git diff _config.yml@@ -3,10 +3,10 @@## Source: https://github.com/hexojs/hexo/# Site-title: Hexo-subtitle:-description:-author: John Doe+title: Paul's blog+subtitle: "学而不思则罔 思而不学则殆"+description: "但行好事 莫问前程"+author: Paul Wanglanguage: zh-Hanstimezone: 3.3.3 修改 hexo 的默认端口号为 5000hexo server 启动 hexo 本地服务的时候，默认使用的是 localhost:4000 端口，如果你的电脑同时安装的福昕pdf阅读器，那么很遗憾，端口冲突了。这个时候通常的做法是通过 hexo server -p 5000 重新指定一个端口号(这里我指定的是 5000)启动 hexo 服务。但是每次预览博客的时候都要手动指定端口号实在是不方便，通过修改站点配置文件可以修改 hexo 服务默认使用的端口号。追加下面这段便可以设置默认的端口号为 5000。 12345# server portserver: port: 5000 compress: true header: true 3.4 配置 next 主题3.4.1 博客主页显示博文预览刚刚安装好 next 之后，不难发现，next 的首页上会将博文的所有内容都贴出来，这样十分不方便我们查找博文，最好是能够像其他博客网站一样，能够有个预览界面，截取博文中的一小段，贴在首页即可。 博客预览有两种设置方法： 第一种是设置自动生成摘要，仅仅截取文章开头的部分文字。 第二种也是截取文章开口的部分，并且会保留原始格式，但是需要每一篇文章都通过 &lt;!-- more --> 指定从文章开头到预览结束的位置。 12345678910 # git diff themes/next/_config.yml@@ -216,7 +216,7 @@ excerpt_description: true # Automatically Excerpt. Not recommend. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt:- enable: false+ enable: true length: 150 # Post meta display settings 3.4.2 取消侧栏目录自动编号侧边栏自动创建目录，并且点击可以跳转的功能是我选择 next 最重要的理由。这个功能实在是太贴心了，尤其对于比较长的文章，很是受用。但是很多的时候我们会为自己的文章的层次结构做好规划，有自己的给目录编号的方式，这个时候就需要取消目录自动编号的功能。 12345678910 # git diff themes/next/_config.yml@@ -161,7 +161,7 @@ toc: enable: true # Automatically add list number to toc.- number: true+ number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 3.4.3 添加博客头像将头像的资源文件放在站点文件目录中的某一处，然后在 next 主题配置文件中指定 avator 属性为该资源的路径即可。 12345678910 # git diff themes/next/_config.yml@@ -154,7 +154,7 @@ links_layout: block # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif-#avatar: /images/avatar.gif+avatar: /images/avatar.jpg # Table Of Contents in the Sidebar toc:tubiao 3.4.4 修改网站图标将网站图标相关的资源文件放在站点文件目录中的某一处，然后在 next 主题配置文件中指定下面的属性为该资源的路径即可。这里值得注意的是，next 有好几个站点图标的资源，我也不清除具体在什么场景下哪一个会生效，因此我全部找了对应分辨率的资源将之替换。 这里顺便推荐一个图标网站：阿里适量图库。 12345678910111213141516171819 # git diff themes/next/_config.yml@@ -27,10 +27,14 @@ override: false # For example, you put your favicons into `hexo-site/source/images` directory. # Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo. favicon:- small: /images/favicon-16x16-next.png- medium: /images/favicon-32x32-next.png- apple_touch_icon: /images/apple-touch-icon-next.png- safari_pinned_tab: /images/logo.svg+ #small: /images/favicon-16x16-next.png+ #medium: /images/favicon-32x32-next.png+ #apple_touch_icon: /images/apple-touch-icon-next.png+ #safari_pinned_tab: /images/logo.svg+ small: /favicon/favicon-16x16.png+ medium: /favicon/favicon-32x32.png+ apple_touch_icon: /favicon/favicon.png+ safari_pinned_tab: /favicon/favicon.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 3.4.5 修改代码高亮的方式12345678910 # git diff themes/next/_config.yml@@ -277,7 +277,7 @@ custom_logo: # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme-highlight_theme: normal+highlight_theme: night # --------------------------------------------------------------- 3.4.6 添加侧边栏社交链接123456789101112131415 # git diff themes/next/_config.yml@@ -130,9 +130,9 @@ scheme: Gemini # Key is the link label showing to end users. # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the name of FontAwesome icon. # If icon (with or without delimeter) is not specified, globe icon will be loaded.-#social:- #GitHub: https://github.com/yourname || github- #E-Mail: mailto:yourname@gmail.com || envelope+social:+ E-Mail: mailto:mz8023yt@163.com || envelope+ GitHub: https://github.com/mz8023yt || github #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook 3.4.7 加宽博文宽度对于显示器比较大的电脑，在使用 next 主题的时候，发现两边大量的留白，对于站点整理的美观有所影响。能不能将文章对应的宽度修改的宽一点呢？ 1234567891011121314151617181920212223242526272829303132 # git diff themes/next/source/css/_schemes/Pisces/_layout.styl@@ -1,7 +1,7 @@ .header &#123; position: relative; margin: 0 auto;- width: $main-desktop;+ width: 80%; +tablet() &#123; width: auto;@@ -47,7 +47,7 @@ &#125; .container .main-inner &#123;- width: $main-desktop;+ width: 80%; +tablet() &#123; width: auto;@@ -61,7 +61,7 @@ float: right; box-sizing: border-box; padding: $content-desktop-padding;- width: $content-desktop;+ width: calc(100% - 260px); background: white; min-height: 700px; box-shadow: $box-shadow-inner;@@ -127,4 +127,3 @@ padding-right: 260px; &#125; &#125; 3.4.8 添加字数统计和阅读时长1234567891011121314151617diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex 72e87b8..288ee8b 100755--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -238,9 +238,9 @@ post_meta: # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true- wordcount: false- min2read: false- totalcount: false+ wordcount: true+ min2read: true+ totalcount: true separated_meta: true # Wechat Subscriber 注释上写此功能依赖 https://github.com/willin/hexo-wordcount 插件，看了看 hexo-wordcount 插件的 README 介绍，需要执行以下命令安装 hexo-wordcount 插件。 1user@lenovo:~/blog$ npm i --save hexo-wordcount 3.5 添加页面3.5.1 添加关于界面参考 Next 官网文档，添加页面可以用 hexo new page 命令。 12user@lenovo:~/blog$ hexo new page "about"INFO Created: ~/blog/source/about/index.md 在生成的 index.md 下编辑你的关于页面即可。 3.5.2 添加标签界面首先，在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags。 12user@lenovo:~/blog$ hexo new page "tags"INFO Created: ~/blog/source/tags/index.md 修改 ~/blog/source/tags/index.md 文件，设置页面类型为 tags。 1234567 # git diff source/tags/index.md@@ -0,0 +1,5 @@+---+title: 标签+date: 2018-01-22 21:19:54+type: tags+--- 最后修改主题配置文件，在侧边栏添加标签菜单项。 12345678910111213 # git diff themes/next/_config.yml@@ -98,9 +98,9 @@ index_with_subtitle: false menu: home: / || home categories: /categories/ || th about: /about/ || user- #tags: /tags/ || tags+ tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 3.5.3 添加分类界面分类界面的添加和上小节的 tags 很类似。首先，在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories。 12user@lenovo:~/blog$ hexo new page "categories"INFO Created: ~/blog/source/categories/index.md 修改 ~/blog/source/categories/index.md 文件，设置页面类型为 categories。 1234567 # git diff source/categories/index.md@@ -0,0 +1,5 @@+---+title: 标签+date: 2018-01-22 21:19:54+type: categories+--- 最后修改主题配置文件，在侧边栏添加标签菜单项。 1234567891011 # git diff themes/next/_config.yml@@ -97,9 +97,9 @@ index_with_subtitle: false menu: home: / || home+ categories: /categories/ || th about: /about/ || user #tags: /tags/ || tags- #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap 四. 开始写第一篇文章4.1 新建文章4.2 预览文章4.3 发布文章五. 重新搭建博客5.1 重装系统或者更换电脑之前描述的是在 ubuntu 环境下搭建博客环境，现在我买了一台 windows 主机或者说重装了一下系统，但是我想将我的博客源码移植到 windows 继续使用怎么办？其实只要将之前的 blog 源码拷贝到新的电脑上，重新配置一下 nodejs、hexo、git 就好。 5.2 重新搭建环境和从零开始的区别安装 nodejs 和 git 和之前一样，请参考第二章。唯一有区别的是 hexo 的安装。 先不管那么多，执行 npm 命令安装 hexo 看看。 1234567$ npm install -g hexo-cliC:\Users\mz802\AppData\Roaming\npm\hexo -&gt; C:\Users\mz802\AppData\Roaming\npm\node_modules\hexo-cli\bin\hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\hexo-cli\node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ hexo-cli@1.0.4added 217 packages in 18.824s 安装好了，看看版本信息确认一下，看看是不是 ok 了。 123$ hexo -vERROR Local hexo not found in E:\blogERROR Try running: 'npm install hexo --save' 有问题？不过没有关系，提示不说叫我们试试 npm install hexo –save 命令吗，那不妨试一下。 12345678910$ npm install hexo --save&gt; nunjucks@3.1.2 postinstall E:\blog\node_modules\hexo\node_modules\nunjucks&gt; node postinstall-build.js srcnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ hexo@3.5.0added 470 packages in 17.778s 成功了，再看看版本信息。 1234567891011121314151617$ hexo -vhexo: 3.5.0hexo-cli: 1.0.4os: Windows_NT 10.0.16299 win32 x64http_parser: 2.7.0node: 8.9.3v8: 6.1.534.48uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 此时如果细心的话，不难发现，package-lock.json 和 package.json 文件有更新，这里自己去看看 git diff 吧，其实是 hexo 版本有变化，才更新到了这两个文件。 六. 常见问题6.1 无法访问 localhost:4000hexo 安装成功，并且正确运行，但是执行 hexo s 的时候，出现 localhost:4000 不能访问。百度查了下是因为 hexo 默认使用 4000 端口，但是如果安装了福昕阅读器，则 4000 端口已经被福昕阅读器使用了，导致 hexo 没有办法使用 4000 端口。解决方法是换个端口，使用 -p 选项可以指定端口号。 1hexo s -p 5000 这里换成 5000 端口，访问 localhost:5000 正常访问。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mini2440] 搭建 Linux 开发环境]]></title>
    <url>%2F2018%2F01%2F12%2Fmini2440-build-the-dev-env%2F</url>
    <content type="text"><![CDATA[一. 烧写 Superboot1.1 相关资料获取本小节主要讲述如何使用韦东山老师开发的 oflash 工具配合 OpenJTAG 下载器下载友善之臂光盘提供的 superboot 到 mini2440 开发板的 nor flash 上。 为什么要下载 superboot 到 nor flash 上？是因为 superboot 可以配合 FriendlyARM 开发的 miniTools 工具快速烧写系统到 mini2440 开发板上。 涉及到的资源有： oflash 工具 OpenJTAG 驱动程序 superboot 镜像 如何获取这些资源： oflash 和 OpenJTAG 驱动可以在韦东山老师的 JZ2440 开发板光盘资料中获取。 superboot 镜像可以在友善之臂 mini2440 开发板光盘资料中获取。 对应的光盘资料可以去对应的论坛获取，论坛网址如下： JZ2440 论坛： http://www.100ask.net/bbs/forum.php FriendlARM 论坛： http://www.arm9home.net/ 1.2 安装 oflash 程序安装 oflash 工具oflash 安装包路径：JZ2440光盘\烧写工具\裸机\eop&amp;op\调试工具\01.OpenOCD with GUI setup.exe使用管理员权限安装 OpenOCD with GUI setup.exe 即可在 cmd.exe 命令行里执行 oflash 程序。 验证是否安装成功依次执行：Win + R -&gt; 输入 cmd 调起控制台 -&gt; 输入 oflash 执行，出现以下提示说明 oflash 安装成功。 1234567891011121314151617181920C:\Users\user&gt;oflash+---------------------------------------------------------+| Flash Programmer v1.5.2 for OpenJTAG of www.100ask.net|| OpenJTAG is a USB to JTAG &amp; RS232 tool based FT2232 || This programmer supports both of S3C24X0 &amp; S3C6410 || Author: Email/MSN(thisway.diy@163.com), QQ(17653039) |+---------------------------------------------------------+Usage:1. oflash, run with cfg.txt or prompt2. oflash [file], write [file] to flash with prompt3. oflash [-f config_file]4. oflash [jtag_type] [cpu_type] [flash_type] [read_or_write] [offset] [file]Can't open cfg.txt, you should follow the promptSelect the JTAG type:0. OpenJTAG1. Dongle JTAG(parallel port)2. Wiggler JTAG(parallel port)Enter the number: 1.3 安装 OpenJTAG 驱动手动安装 OpenJTAG 驱动OpenJATG 驱动程序路径：JZ2440光盘\烧写工具\裸机\eop&amp;op\驱动\OpenJTAG*将 OpenJTAG 插入电脑 -&gt; 右键我的电脑 -&gt; 管理 -&gt; 设备管理器。可以看到其他设备里面有两个 USB &lt;==&gt; JTAG&amp;&amp;RS232 设备，但是旁边有感叹号，说明这两个设备并没有驱动。 手动去安装 OpenJTAG 的驱动程序，右键 “USB &lt;==&gt; JTAG&amp;&amp;RS232” -&gt; 更新驱动程序 -&gt; 浏览计算机以查找驱动程序 -&gt; 路径选择到 OpenJATG 驱动文件夹 -&gt; 点击下一步，开始安装驱动。但是，报了一个这样的错，文件的哈希值不在指定的目录文件。 解决 OpenJTAG 驱动安装不上的问题百度查了一下，原因是因为老设备的驱动没有更新，和新系统 Win 8 或 Win 10 系统不兼容，没得到数字签名通过。要正常安装驱动程序，需要强制关闭数字签名。怎么操作：开始菜单 -&gt; 设置 -&gt; 更新和安全 -&gt; 恢复 -&gt; 立即重启 -&gt; 疑难解答 -&gt; 高级选项 -&gt; 启动设置 -&gt; 重启 -&gt; 电脑重启后，出现选择界面，F7选择禁止验证驱动签名。设置好之后，重新手动安装，注意这里需要安装三次驱动。分别是： 1.4 下载 superboot 到 mini2440 开发板上使用 oflash 开始烧写 superbootsuperboot 镜像路径：mini2440光盘\images\Superboot2440.bin开发板上电(不管是 nor 还是 nand 启动都行)，使用 OpenJTAG 连接好开发板和电脑，运行 cmd 程序，切换到 superboot 所在目录，依次执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556E:\Material\mini2440\FriendlyARM-2440-DVD\images&gt;oflash Superboot2440.bin+---------------------------------------------------------+| Flash Programmer v1.5.2 for OpenJTAG of www.100ask.net|| OpenJTAG is a USB to JTAG &amp; RS232 tool based FT2232 || This programmer supports both of S3C24X0 &amp; S3C6410 || Author: Email/MSN(thisway.diy@163.com), QQ(17653039) |+---------------------------------------------------------+Usage:1. oflash, run with cfg.txt or prompt2. oflash [file], write [file] to flash with prompt3. oflash [-f config_file]4. oflash [jtag_type] [cpu_type] [flash_type] [read_or_write] [offset] [file]Select the JTAG type:0. OpenJTAG1. Dongle JTAG(parallel port)2. Wiggler JTAG(parallel port)Enter the number: 0Select the CPU:0. S3C24101. S3C24402. S3C6410Enter the number: 1device: 4 "2232C"deviceID: 0x14575118SerialNumber: FThecwJmADescription: USB&lt;=&gt;JTAG&amp;RS232 AS3C2440 detected, cpuID = 0x0032409d[Main Menu] 0:Nand Flash prog 1:Nor Flash prog 2:Memory Rd/Wr 3:ExitSelect the function to test:1Detect Nor Flash ...AMD AM29LV160DBSize: 2 MBImage Size: 0x40000Available Target Offset:Bank # 1: AMD AM29LV160DB FLASH (16 x 16) Size: 2 MB in 35 Sectors AMD Standard command set, Manufacturer ID: 0x01, Device ID: 0x2249 Erase timeout: 30000 ms, write timeout: 100 msSector Start Addresses:00000000 00004000 00006000 00008000 0001000000020000 00030000 00040000 00050000 0006000000070000 00080000 00090000 000A0000 000B0000000C0000 000D0000 000E0000 000F0000 0010000000110000 00120000 00130000 00140000 0015000000160000 00170000 00180000 00190000 001A0000001B0000 001C0000 001D0000 001E0000 001F0000Input target offset:0Erasing ....... donewrite ...100%done 验证是否烧录成功mini2440 切换到 nor 启动，连接串口终端，出现如下提示则表示烧录成功。 12345Superboot-2440 V1.5(20150414) by FriendlyARMBooting from NORTry to find SD card...... not found.Hello USB Loop 二. 使用 miniTool 刷机2.1 安装 miniTools 工具miniTools 安装包路径：mini2440光盘\windows平台工具\MiniTools-USB下载工具\MiniToolsSetup-Windows-20150528.exeWindows 平台下安装 MiniTools 工具，双击安装即可。安装好后桌面会出现 miniTools 应用的图标，双击执行效果为： 2.2 安装 mini2440 驱动程序mini2440 usb 驱动程序路径：mini2440光盘\windows平台工具\usb下载驱动\FriendlyARM USB Download Driver Setup_20090421.exe直接安装无法安装上，同样需要用 usb 线连接好了 mini2440 后在设备管理器下手动去安装驱动，针对 Win 8 和 Win 10 也是需要强制关闭数字签名后才能安装的上。驱动安装成功后设备管理器截图： 2.3 使用 miniTools 给 mini2440 刷系统使用 usb 线连接好 mini2440 和电脑，mini2440 使用 nor 启动，然后运行 miniTools，此时显示的是开发板信息。 切换到 linux 选项下，直接选择从光盘目录中的 image 目录自动导入，然后修改好自己手头上 mini2440 搭配的屏即可开始烧写。 点击开始烧写，等待烧写完成。 2.4 验证是否烧写成功mini2440 切换到 nand 启动模式，开机，看是否能成功启动 kernel，这里贴出部分开机 log： 1234567891011121314151617181920212223242526Superboot-2440 V1.5(20150414) by FriendlyARMBooting from NANDLoad Kernel...Uncompressing Linux...................................................................................................................................................... done, booting the kernel.Linux version 2.6.32.2-FriendlyARM (root@tzs-ThinkPad-X201) (gcc version 4.4.3 (ctng-1.6.1) ) #16 Tue Dec 23 15:08:43 CST 2014CPU: ARM920T [41129200] revision 0 (ARMv4T), cr=c0007177CPU: VIVT data cache, VIVT instruction cacheMachine: FriendlyARM Mini2440 development boardATAG_INITRD is deprecated; please update your bootloader.Memory policy: ECC disabled, Data cache writebackCPU S3C2440A (id 0x32440001)S3C24XX Clocks, (c) 2004 Simtec ElectronicsS3C244X: core 405.000 MHz, memory 101.250 MHz, peripheral 50.625 MHzCLOCK: Slow mode (1.500 MHz), fast, MPLL on, UPLL on... ... ... ...Freeing init memory: 156Khwclock: settimeofday() failed: Invalid argument[01/Jan/1970:00:00:12 +0000] boa: server version Boa/0.94.13[01/Jan/1970:00:00:12 +0000] boa: server built Jul 26 2010 at 15:58:29.[01/Jan/1970:00:00:12 +0000] boa: starting server pid=697, port 80Try to bring eth0 interface up......eth0: link downDonePlease press Enter to activate this console. eth0: link up, 100Mbps, full-duplex, lpa 0xC1E1[root@FriendlyARM /]# 最后能出现控制台说明 kernel 正常启动了。 三. 编译 linux-2.6.32.2 内核3.1 准备好开发环境需要创建一个 Ubuntu 虚拟机，并且安装好 VMwareTools 方便和 Windows 之间传文件。创建好一个 mini2440 的工作目录，后续所有 mini2440 相关的文件均存放在此目录下。 1user@vmware:~$ mkdir -p workspace/mini2440 3.2 安装交叉编译器在 mini2440 工作目录下创建 package 目录，存放软件包。 1user@vmware:~$ mkdir workspace/mini2440/package 拷贝 mini2440光盘\Linux\arm-linux-gcc-4.4.3.tar.gz 到虚拟机 /home/user/workspace/mini2440/package 目录下。解压到 /opt 目录下并配置好环境变量. 12345user@vmware:~$ cd workspace/mini2440/package/user@vmware:~/workspace/mini2440/package$ sudo tar zxf arm-linux-gcc-4.4.3.tar.gz -C /user@vmware:~/workspace/mini2440/package$ cduser@vmware:~$ echo "export PATH=\$PATH:/opt/FriendlyARM/toolschain/4.4.3/bin" &gt;&gt; .bashrcuser@vmware:~$ . .bashrc 验证交叉编译器是否安装成功。 12user@vmware:~$ arm-linux-gcc -v/opt/FriendlyARM/toolschain/4.4.3/bin/arm-linux-gcc: 15: exec: /opt/FriendlyARM/toolschain/4.4.3/bin/.arm-none-linux-gnueabi-gcc: not found 没有正确的显示版本号，百度查了一下，原因是虚拟机的 Ubuntu 是 64 位的，而此交叉编译器是 32 位的版本，要想正常使用，需要安装 32 位兼容库。 12user@vmware:~$ sudo apt-get install lib32ncurses5user@vmware:~$ sudo apt-get install lib32z1 安装好兼容库之后，验证成功。 123456789101112user@vmware:~$ arm-linux-gcc -vUsing built-in specs.Target: arm-none-linux-gnueabiConfigured with: /opt/FriendlyARM/mini2440/build-toolschain/working/src/gcc-4.4.3/configure --build=i386-build_redhat-linux-gnu --host=i386-build_redhat-linux-gnu --target=arm-none-linux-gnueabi --prefix=/opt/FriendlyARM/toolschain/4.4.3 --with-sysroot=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --enable-languages=c,c++ --disable-multilib --with-arch=armv4t --with-cpu=arm920t --with-tune=arm920t --with-float=soft --with-pkgversion=ctng-1.6.1 --disable-sjlj-exceptions --enable-__cxa_atexit --with-gmp=/opt/FriendlyARM/toolschain/4.4.3 --with-mpfr=/opt/FriendlyARM/toolschain/4.4.3 --with-ppl=/opt/FriendlyARM/toolschain/4.4.3 --with-cloog=/opt/FriendlyARM/toolschain/4.4.3 --with-mpc=/opt/FriendlyARM/toolschain/4.4.3 --with-local-prefix=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --disable-nls --enable-threads=posix --enable-symvers=gnu --enable-c99 --enable-long-long --enable-target-optspaceThread model: posixgcc version 4.4.3 (ctng-1.6.1) 3.3 配置 linux 内核同样将 mini2440光盘\Linux\linux-2.6.32.2-mini2440-20150709.tgz 文件拷贝到虚拟机 /home/user/workspace/mini2440/package 目录下。解压开来，可以看到有很多的配置文件，当然还是挑自己板子搭配屏的配置文件。 123456789101112131415user@vmware:~/workspace/mini2440/package$ tar zxf linux-2.6.32.2-mini2440-20150709.tgz -C ../user@vmware:~/workspace/mini2440/package$ cd ../linux-2.6.32.2/user@vmware:~/workspace/mini2440/linux-2.6.32.2$ lsarch config_mini2440_s70d drivers netblock config_mini2440_t35 firmware READMEbuild.sh config_mini2440_td35 fs REPORTING-BUGSconfig_mini2440_a70 config_mini2440_vga1024x768 include samplesconfig_mini2440_a70i config_mini2440_vga640x480 init scriptsconfig_mini2440_h43 config_mini2440_vga800x600 ipc securityconfig_mini2440_l80 config_mini2440_w35 Kbuild soundconfig_mini2440_n35 config_mini2440_x35 kernel toolsconfig_mini2440_n43 COPYING lib usrconfig_mini2440_p35 CREDITS MAINTAINERS virtconfig_mini2440_p43 crypto Makefileconfig_mini2440_s70 Documentation mm 开始配置，拷贝配置文件，执行 make menuconfig 生成对应 C 语言配置宏文件和 Makefile 编译宏控文件。 123456789101112131415161718192021222324252627282930313233user@vmware:~/workspace/mini2440/linux-2.6.32.2$ make distcleanuser@vmware:~/workspace/mini2440/linux-2.6.32.2$ cp config_mini2440_x35 .configuser@vmware:~/workspace/mini2440/linux-2.6.32.2$ make menuconfig HOSTCC scripts/basic/fixdep HOSTCC scripts/basic/docproc HOSTCC scripts/basic/hash HOSTCC scripts/kconfig/conf.oscripts/kconfig/conf.c: In function ‘conf_sym’:scripts/kconfig/conf.c:159:6: warning: variable ‘type’ set but not used [-Wunused-but-set-variable] int type; ^scripts/kconfig/conf.c: In function ‘conf_choice’:scripts/kconfig/conf.c:231:6: warning: variable ‘type’ set but not used [-Wunused-but-set-variable] int type; ^scripts/kconfig/conf.c:307:4: warning: ignoring return value of ‘fgets’, declared with attribute warn_unused_result [-Wunused-result] fgets(line, 128, stdin); ^scripts/kconfig/conf.c: In function ‘conf_askvalue’:scripts/kconfig/conf.c:105:3: warning: ignoring return value of ‘fgets’, declared with attribute warn_unused_result [-Wunused-result] fgets(line, 128, stdin); ^ HOSTCC scripts/kconfig/kxgettext.o *** Unable to find the ncurses libraries or the *** required header files. *** 'make menuconfig' requires the ncurses libraries. *** *** Install ncurses (ncurses-devel) and try again. ***/home/user/workspace/mini2440/linux-2.6.32.2/scripts/kconfig/Makefile:186: recipe for target 'scripts/kconfig/dochecklxdialog' failedmake[1]: *** [scripts/kconfig/dochecklxdialog] Error 1Makefile:454: recipe for target 'menuconfig' failedmake: *** [menuconfig] Error 2 报错了，提示说需要 ncurses 库，安装好库之后，成功配置。 12user@vmware:~/workspace/mini2440/linux-2.6.32.2$ sudo apt-get install libncursesuser@vmware:~/workspace/mini2440/linux-2.6.32.2$ sudo apt-get install ncurses-dev 进入图形化配置界面后，直接按 esc 退出即可，配置项已经拷贝到最终的配置文件 .config 文件中了，执行 make menuconfig 的作用，只是去自动生成 Makefile 和 c 语言宏控文件。 3.4 编译内核配置 ok 了，要开始编译内核了。 12345678910111213user@vmware:~/workspace/mini2440/linux-2.6.32.2$ make CHK include/linux/version.h UPD include/linux/version.h Generating include/asm-arm/mach-types.h CHK include/linux/utsrelease.h UPD include/linux/utsrelease.h SYMLINK include/asm -&gt; include/asm-arm CC kernel/bounds.s/opt/FriendlyARM/toolschain/4.4.3/libexec/gcc/arm-none-linux-gnueabi/4.4.3/cc1: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory/home/user/workspace/mini2440/linux-2.6.32.2/./Kbuild:35: recipe for target 'kernel/bounds.s' failedmake[1]: *** [kernel/bounds.s] Error 1Makefile:982: recipe for target 'prepare0' failedmake: *** [prepare0] Error 2 可是又报错了，提示说是找不到 libstdc++.so.6 这个库。安装一下试试： 1user@vmware:~/workspace/mini2440/linux-2.6.32.2$ sudo apt-get install lib32stdc++6 库安装好了之后，果然可以开始编译了。 12345678910user@vmware:~/workspace/mini2440/linux-2.6.32.2$ make... ... ... ... CC kernel/exit.o CC kernel/itimer.o TIMEC kernel/timeconst.hCan&apos;t use &apos;defined(@array)&apos; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373./home/user/workspace/mini2440/linux-2.6.32.2/kernel/Makefile:129: recipe for target &apos;kernel/timeconst.h&apos; failedmake[1]: *** [kernel/timeconst.h] Error 255Makefile:878: recipe for target &apos;kernel&apos; failedmake: *** [kernel] Error 2 可是又报错了，看提示说 ‘defined(@array)’语法有问题，将 kernel/timeconst.pl 文件中 373 行 “if (!defined(@val)) {“ 修改为 “if (!@val) {“ 后编译成功。 12345678910111213diff --git a/kernel/timeconst.pl b/kernel/timeconst.plindex eb51d76..0461239 100644--- a/kernel/timeconst.pl+++ b/kernel/timeconst.pl@@ -370,7 +370,7 @@ if ($hz eq &apos;--can&apos;) &#123; &#125; @val = @&#123;$canned_values&#123;$hz&#125;&#125;;- if (!defined(@val)) &#123;+ if (!@val) &#123; @val = compute_values($hz); &#125; output($hz, @val); 编译成功提示如下，同时会在 arch/arm/boot/ 目录下生成 zImage 内核镜像文件。 12345678910111213user@vmware:~/workspace/mini2440/linux-2.6.32.2$ make CHK include/linux/version.hmake[1]: 'include/asm-arm/mach-types.h' is up to date. CHK include/linux/utsrelease.h SYMLINK include/asm -&gt; include/asm-arm CALL scripts/checksyscalls.sh CHK include/linux/compile.h Kernel: arch/arm/boot/Image is ready Kernel: arch/arm/boot/zImage is ready Building modules, stage 2. MODPOST 16 modulesuser@vmware:~/workspace/mini2440/linux-2.6.32.2$ ls -l arch/arm/boot/zImage-rwxrwxr-x 1 user user 2330052 11月 25 03:10 arch/arm/boot/zImage 四. 使用 nfs 传输文件4.1 Ubuntu 安装 nfs 服务器NFS 介绍NFS 即网络文件系统(Network File-System),可以通过网络让不同机器、不同系统之间可以实现文件共享。通过 NFS,可以访问远程共享目录,就像访问本地磁盘一样。在 ubuntu 主机上安装 nfs 服务器，开发板便可以通过网络访问 ubuntu 主机上的共享的文件。 ubuntu 下安装 nfs 服务器。12user@vmware:~$ sudo apt-get install nfs-kernel-server # 安装 NFS 服务器端user@vmware:~$ sudo apt-get install nfs-common # 安装 NFS 客户端 配置 nfs 共享目录安装完 NFS 服务器后，需要指定共享的 NFS 目录，其方法是在 “/etc/exports” 文件里面设置对应的目录及相应的访问权限，每一行对应一个设置。配置 /home/user/board/ 目录为 nfs 共享的目录，需要修改 “/etc/exports” 文件，添加一行： 1/home/user/board/ *(rw,sync,no_root_squash) 建立 nfs 共享文件夹修改完成后,保存并退出 /etc/exports 文件。然后新建 /home/user/board 目录,并为该目录设置最宽松的权限: 123user@vmware:~$ sudo mkdir -p /home/user/boarduser@vmware:~$ sudo chmod -R 777 /home/user/boarduser@vmware:~$ sudo chown –R nobody /home/user/board 开启 nfs 服务器12user@vmware:~$ sudo /etc/init.d/nfs-kernel-server start # 开启 nfs 服务器user@vmware:~$ sudo /etc/init.d/nfs-kernel-server restart # 重启 nfs 服务器 4.2 开发板挂载 nfs 共享目录开发板接好网线，保证开发板和虚拟机在同一个局域网下，执行以下命令，挂载 /home/user/board 目录到开发板的 /mnt 目录下。 12[root@FriendlyARM /]# ifconfig eth0 192.168.1.111[root@FriendlyARM /]# mount -t nfs 192.168.1.110:/home/user/board /mnt -o nolock 其中 192.168.1.100 是 Ubuntu 虚拟机 ip 地址，/home/user/board 是虚拟机 nfs 服务器共享的目录。]]></content>
      <categories>
        <category>Mini2440</category>
      </categories>
      <tags>
        <tag>mini2440</tag>
        <tag>FrindlyARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ubuntu] 开始使用 Ubuntu]]></title>
    <url>%2F2018%2F01%2F08%2Fubuntu-start-using-ubuntu%2F</url>
    <content type="text"><![CDATA[一. 系统配置 设置 root 用户密码 sudo passwd root 安装 32 位兼容库经常会遇到 gcc 安装好了，环境变量配置好了，但是就是 arm-none-eabi-gcc -v 显示找不到命令，其实就是在 64 位的 ubuntu 下没有装 32 位兼容库，导致 32 的 arm-none-eabi-gcc 无法正常运行。 sudo apt-get install lib32ncurses5 sudo apt-get install lib32z1 安装 ncurses 基本库ncurses 是字符终端下屏幕控制的基本库。可能很多新开发的程序都不使用了，不过如果要编译一些老程序，还经常遇得到。编译 kernel 和 u-boot 时 make menuconfig 命令就需要这个库。 sudo apt-get install libncurses5-dev 修改家目录文件夹名倘若安装 ubuntu 的时候选择的语言是中文，则家目录下的文件夹名都是中文名称，这样在控制台 cd 切入子目录下要输入中文，很不方便。要是是英文的话就方便多了，但是我们直接将家目录下的文件家改为英文名后，之前的桌面、下载、文档等目录就全部都变成了家目录。其他的目录都还好，但是桌面变成了家目录，导致家目录下的所有文件都暴露在桌面上，很不开心。那怎么手动去指定桌面、文档、下载等文件夹的路径呢？需要修改一个配置文件，该配置文件路径为： user@vmware:~$ vim ~/.config/user-dirs.dirs 修改此文件中的 XDG_xxx_DIR 对应的目录便可以指定桌面、文档、下载等文件夹的路径。这里有一段注释，简单翻译一下：此文件由 xdg-user-dirs-update 编写，如果你想要增加或者改变一下家目录下的目录结构，只需编辑你感兴趣的那一行。所有本地更改将在下次运行(重启)时生效。每一行的格式是 XDG_xxx_DIR =”$ HOME/yyy” 相对路径，或着 XDG_xxx_DIR = “/yyy” 绝对路径，不支持其他格式。所以这里这样就搞定了，但是要生效的话需要重启。 二. 软件安装2.1 apt-get 安装常用软件 更新软件源 sudo apt-get update 文本编辑器 Vim sudo apt-get install vim-nox pdf 阅读器 okular sudo apt-get install okular 截图工具 shutter sudo apt-get install shutter 视频播放器 VLC sudo apt-get install vlc 版本控制工具 git sudo apt-get install git 2.2 deb 格式的常用软件 搜狗输入法 sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb sudo apt-get install -f sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb 设置 -&gt; 文本输入 -&gt; 拼音 -&gt; 设置齿轮按钮 -&gt; 删除其他输入法，只保留搜狗输入法和美式键盘，可以将搜狗输入法配置为默认输入法。 文本编辑器 Atom sudo dpkg -i atom-amd64.deb sudo apt-get install -f sudo dpkg -i atom-amd64.deb 音乐播放器网易云音乐 sudo dpkg -i netease-cloud-music_1.0.0-2_amd64_ubuntu16.04.deb sudo apt-get install -f sudo dpkg -i netease-cloud-music_1.0.0-2_amd64_ubuntu16.04.deb 2.3 tar 格式常用软件 邮箱客户端 Thunderbird下载解压，直接运行即可。配置时需要注意一点，163登录不是直接用邮箱密码，而是使用授权密码。 sudo tar -jxf thunderbird-52.4.0.tar.bz2 -C /opt/ cd /opt/thunderbird/ ./thunderbird 三. 常用服务3.1 安装 ssh 服务 ssh 介绍SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。一般我们在 windows 主机上使用远程登陆工具(Xshell等)登陆 linux 主机都是使用的 ssh 协议。 安装 ssh 服务器 user@vmware:~$ sudo apt-get install openssh-server 测试 ssh 服务器配置好 windows 和 ubuntu 在同一个局域网中，在 windows 下安装 xshell 远程登录工具，远程登录到 ubuntu。看是否能够成功登陆。 3.2 安装 nfs 服务器 nfs 介绍NFS 即网络文件系统(Network File-System)，可以通过网络让不同机器、不同系统之间可以实现文件共享。通过 NFS，可以访问远程共享目录,就像访问本地磁盘一样。在 ubuntu 主机上安装 nfs 服务器，开发板便可以通过网络访问 ubuntu 主机上的共享的文件。 nfs 服务器 user@vmware:~$ sudo apt-get install nfs-kernel-server # 安装 NFS 服务器端 user@vmware:~$ sudo apt-get install nfs-common # 安装 NFS 客户端 配置 nfs 共享目录安装完 NFS 服务器后，需要指定共享的 NFS 目录，其方法是在 “/etc/exports” 文件里面设置对应的目录及相应的访问权限，每一行对应一个设置。配置 /home/user/board/ 目录为 nfs 共享的目录，需要修改 “/etc/exports” 文件，添加一行 /home/user/board/ *(rw,sync,no_root_squash) 建立 nfs 共享文件夹修改完成后,保存并退出 /etc/exports 文件。然后新建 /home/user/board 目录,并为该目录设置最宽松的权限: user@vmware:~$ sudo mkdir -p /home/user/board user@vmware:~$ sudo chmod -R 777 /home/user/board user@vmware:~$ sudo chown –R nobody /home/user/board 启动 nfs 服务器 user@vmware:~$ sudo /etc/init.d/nfs-kernel-server start # 开启 nfs 服务器 user@vmware:~$ sudo /etc/init.d/nfs-kernel-server restart # 重启 nfs 服务器 测试 nfs 服务器开发板接好网线，保证开发板和虚拟机在同一个局域网下，执行以下命令，挂载 /home/user/board 目录到开发板的 /mnt 目录下。 [root@FriendlyARM /]# sudo mount -t nfs 192.168.1.110:/home/user/board /mnt -o nolock 其中 192.168.1.100 是 Ubuntu 虚拟机 ip 地址，/home/user/board 是虚拟机 nfs 服务器共享的目录。 3.3 安装 samba 服务器 samba 介绍Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。 安装 samba 服务器 user@vmware:~$ sudo apt-get install samba 配置 samba 选项 user@vmware:~$ sudo vim /etc/samba/smb.conf 配置文件追加： [Ubuntu] # windows 映射网络位置时显示的文件夹名 comment = ubuntu share # 提示信息，不重要，随便写个字符串就好了 path = /home/user/workspace/ # 用于共享的虚拟机文件夹路径 writable = yes # windows 映射后是否可写 browseable = yes # windows 映射后是否可浏览 设置 samba 用户 user@vmware:~$ sudo smbpasswd -a user 重启 samba 服务器 user@vmware:~$ sudo /etc/init.d/smbd restart user@vmware:~$ sudo /etc/init.d/nmbd restart 映射 samba 网络位置]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ubuntu] 使用 VMware 虚拟机安装 Ubuntu 系统]]></title>
    <url>%2F2018%2F01%2F01%2Fubuntu-install-ubuntu-by-vmware%2F</url>
    <content type="text"><![CDATA[一. 下载安装 VMware1.1 VMware 介绍VMware 就是我们俗称的虚拟机，通过这个软件我们可以模拟出一台或者多台 PC 机，就好像我们买了很多台电脑一样。我们可以在这些虚拟出来的 PC 机上安装我们的操作系统，可以安装 windows、ubuntu、fedora 等操作系统。然后在运行这个装好了操作系统的 PC 机，将这些主机给虚拟出来，就拥有很多台的 PC 主机。 1.2 下载 VMware 软件百度搜索 VMware 关键字，在百度软件中心可以获取到 VMware 安装包，这里下载的是 12.5.7 版本的 VMware。 下载后将会得到一个 exe 的安装包，如下图。 1.3 安装 VMware 软件双击执行刚刚下载的可执行文件，进入安装向导界面。 同意许可协议，不同意不让你安装。 选择软件的安装位置，我一般习惯性将 C 改成 D，保持子路径不变。 选择是否启动自动检查更新和反馈数据，这两个勾一般我都是不勾的，你们自己看心情。 选择是否创建相应的快捷方式。 配置好了，要开始安装了。 正在安装界面。 安装好了，可以选择直接退出，或者输入产品密钥。这里为了方便日后使用，一并激活一下这个软件。 百度搜索 “vmware workstation 12 密钥” 可以看到一大串的密钥，随便找一个用都是可以用的。 输入许可证。 至此，VMware 软件安装完成。 二. 使用 VMware 创建一台虚拟机2.1 使用 VMware 创建一台虚拟机使用 VMware 创建一台虚拟机，这个动作就好比，我们新买了一台电脑，有主板、硬盘、网卡、内存等具体的设备，是一套硬件系统，只不过这些东西都是虚拟出来的。买了电脑之后，我们就可以装自己想要运行的操作系统了，又拥有了一台电脑，是不是很开心。 2.2 新建虚拟机具体步骤运行 VMware 软件，点击新建虚拟机。 随后进入虚拟机配置向导。这里选择虚拟机的配置类型，一般都是典型安装，高级要配置的东西太多了。 选择是否同时安装操作系统，这个时候同步安装操作系统将会采取简易安装，建议稍后在手动安装操作系统。 选择好这台虚拟机将会安装哪种操作系统，注意区分 32/64 位。 配置虚拟机名称以及虚拟机在物理磁盘上保存的路径。 设置虚拟机的硬盘大小。 点击完成，新的虚拟机将按照之前的配置创建。 至此，一台新的虚拟机创建成功，创建成功左侧导航栏会有相应的虚拟机选项。 三. 获取 Ubuntu 16.04 LTS3.1 从官网获取最新的 Ubuntu百度搜索 ubuntu 关键字，进入 ubuntu 官网。 Ubuntu 为了方便广大中国用户，推出了中文的官方网站。由于在 Ubuntu 官网下载 ubuntu 网速太慢，需要 VPN 才能流畅下载，因此，这里我们进入中文官网，方便下载。 进入中文官网，点击下载。 下载 64 位版本，或者 32 位版本都行，看你心情。 点击对应下载按钮将会弹出下载对话框，开始下载就好。我用的是火狐浏览器，其他浏览器可能直接开始下载了。 下载好之后得到 ubuntu iso 镜像包。 四. 虚拟机安装 ubuntu 操作系统4.1 使用虚拟机安装 Ubuntu 16.04运行 VMware 软件，点击编辑虚拟机设置，可以修改虚拟机的硬件配置。 在运行虚拟机之前，将下载好的 Ubuntu 镜像加载到光驱中。这样开机便可以从光驱中运行 Ubuntu 安装程序。 配置好了光驱，开启虚拟机，开始安装 Ubuntu。 开机后出现 Ubuntu logo 界面，说明已经进入了 Ubuntu 安装程序。 左侧选择好 Ubuntu 的语言，点击右方 Install Ubuntu 按钮开始安装。 这里选择的是安装时是否同步下载更新，还有就是是否安装第三方媒体库，我一般不选，因为这样会增加安装时间。复选框都不勾选，然后点击 Continue。 选择磁盘如何处理，可以擦除整个磁盘然后装 Ubuntu，也可以自己自定义分区，在指定的分区中安装 Ubuntu。由于使用虚拟机安装，就不自定义分区了，直接全擦后安装 Ubuntu，这样方便。如果是安装 Windows 和 Ubuntu 双系统的话，建议还是自己自定义分区。 这是一个二次确认的对话框，确认要全擦？然后哪些分区将被创建会列举出来。 选择位置。 选择键盘布局，我们一般都是用的美式布局的键盘，默认就可以了。 配置好用户名和主机名以及登录密码。 开始安装了，耐心等待一会。 安装完毕，提示要重启，这个时候直接关闭虚拟机，直接关机，不要重启。 进入虚拟机配置界面，将光驱的配置修改回来，不修改回来的话将无法进入 Ubuntu 系统。 至此 Ubuntu 16.04 LTS 成功安装 五. 虚拟机安装 VM Tools5.1 VMware Tools 有什么用？安装 VMware Tools 后，最简单直观的体验就是可以从物理主机直接往虚拟机里面拖文件。我们学习嵌入式大都是在 Windows 下阅读、编辑源代码，而编译的过程则是放在 Ubuntu 虚拟机中的。这必然涉及到文件的传输，安装 VMware Tools 之后将极大的方便虚拟机和主机之间的文件传输。 5.2 安装 VMware Tools开始安装 VMware Tools 点击之后 Ubuntu 将会加载一个光盘，其中 tar.gz 格式的文件就是 VMware Tools 对应的安装文件。 Ubuntu 中使用 Ctrl + Alt + T 调起终端，依次输入以下命令开始安装 VMware Tools。 期间或有很多的安装提示选项，除了第一个选项问你是否要安装此程序，默认是 no，安装时需要输入 y 或 yes 以外，其他的安装选项默认即可，安装成功后截图如下。 5.3 配置虚拟机共享文件夹在开启虚拟机之前，先按照下图配置虚拟机共享文件夹。通过配置共享文件夹，ubuntu 可以通过访问 /mnt/hgfs/Share 目录访问 windows 下的 E:\Share 目录。其中，/mnt/hgfs/Share 中的最后一级目录 Share 是下图中配置的名称，E:\Share 中的 Share 是下图中配置的主机路径。 例如我在 /mnt/hgfs/Share 目录下创建了一个 demo 文件。 然后打开 Windows 下的 E:\Share 目录下查看，发现确实有了 demo 文件。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
</search>
